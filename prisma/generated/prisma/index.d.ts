
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BarberProfile
 * 
 */
export type BarberProfile = $Result.DefaultSelection<Prisma.$BarberProfilePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model BarberProfileToService
 * 
 */
export type BarberProfileToService = $Result.DefaultSelection<Prisma.$BarberProfileToServicePayload>
/**
 * Model BookingService
 * 
 */
export type BookingService = $Result.DefaultSelection<Prisma.$BookingServicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model DisabledDay
 * 
 */
export type DisabledDay = $Result.DefaultSelection<Prisma.$DisabledDayPayload>
/**
 * Model DisabledTime
 * 
 */
export type DisabledTime = $Result.DefaultSelection<Prisma.$DisabledTimePayload>
/**
 * Model ExtraTimeDay
 * 
 */
export type ExtraTimeDay = $Result.DefaultSelection<Prisma.$ExtraTimeDayPayload>
/**
 * Model PointSystem
 * 
 */
export type PointSystem = $Result.DefaultSelection<Prisma.$PointSystemPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model PointTransaction
 * 
 */
export type PointTransaction = $Result.DefaultSelection<Prisma.$PointTransactionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ClientPlan
 * 
 */
export type ClientPlan = $Result.DefaultSelection<Prisma.$ClientPlanPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanToService
 * 
 */
export type PlanToService = $Result.DefaultSelection<Prisma.$PlanToServicePayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const NotificationRecipient: {
  BARBER: 'BARBER',
  USER: 'USER'
};

export type NotificationRecipient = (typeof NotificationRecipient)[keyof typeof NotificationRecipient]


export const NotificationType: {
  COUPON_REDEEMED: 'COUPON_REDEEMED',
  POINTS_PENDING: 'POINTS_PENDING',
  POINTS_CONFIRMED: 'POINTS_CONFIRMED',
  POINTS_REJECTED: 'POINTS_REJECTED',
  POINTS_ADJUSTED: 'POINTS_ADJUSTED',
  BOOKING_CREATED: 'BOOKING_CREATED',
  BOOKING_EDITED: 'BOOKING_EDITED',
  BOOKING_CANCELLED: 'BOOKING_CANCELLED',
  BOOKING_REMINDER: 'BOOKING_REMINDER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionType: {
  EARNED: 'EARNED',
  REDEEMED: 'REDEEMED',
  EXPIRED: 'EXPIRED',
  ADJUSTED: 'ADJUSTED'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const Role: {
  USER: 'USER',
  BARBER: 'BARBER',
  ADMIN: 'ADMIN',
  SUPERADMIN: 'SUPERADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELED: 'CANCELED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const TransactionStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  REJECTED: 'REJECTED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]

}

export type NotificationRecipient = $Enums.NotificationRecipient

export const NotificationRecipient: typeof $Enums.NotificationRecipient

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barberProfile`: Exposes CRUD operations for the **BarberProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarberProfiles
    * const barberProfiles = await prisma.barberProfile.findMany()
    * ```
    */
  get barberProfile(): Prisma.BarberProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barberProfileToService`: Exposes CRUD operations for the **BarberProfileToService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BarberProfileToServices
    * const barberProfileToServices = await prisma.barberProfileToService.findMany()
    * ```
    */
  get barberProfileToService(): Prisma.BarberProfileToServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingService`: Exposes CRUD operations for the **BookingService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingServices
    * const bookingServices = await prisma.bookingService.findMany()
    * ```
    */
  get bookingService(): Prisma.BookingServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disabledDay`: Exposes CRUD operations for the **DisabledDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisabledDays
    * const disabledDays = await prisma.disabledDay.findMany()
    * ```
    */
  get disabledDay(): Prisma.DisabledDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disabledTime`: Exposes CRUD operations for the **DisabledTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisabledTimes
    * const disabledTimes = await prisma.disabledTime.findMany()
    * ```
    */
  get disabledTime(): Prisma.DisabledTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extraTimeDay`: Exposes CRUD operations for the **ExtraTimeDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtraTimeDays
    * const extraTimeDays = await prisma.extraTimeDay.findMany()
    * ```
    */
  get extraTimeDay(): Prisma.ExtraTimeDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointSystem`: Exposes CRUD operations for the **PointSystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointSystems
    * const pointSystems = await prisma.pointSystem.findMany()
    * ```
    */
  get pointSystem(): Prisma.PointSystemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointTransaction`: Exposes CRUD operations for the **PointTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointTransactions
    * const pointTransactions = await prisma.pointTransaction.findMany()
    * ```
    */
  get pointTransaction(): Prisma.PointTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientPlan`: Exposes CRUD operations for the **ClientPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientPlans
    * const clientPlans = await prisma.clientPlan.findMany()
    * ```
    */
  get clientPlan(): Prisma.ClientPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planToService`: Exposes CRUD operations for the **PlanToService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanToServices
    * const planToServices = await prisma.planToService.findMany()
    * ```
    */
  get planToService(): Prisma.PlanToServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    BarberProfile: 'BarberProfile',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Service: 'Service',
    BarberProfileToService: 'BarberProfileToService',
    BookingService: 'BookingService',
    Booking: 'Booking',
    DisabledDay: 'DisabledDay',
    DisabledTime: 'DisabledTime',
    ExtraTimeDay: 'ExtraTimeDay',
    PointSystem: 'PointSystem',
    Coupon: 'Coupon',
    PointTransaction: 'PointTransaction',
    Notification: 'Notification',
    ClientPlan: 'ClientPlan',
    Plan: 'Plan',
    PlanToService: 'PlanToService',
    PushSubscription: 'PushSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "barberProfile" | "account" | "session" | "verificationToken" | "service" | "barberProfileToService" | "bookingService" | "booking" | "disabledDay" | "disabledTime" | "extraTimeDay" | "pointSystem" | "coupon" | "pointTransaction" | "notification" | "clientPlan" | "plan" | "planToService" | "pushSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BarberProfile: {
        payload: Prisma.$BarberProfilePayload<ExtArgs>
        fields: Prisma.BarberProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarberProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarberProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          findFirst: {
            args: Prisma.BarberProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarberProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          findMany: {
            args: Prisma.BarberProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>[]
          }
          create: {
            args: Prisma.BarberProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          createMany: {
            args: Prisma.BarberProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarberProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>[]
          }
          delete: {
            args: Prisma.BarberProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          update: {
            args: Prisma.BarberProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          deleteMany: {
            args: Prisma.BarberProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarberProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarberProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>[]
          }
          upsert: {
            args: Prisma.BarberProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfilePayload>
          }
          aggregate: {
            args: Prisma.BarberProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarberProfile>
          }
          groupBy: {
            args: Prisma.BarberProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarberProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarberProfileCountArgs<ExtArgs>
            result: $Utils.Optional<BarberProfileCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      BarberProfileToService: {
        payload: Prisma.$BarberProfileToServicePayload<ExtArgs>
        fields: Prisma.BarberProfileToServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BarberProfileToServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BarberProfileToServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          findFirst: {
            args: Prisma.BarberProfileToServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BarberProfileToServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          findMany: {
            args: Prisma.BarberProfileToServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>[]
          }
          create: {
            args: Prisma.BarberProfileToServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          createMany: {
            args: Prisma.BarberProfileToServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BarberProfileToServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>[]
          }
          delete: {
            args: Prisma.BarberProfileToServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          update: {
            args: Prisma.BarberProfileToServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          deleteMany: {
            args: Prisma.BarberProfileToServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BarberProfileToServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BarberProfileToServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>[]
          }
          upsert: {
            args: Prisma.BarberProfileToServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BarberProfileToServicePayload>
          }
          aggregate: {
            args: Prisma.BarberProfileToServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBarberProfileToService>
          }
          groupBy: {
            args: Prisma.BarberProfileToServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BarberProfileToServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BarberProfileToServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BarberProfileToServiceCountAggregateOutputType> | number
          }
        }
      }
      BookingService: {
        payload: Prisma.$BookingServicePayload<ExtArgs>
        fields: Prisma.BookingServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findFirst: {
            args: Prisma.BookingServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findMany: {
            args: Prisma.BookingServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          create: {
            args: Prisma.BookingServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          createMany: {
            args: Prisma.BookingServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          delete: {
            args: Prisma.BookingServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          update: {
            args: Prisma.BookingServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          deleteMany: {
            args: Prisma.BookingServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          upsert: {
            args: Prisma.BookingServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          aggregate: {
            args: Prisma.BookingServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingService>
          }
          groupBy: {
            args: Prisma.BookingServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      DisabledDay: {
        payload: Prisma.$DisabledDayPayload<ExtArgs>
        fields: Prisma.DisabledDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisabledDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisabledDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          findFirst: {
            args: Prisma.DisabledDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisabledDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          findMany: {
            args: Prisma.DisabledDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>[]
          }
          create: {
            args: Prisma.DisabledDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          createMany: {
            args: Prisma.DisabledDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisabledDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>[]
          }
          delete: {
            args: Prisma.DisabledDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          update: {
            args: Prisma.DisabledDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          deleteMany: {
            args: Prisma.DisabledDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisabledDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisabledDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>[]
          }
          upsert: {
            args: Prisma.DisabledDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledDayPayload>
          }
          aggregate: {
            args: Prisma.DisabledDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisabledDay>
          }
          groupBy: {
            args: Prisma.DisabledDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisabledDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisabledDayCountArgs<ExtArgs>
            result: $Utils.Optional<DisabledDayCountAggregateOutputType> | number
          }
        }
      }
      DisabledTime: {
        payload: Prisma.$DisabledTimePayload<ExtArgs>
        fields: Prisma.DisabledTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisabledTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisabledTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          findFirst: {
            args: Prisma.DisabledTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisabledTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          findMany: {
            args: Prisma.DisabledTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>[]
          }
          create: {
            args: Prisma.DisabledTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          createMany: {
            args: Prisma.DisabledTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisabledTimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>[]
          }
          delete: {
            args: Prisma.DisabledTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          update: {
            args: Prisma.DisabledTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          deleteMany: {
            args: Prisma.DisabledTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisabledTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisabledTimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>[]
          }
          upsert: {
            args: Prisma.DisabledTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisabledTimePayload>
          }
          aggregate: {
            args: Prisma.DisabledTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisabledTime>
          }
          groupBy: {
            args: Prisma.DisabledTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisabledTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisabledTimeCountArgs<ExtArgs>
            result: $Utils.Optional<DisabledTimeCountAggregateOutputType> | number
          }
        }
      }
      ExtraTimeDay: {
        payload: Prisma.$ExtraTimeDayPayload<ExtArgs>
        fields: Prisma.ExtraTimeDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtraTimeDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtraTimeDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          findFirst: {
            args: Prisma.ExtraTimeDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtraTimeDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          findMany: {
            args: Prisma.ExtraTimeDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>[]
          }
          create: {
            args: Prisma.ExtraTimeDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          createMany: {
            args: Prisma.ExtraTimeDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtraTimeDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>[]
          }
          delete: {
            args: Prisma.ExtraTimeDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          update: {
            args: Prisma.ExtraTimeDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          deleteMany: {
            args: Prisma.ExtraTimeDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtraTimeDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExtraTimeDayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>[]
          }
          upsert: {
            args: Prisma.ExtraTimeDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtraTimeDayPayload>
          }
          aggregate: {
            args: Prisma.ExtraTimeDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtraTimeDay>
          }
          groupBy: {
            args: Prisma.ExtraTimeDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtraTimeDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtraTimeDayCountArgs<ExtArgs>
            result: $Utils.Optional<ExtraTimeDayCountAggregateOutputType> | number
          }
        }
      }
      PointSystem: {
        payload: Prisma.$PointSystemPayload<ExtArgs>
        fields: Prisma.PointSystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointSystemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointSystemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          findFirst: {
            args: Prisma.PointSystemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointSystemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          findMany: {
            args: Prisma.PointSystemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>[]
          }
          create: {
            args: Prisma.PointSystemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          createMany: {
            args: Prisma.PointSystemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointSystemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>[]
          }
          delete: {
            args: Prisma.PointSystemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          update: {
            args: Prisma.PointSystemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          deleteMany: {
            args: Prisma.PointSystemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointSystemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointSystemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>[]
          }
          upsert: {
            args: Prisma.PointSystemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointSystemPayload>
          }
          aggregate: {
            args: Prisma.PointSystemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointSystem>
          }
          groupBy: {
            args: Prisma.PointSystemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointSystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointSystemCountArgs<ExtArgs>
            result: $Utils.Optional<PointSystemCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      PointTransaction: {
        payload: Prisma.$PointTransactionPayload<ExtArgs>
        fields: Prisma.PointTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findFirst: {
            args: Prisma.PointTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          findMany: {
            args: Prisma.PointTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          create: {
            args: Prisma.PointTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          createMany: {
            args: Prisma.PointTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          delete: {
            args: Prisma.PointTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          update: {
            args: Prisma.PointTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PointTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PointTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointTransactionPayload>
          }
          aggregate: {
            args: Prisma.PointTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointTransaction>
          }
          groupBy: {
            args: Prisma.PointTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PointTransactionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ClientPlan: {
        payload: Prisma.$ClientPlanPayload<ExtArgs>
        fields: Prisma.ClientPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          findFirst: {
            args: Prisma.ClientPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          findMany: {
            args: Prisma.ClientPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>[]
          }
          create: {
            args: Prisma.ClientPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          createMany: {
            args: Prisma.ClientPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>[]
          }
          delete: {
            args: Prisma.ClientPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          update: {
            args: Prisma.ClientPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          deleteMany: {
            args: Prisma.ClientPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>[]
          }
          upsert: {
            args: Prisma.ClientPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPlanPayload>
          }
          aggregate: {
            args: Prisma.ClientPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientPlan>
          }
          groupBy: {
            args: Prisma.ClientPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ClientPlanCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanToService: {
        payload: Prisma.$PlanToServicePayload<ExtArgs>
        fields: Prisma.PlanToServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanToServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanToServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          findFirst: {
            args: Prisma.PlanToServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanToServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          findMany: {
            args: Prisma.PlanToServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>[]
          }
          create: {
            args: Prisma.PlanToServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          createMany: {
            args: Prisma.PlanToServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanToServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>[]
          }
          delete: {
            args: Prisma.PlanToServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          update: {
            args: Prisma.PlanToServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          deleteMany: {
            args: Prisma.PlanToServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanToServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanToServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>[]
          }
          upsert: {
            args: Prisma.PlanToServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanToServicePayload>
          }
          aggregate: {
            args: Prisma.PlanToServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanToService>
          }
          groupBy: {
            args: Prisma.PlanToServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanToServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanToServiceCountArgs<ExtArgs>
            result: $Utils.Optional<PlanToServiceCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    barberProfile?: BarberProfileOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    service?: ServiceOmit
    barberProfileToService?: BarberProfileToServiceOmit
    bookingService?: BookingServiceOmit
    booking?: BookingOmit
    disabledDay?: DisabledDayOmit
    disabledTime?: DisabledTimeOmit
    extraTimeDay?: ExtraTimeDayOmit
    pointSystem?: PointSystemOmit
    coupon?: CouponOmit
    pointTransaction?: PointTransactionOmit
    notification?: NotificationOmit
    clientPlan?: ClientPlanOmit
    plan?: PlanOmit
    planToService?: PlanToServiceOmit
    pushSubscription?: PushSubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    bookings: number
    sessions: number
    notifications: number
    pushSubscriptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }


  /**
   * Count Type BarberProfileCountOutputType
   */

  export type BarberProfileCountOutputType = {
    bookings: number
    services: number
    disabledDays: number
    clientPlans: number
    plans: number
    extraTimeDays: number
    disabledTimes: number
    notifications: number
  }

  export type BarberProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | BarberProfileCountOutputTypeCountBookingsArgs
    services?: boolean | BarberProfileCountOutputTypeCountServicesArgs
    disabledDays?: boolean | BarberProfileCountOutputTypeCountDisabledDaysArgs
    clientPlans?: boolean | BarberProfileCountOutputTypeCountClientPlansArgs
    plans?: boolean | BarberProfileCountOutputTypeCountPlansArgs
    extraTimeDays?: boolean | BarberProfileCountOutputTypeCountExtraTimeDaysArgs
    disabledTimes?: boolean | BarberProfileCountOutputTypeCountDisabledTimesArgs
    notifications?: boolean | BarberProfileCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileCountOutputType
     */
    select?: BarberProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarberProfileToServiceWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountDisabledDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisabledDayWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountClientPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPlanWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountExtraTimeDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraTimeDayWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountDisabledTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisabledTimeWhereInput
  }

  /**
   * BarberProfileCountOutputType without action
   */
  export type BarberProfileCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookings: number
    barbers: number
    planToService: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
    barbers?: boolean | ServiceCountOutputTypeCountBarbersArgs
    planToService?: boolean | ServiceCountOutputTypeCountPlanToServiceArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBarbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarberProfileToServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPlanToServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanToServiceWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    services: number
    notifications: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | BookingCountOutputTypeCountServicesArgs
    notifications?: boolean | BookingCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PointSystemCountOutputType
   */

  export type PointSystemCountOutputType = {
    coupons: number
    pointTransactions: number
  }

  export type PointSystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupons?: boolean | PointSystemCountOutputTypeCountCouponsArgs
    pointTransactions?: boolean | PointSystemCountOutputTypeCountPointTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PointSystemCountOutputType without action
   */
  export type PointSystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystemCountOutputType
     */
    select?: PointSystemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PointSystemCountOutputType without action
   */
  export type PointSystemCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }

  /**
   * PointSystemCountOutputType without action
   */
  export type PointSystemCountOutputTypeCountPointTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    notifications: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | CouponCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PointTransactionCountOutputType
   */

  export type PointTransactionCountOutputType = {
    notifications: number
  }

  export type PointTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | PointTransactionCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PointTransactionCountOutputType without action
   */
  export type PointTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransactionCountOutputType
     */
    select?: PointTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PointTransactionCountOutputType without action
   */
  export type PointTransactionCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ClientPlanCountOutputType
   */

  export type ClientPlanCountOutputType = {
    booking: number
  }

  export type ClientPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ClientPlanCountOutputTypeCountBookingArgs
  }

  // Custom InputTypes
  /**
   * ClientPlanCountOutputType without action
   */
  export type ClientPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlanCountOutputType
     */
    select?: ClientPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientPlanCountOutputType without action
   */
  export type ClientPlanCountOutputTypeCountBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    planToService: number
    clientPlans: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planToService?: boolean | PlanCountOutputTypeCountPlanToServiceArgs
    clientPlans?: boolean | PlanCountOutputTypeCountClientPlansArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountPlanToServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanToServiceWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountClientPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPlanWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    phone: string | null
    createdAt: Date | null
    role: $Enums.Role | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    phone: string | null
    createdAt: Date | null
    role: $Enums.Role | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    phone: number
    createdAt: number
    role: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    phone?: true
    createdAt?: true
    role?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    phone?: true
    createdAt?: true
    role?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    phone?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    phone: string | null
    createdAt: Date
    role: $Enums.Role
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    phone?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    barberProfile?: boolean | User$barberProfileArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    pointSystem?: boolean | User$pointSystemArgs<ExtArgs>
    plan?: boolean | User$planArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    phone?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    phone?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    phone?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "phone" | "createdAt" | "role" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    barberProfile?: boolean | User$barberProfileArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    pointSystem?: boolean | User$pointSystemArgs<ExtArgs>
    plan?: boolean | User$planArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      barberProfile: Prisma.$BarberProfilePayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      pointSystem: Prisma.$PointSystemPayload<ExtArgs> | null
      plan: Prisma.$ClientPlanPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      phone: string | null
      createdAt: Date
      role: $Enums.Role
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barberProfile<T extends User$barberProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$barberProfileArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointSystem<T extends User$pointSystemArgs<ExtArgs> = {}>(args?: Subset<T, User$pointSystemArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plan<T extends User$planArgs<ExtArgs> = {}>(args?: Subset<T, User$planArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.barberProfile
   */
  export type User$barberProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    where?: BarberProfileWhereInput
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.pointSystem
   */
  export type User$pointSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    where?: PointSystemWhereInput
  }

  /**
   * User.plan
   */
  export type User$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    where?: ClientPlanWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BarberProfile
   */

  export type AggregateBarberProfile = {
    _count: BarberProfileCountAggregateOutputType | null
    _avg: BarberProfileAvgAggregateOutputType | null
    _sum: BarberProfileSumAggregateOutputType | null
    _min: BarberProfileMinAggregateOutputType | null
    _max: BarberProfileMaxAggregateOutputType | null
  }

  export type BarberProfileAvgAggregateOutputType = {
    timeInterval: number | null
  }

  export type BarberProfileSumAggregateOutputType = {
    timeInterval: number | null
  }

  export type BarberProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    timeInterval: number | null
    createdAt: Date | null
  }

  export type BarberProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    bio: string | null
    timeInterval: number | null
    createdAt: Date | null
  }

  export type BarberProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    bio: number
    timeInterval: number
    createdAt: number
    _all: number
  }


  export type BarberProfileAvgAggregateInputType = {
    timeInterval?: true
  }

  export type BarberProfileSumAggregateInputType = {
    timeInterval?: true
  }

  export type BarberProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    timeInterval?: true
    createdAt?: true
  }

  export type BarberProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    timeInterval?: true
    createdAt?: true
  }

  export type BarberProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    bio?: true
    timeInterval?: true
    createdAt?: true
    _all?: true
  }

  export type BarberProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarberProfile to aggregate.
     */
    where?: BarberProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfiles to fetch.
     */
    orderBy?: BarberProfileOrderByWithRelationInput | BarberProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarberProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarberProfiles
    **/
    _count?: true | BarberProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BarberProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BarberProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarberProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarberProfileMaxAggregateInputType
  }

  export type GetBarberProfileAggregateType<T extends BarberProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateBarberProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarberProfile[P]>
      : GetScalarType<T[P], AggregateBarberProfile[P]>
  }




  export type BarberProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarberProfileWhereInput
    orderBy?: BarberProfileOrderByWithAggregationInput | BarberProfileOrderByWithAggregationInput[]
    by: BarberProfileScalarFieldEnum[] | BarberProfileScalarFieldEnum
    having?: BarberProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarberProfileCountAggregateInputType | true
    _avg?: BarberProfileAvgAggregateInputType
    _sum?: BarberProfileSumAggregateInputType
    _min?: BarberProfileMinAggregateInputType
    _max?: BarberProfileMaxAggregateInputType
  }

  export type BarberProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string
    bio: string | null
    timeInterval: number
    createdAt: Date
    _count: BarberProfileCountAggregateOutputType | null
    _avg: BarberProfileAvgAggregateOutputType | null
    _sum: BarberProfileSumAggregateOutputType | null
    _min: BarberProfileMinAggregateOutputType | null
    _max: BarberProfileMaxAggregateOutputType | null
  }

  type GetBarberProfileGroupByPayload<T extends BarberProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarberProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarberProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarberProfileGroupByOutputType[P]>
            : GetScalarType<T[P], BarberProfileGroupByOutputType[P]>
        }
      >
    >


  export type BarberProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    timeInterval?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | BarberProfile$bookingsArgs<ExtArgs>
    services?: boolean | BarberProfile$servicesArgs<ExtArgs>
    disabledDays?: boolean | BarberProfile$disabledDaysArgs<ExtArgs>
    clientPlans?: boolean | BarberProfile$clientPlansArgs<ExtArgs>
    plans?: boolean | BarberProfile$plansArgs<ExtArgs>
    extraTimeDays?: boolean | BarberProfile$extraTimeDaysArgs<ExtArgs>
    disabledTimes?: boolean | BarberProfile$disabledTimesArgs<ExtArgs>
    notifications?: boolean | BarberProfile$notificationsArgs<ExtArgs>
    _count?: boolean | BarberProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfile"]>

  export type BarberProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    timeInterval?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfile"]>

  export type BarberProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    timeInterval?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfile"]>

  export type BarberProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    bio?: boolean
    timeInterval?: boolean
    createdAt?: boolean
  }

  export type BarberProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "displayName" | "bio" | "timeInterval" | "createdAt", ExtArgs["result"]["barberProfile"]>
  export type BarberProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | BarberProfile$bookingsArgs<ExtArgs>
    services?: boolean | BarberProfile$servicesArgs<ExtArgs>
    disabledDays?: boolean | BarberProfile$disabledDaysArgs<ExtArgs>
    clientPlans?: boolean | BarberProfile$clientPlansArgs<ExtArgs>
    plans?: boolean | BarberProfile$plansArgs<ExtArgs>
    extraTimeDays?: boolean | BarberProfile$extraTimeDaysArgs<ExtArgs>
    disabledTimes?: boolean | BarberProfile$disabledTimesArgs<ExtArgs>
    notifications?: boolean | BarberProfile$notificationsArgs<ExtArgs>
    _count?: boolean | BarberProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BarberProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BarberProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BarberProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarberProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      services: Prisma.$BarberProfileToServicePayload<ExtArgs>[]
      disabledDays: Prisma.$DisabledDayPayload<ExtArgs>[]
      clientPlans: Prisma.$ClientPlanPayload<ExtArgs>[]
      plans: Prisma.$PlanPayload<ExtArgs>[]
      extraTimeDays: Prisma.$ExtraTimeDayPayload<ExtArgs>[]
      disabledTimes: Prisma.$DisabledTimePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string
      bio: string | null
      timeInterval: number
      createdAt: Date
    }, ExtArgs["result"]["barberProfile"]>
    composites: {}
  }

  type BarberProfileGetPayload<S extends boolean | null | undefined | BarberProfileDefaultArgs> = $Result.GetResult<Prisma.$BarberProfilePayload, S>

  type BarberProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarberProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarberProfileCountAggregateInputType | true
    }

  export interface BarberProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarberProfile'], meta: { name: 'BarberProfile' } }
    /**
     * Find zero or one BarberProfile that matches the filter.
     * @param {BarberProfileFindUniqueArgs} args - Arguments to find a BarberProfile
     * @example
     * // Get one BarberProfile
     * const barberProfile = await prisma.barberProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarberProfileFindUniqueArgs>(args: SelectSubset<T, BarberProfileFindUniqueArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarberProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarberProfileFindUniqueOrThrowArgs} args - Arguments to find a BarberProfile
     * @example
     * // Get one BarberProfile
     * const barberProfile = await prisma.barberProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarberProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, BarberProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarberProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileFindFirstArgs} args - Arguments to find a BarberProfile
     * @example
     * // Get one BarberProfile
     * const barberProfile = await prisma.barberProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarberProfileFindFirstArgs>(args?: SelectSubset<T, BarberProfileFindFirstArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarberProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileFindFirstOrThrowArgs} args - Arguments to find a BarberProfile
     * @example
     * // Get one BarberProfile
     * const barberProfile = await prisma.barberProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarberProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, BarberProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarberProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarberProfiles
     * const barberProfiles = await prisma.barberProfile.findMany()
     * 
     * // Get first 10 BarberProfiles
     * const barberProfiles = await prisma.barberProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const barberProfileWithIdOnly = await prisma.barberProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BarberProfileFindManyArgs>(args?: SelectSubset<T, BarberProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarberProfile.
     * @param {BarberProfileCreateArgs} args - Arguments to create a BarberProfile.
     * @example
     * // Create one BarberProfile
     * const BarberProfile = await prisma.barberProfile.create({
     *   data: {
     *     // ... data to create a BarberProfile
     *   }
     * })
     * 
     */
    create<T extends BarberProfileCreateArgs>(args: SelectSubset<T, BarberProfileCreateArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarberProfiles.
     * @param {BarberProfileCreateManyArgs} args - Arguments to create many BarberProfiles.
     * @example
     * // Create many BarberProfiles
     * const barberProfile = await prisma.barberProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarberProfileCreateManyArgs>(args?: SelectSubset<T, BarberProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarberProfiles and returns the data saved in the database.
     * @param {BarberProfileCreateManyAndReturnArgs} args - Arguments to create many BarberProfiles.
     * @example
     * // Create many BarberProfiles
     * const barberProfile = await prisma.barberProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarberProfiles and only return the `id`
     * const barberProfileWithIdOnly = await prisma.barberProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarberProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, BarberProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarberProfile.
     * @param {BarberProfileDeleteArgs} args - Arguments to delete one BarberProfile.
     * @example
     * // Delete one BarberProfile
     * const BarberProfile = await prisma.barberProfile.delete({
     *   where: {
     *     // ... filter to delete one BarberProfile
     *   }
     * })
     * 
     */
    delete<T extends BarberProfileDeleteArgs>(args: SelectSubset<T, BarberProfileDeleteArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarberProfile.
     * @param {BarberProfileUpdateArgs} args - Arguments to update one BarberProfile.
     * @example
     * // Update one BarberProfile
     * const barberProfile = await prisma.barberProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarberProfileUpdateArgs>(args: SelectSubset<T, BarberProfileUpdateArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarberProfiles.
     * @param {BarberProfileDeleteManyArgs} args - Arguments to filter BarberProfiles to delete.
     * @example
     * // Delete a few BarberProfiles
     * const { count } = await prisma.barberProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarberProfileDeleteManyArgs>(args?: SelectSubset<T, BarberProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarberProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarberProfiles
     * const barberProfile = await prisma.barberProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarberProfileUpdateManyArgs>(args: SelectSubset<T, BarberProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarberProfiles and returns the data updated in the database.
     * @param {BarberProfileUpdateManyAndReturnArgs} args - Arguments to update many BarberProfiles.
     * @example
     * // Update many BarberProfiles
     * const barberProfile = await prisma.barberProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarberProfiles and only return the `id`
     * const barberProfileWithIdOnly = await prisma.barberProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarberProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, BarberProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarberProfile.
     * @param {BarberProfileUpsertArgs} args - Arguments to update or create a BarberProfile.
     * @example
     * // Update or create a BarberProfile
     * const barberProfile = await prisma.barberProfile.upsert({
     *   create: {
     *     // ... data to create a BarberProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarberProfile we want to update
     *   }
     * })
     */
    upsert<T extends BarberProfileUpsertArgs>(args: SelectSubset<T, BarberProfileUpsertArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarberProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileCountArgs} args - Arguments to filter BarberProfiles to count.
     * @example
     * // Count the number of BarberProfiles
     * const count = await prisma.barberProfile.count({
     *   where: {
     *     // ... the filter for the BarberProfiles we want to count
     *   }
     * })
    **/
    count<T extends BarberProfileCountArgs>(
      args?: Subset<T, BarberProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarberProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarberProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarberProfileAggregateArgs>(args: Subset<T, BarberProfileAggregateArgs>): Prisma.PrismaPromise<GetBarberProfileAggregateType<T>>

    /**
     * Group by BarberProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarberProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarberProfileGroupByArgs['orderBy'] }
        : { orderBy?: BarberProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarberProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarberProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarberProfile model
   */
  readonly fields: BarberProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarberProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarberProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends BarberProfile$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends BarberProfile$servicesArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disabledDays<T extends BarberProfile$disabledDaysArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$disabledDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientPlans<T extends BarberProfile$clientPlansArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$clientPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plans<T extends BarberProfile$plansArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    extraTimeDays<T extends BarberProfile$extraTimeDaysArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$extraTimeDaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disabledTimes<T extends BarberProfile$disabledTimesArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$disabledTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends BarberProfile$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfile$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarberProfile model
   */
  interface BarberProfileFieldRefs {
    readonly id: FieldRef<"BarberProfile", 'String'>
    readonly userId: FieldRef<"BarberProfile", 'String'>
    readonly displayName: FieldRef<"BarberProfile", 'String'>
    readonly bio: FieldRef<"BarberProfile", 'String'>
    readonly timeInterval: FieldRef<"BarberProfile", 'Int'>
    readonly createdAt: FieldRef<"BarberProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BarberProfile findUnique
   */
  export type BarberProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfile to fetch.
     */
    where: BarberProfileWhereUniqueInput
  }

  /**
   * BarberProfile findUniqueOrThrow
   */
  export type BarberProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfile to fetch.
     */
    where: BarberProfileWhereUniqueInput
  }

  /**
   * BarberProfile findFirst
   */
  export type BarberProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfile to fetch.
     */
    where?: BarberProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfiles to fetch.
     */
    orderBy?: BarberProfileOrderByWithRelationInput | BarberProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarberProfiles.
     */
    cursor?: BarberProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarberProfiles.
     */
    distinct?: BarberProfileScalarFieldEnum | BarberProfileScalarFieldEnum[]
  }

  /**
   * BarberProfile findFirstOrThrow
   */
  export type BarberProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfile to fetch.
     */
    where?: BarberProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfiles to fetch.
     */
    orderBy?: BarberProfileOrderByWithRelationInput | BarberProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarberProfiles.
     */
    cursor?: BarberProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarberProfiles.
     */
    distinct?: BarberProfileScalarFieldEnum | BarberProfileScalarFieldEnum[]
  }

  /**
   * BarberProfile findMany
   */
  export type BarberProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfiles to fetch.
     */
    where?: BarberProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfiles to fetch.
     */
    orderBy?: BarberProfileOrderByWithRelationInput | BarberProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarberProfiles.
     */
    cursor?: BarberProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfiles.
     */
    skip?: number
    distinct?: BarberProfileScalarFieldEnum | BarberProfileScalarFieldEnum[]
  }

  /**
   * BarberProfile create
   */
  export type BarberProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a BarberProfile.
     */
    data: XOR<BarberProfileCreateInput, BarberProfileUncheckedCreateInput>
  }

  /**
   * BarberProfile createMany
   */
  export type BarberProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarberProfiles.
     */
    data: BarberProfileCreateManyInput | BarberProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarberProfile createManyAndReturn
   */
  export type BarberProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * The data used to create many BarberProfiles.
     */
    data: BarberProfileCreateManyInput | BarberProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarberProfile update
   */
  export type BarberProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a BarberProfile.
     */
    data: XOR<BarberProfileUpdateInput, BarberProfileUncheckedUpdateInput>
    /**
     * Choose, which BarberProfile to update.
     */
    where: BarberProfileWhereUniqueInput
  }

  /**
   * BarberProfile updateMany
   */
  export type BarberProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarberProfiles.
     */
    data: XOR<BarberProfileUpdateManyMutationInput, BarberProfileUncheckedUpdateManyInput>
    /**
     * Filter which BarberProfiles to update
     */
    where?: BarberProfileWhereInput
    /**
     * Limit how many BarberProfiles to update.
     */
    limit?: number
  }

  /**
   * BarberProfile updateManyAndReturn
   */
  export type BarberProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * The data used to update BarberProfiles.
     */
    data: XOR<BarberProfileUpdateManyMutationInput, BarberProfileUncheckedUpdateManyInput>
    /**
     * Filter which BarberProfiles to update
     */
    where?: BarberProfileWhereInput
    /**
     * Limit how many BarberProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarberProfile upsert
   */
  export type BarberProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the BarberProfile to update in case it exists.
     */
    where: BarberProfileWhereUniqueInput
    /**
     * In case the BarberProfile found by the `where` argument doesn't exist, create a new BarberProfile with this data.
     */
    create: XOR<BarberProfileCreateInput, BarberProfileUncheckedCreateInput>
    /**
     * In case the BarberProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarberProfileUpdateInput, BarberProfileUncheckedUpdateInput>
  }

  /**
   * BarberProfile delete
   */
  export type BarberProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    /**
     * Filter which BarberProfile to delete.
     */
    where: BarberProfileWhereUniqueInput
  }

  /**
   * BarberProfile deleteMany
   */
  export type BarberProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarberProfiles to delete
     */
    where?: BarberProfileWhereInput
    /**
     * Limit how many BarberProfiles to delete.
     */
    limit?: number
  }

  /**
   * BarberProfile.bookings
   */
  export type BarberProfile$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * BarberProfile.services
   */
  export type BarberProfile$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    where?: BarberProfileToServiceWhereInput
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    cursor?: BarberProfileToServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarberProfileToServiceScalarFieldEnum | BarberProfileToServiceScalarFieldEnum[]
  }

  /**
   * BarberProfile.disabledDays
   */
  export type BarberProfile$disabledDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    where?: DisabledDayWhereInput
    orderBy?: DisabledDayOrderByWithRelationInput | DisabledDayOrderByWithRelationInput[]
    cursor?: DisabledDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisabledDayScalarFieldEnum | DisabledDayScalarFieldEnum[]
  }

  /**
   * BarberProfile.clientPlans
   */
  export type BarberProfile$clientPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    where?: ClientPlanWhereInput
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    cursor?: ClientPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPlanScalarFieldEnum | ClientPlanScalarFieldEnum[]
  }

  /**
   * BarberProfile.plans
   */
  export type BarberProfile$plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    cursor?: PlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * BarberProfile.extraTimeDays
   */
  export type BarberProfile$extraTimeDaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    where?: ExtraTimeDayWhereInput
    orderBy?: ExtraTimeDayOrderByWithRelationInput | ExtraTimeDayOrderByWithRelationInput[]
    cursor?: ExtraTimeDayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExtraTimeDayScalarFieldEnum | ExtraTimeDayScalarFieldEnum[]
  }

  /**
   * BarberProfile.disabledTimes
   */
  export type BarberProfile$disabledTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    where?: DisabledTimeWhereInput
    orderBy?: DisabledTimeOrderByWithRelationInput | DisabledTimeOrderByWithRelationInput[]
    cursor?: DisabledTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisabledTimeScalarFieldEnum | DisabledTimeScalarFieldEnum[]
  }

  /**
   * BarberProfile.notifications
   */
  export type BarberProfile$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * BarberProfile without action
   */
  export type BarberProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    keyword: string | null
    imagePath: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    keyword: string | null
    imagePath: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    keyword: number
    imagePath: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    keyword?: true
    imagePath?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    keyword?: true
    imagePath?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    keyword?: true
    imagePath?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    keyword?: boolean
    imagePath?: boolean
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    barbers?: boolean | Service$barbersArgs<ExtArgs>
    planToService?: boolean | Service$planToServiceArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    keyword?: boolean
    imagePath?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    keyword?: boolean
    imagePath?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    keyword?: boolean
    imagePath?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "duration" | "keyword" | "imagePath", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    barbers?: boolean | Service$barbersArgs<ExtArgs>
    planToService?: boolean | Service$planToServiceArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      bookings: Prisma.$BookingServicePayload<ExtArgs>[]
      barbers: Prisma.$BarberProfileToServicePayload<ExtArgs>[]
      planToService: Prisma.$PlanToServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      duration: number
      keyword: string
      imagePath: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barbers<T extends Service$barbersArgs<ExtArgs> = {}>(args?: Subset<T, Service$barbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    planToService<T extends Service$planToServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$planToServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Int'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly keyword: FieldRef<"Service", 'String'>
    readonly imagePath: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Service.barbers
   */
  export type Service$barbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    where?: BarberProfileToServiceWhereInput
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    cursor?: BarberProfileToServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BarberProfileToServiceScalarFieldEnum | BarberProfileToServiceScalarFieldEnum[]
  }

  /**
   * Service.planToService
   */
  export type Service$planToServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    where?: PlanToServiceWhereInput
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    cursor?: PlanToServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanToServiceScalarFieldEnum | PlanToServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model BarberProfileToService
   */

  export type AggregateBarberProfileToService = {
    _count: BarberProfileToServiceCountAggregateOutputType | null
    _min: BarberProfileToServiceMinAggregateOutputType | null
    _max: BarberProfileToServiceMaxAggregateOutputType | null
  }

  export type BarberProfileToServiceMinAggregateOutputType = {
    barberProfileId: string | null
    serviceId: string | null
  }

  export type BarberProfileToServiceMaxAggregateOutputType = {
    barberProfileId: string | null
    serviceId: string | null
  }

  export type BarberProfileToServiceCountAggregateOutputType = {
    barberProfileId: number
    serviceId: number
    _all: number
  }


  export type BarberProfileToServiceMinAggregateInputType = {
    barberProfileId?: true
    serviceId?: true
  }

  export type BarberProfileToServiceMaxAggregateInputType = {
    barberProfileId?: true
    serviceId?: true
  }

  export type BarberProfileToServiceCountAggregateInputType = {
    barberProfileId?: true
    serviceId?: true
    _all?: true
  }

  export type BarberProfileToServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarberProfileToService to aggregate.
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfileToServices to fetch.
     */
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BarberProfileToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfileToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfileToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BarberProfileToServices
    **/
    _count?: true | BarberProfileToServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BarberProfileToServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BarberProfileToServiceMaxAggregateInputType
  }

  export type GetBarberProfileToServiceAggregateType<T extends BarberProfileToServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBarberProfileToService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarberProfileToService[P]>
      : GetScalarType<T[P], AggregateBarberProfileToService[P]>
  }




  export type BarberProfileToServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BarberProfileToServiceWhereInput
    orderBy?: BarberProfileToServiceOrderByWithAggregationInput | BarberProfileToServiceOrderByWithAggregationInput[]
    by: BarberProfileToServiceScalarFieldEnum[] | BarberProfileToServiceScalarFieldEnum
    having?: BarberProfileToServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BarberProfileToServiceCountAggregateInputType | true
    _min?: BarberProfileToServiceMinAggregateInputType
    _max?: BarberProfileToServiceMaxAggregateInputType
  }

  export type BarberProfileToServiceGroupByOutputType = {
    barberProfileId: string
    serviceId: string
    _count: BarberProfileToServiceCountAggregateOutputType | null
    _min: BarberProfileToServiceMinAggregateOutputType | null
    _max: BarberProfileToServiceMaxAggregateOutputType | null
  }

  type GetBarberProfileToServiceGroupByPayload<T extends BarberProfileToServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarberProfileToServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BarberProfileToServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarberProfileToServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BarberProfileToServiceGroupByOutputType[P]>
        }
      >
    >


  export type BarberProfileToServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    barberProfileId?: boolean
    serviceId?: boolean
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfileToService"]>

  export type BarberProfileToServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    barberProfileId?: boolean
    serviceId?: boolean
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfileToService"]>

  export type BarberProfileToServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    barberProfileId?: boolean
    serviceId?: boolean
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["barberProfileToService"]>

  export type BarberProfileToServiceSelectScalar = {
    barberProfileId?: boolean
    serviceId?: boolean
  }

  export type BarberProfileToServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"barberProfileId" | "serviceId", ExtArgs["result"]["barberProfileToService"]>
  export type BarberProfileToServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BarberProfileToServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BarberProfileToServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barberProfile?: boolean | BarberProfileDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BarberProfileToServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BarberProfileToService"
    objects: {
      barberProfile: Prisma.$BarberProfilePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      barberProfileId: string
      serviceId: string
    }, ExtArgs["result"]["barberProfileToService"]>
    composites: {}
  }

  type BarberProfileToServiceGetPayload<S extends boolean | null | undefined | BarberProfileToServiceDefaultArgs> = $Result.GetResult<Prisma.$BarberProfileToServicePayload, S>

  type BarberProfileToServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BarberProfileToServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BarberProfileToServiceCountAggregateInputType | true
    }

  export interface BarberProfileToServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BarberProfileToService'], meta: { name: 'BarberProfileToService' } }
    /**
     * Find zero or one BarberProfileToService that matches the filter.
     * @param {BarberProfileToServiceFindUniqueArgs} args - Arguments to find a BarberProfileToService
     * @example
     * // Get one BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarberProfileToServiceFindUniqueArgs>(args: SelectSubset<T, BarberProfileToServiceFindUniqueArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BarberProfileToService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarberProfileToServiceFindUniqueOrThrowArgs} args - Arguments to find a BarberProfileToService
     * @example
     * // Get one BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarberProfileToServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BarberProfileToServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarberProfileToService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceFindFirstArgs} args - Arguments to find a BarberProfileToService
     * @example
     * // Get one BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarberProfileToServiceFindFirstArgs>(args?: SelectSubset<T, BarberProfileToServiceFindFirstArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BarberProfileToService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceFindFirstOrThrowArgs} args - Arguments to find a BarberProfileToService
     * @example
     * // Get one BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarberProfileToServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BarberProfileToServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BarberProfileToServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarberProfileToServices
     * const barberProfileToServices = await prisma.barberProfileToService.findMany()
     * 
     * // Get first 10 BarberProfileToServices
     * const barberProfileToServices = await prisma.barberProfileToService.findMany({ take: 10 })
     * 
     * // Only select the `barberProfileId`
     * const barberProfileToServiceWithBarberProfileIdOnly = await prisma.barberProfileToService.findMany({ select: { barberProfileId: true } })
     * 
     */
    findMany<T extends BarberProfileToServiceFindManyArgs>(args?: SelectSubset<T, BarberProfileToServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BarberProfileToService.
     * @param {BarberProfileToServiceCreateArgs} args - Arguments to create a BarberProfileToService.
     * @example
     * // Create one BarberProfileToService
     * const BarberProfileToService = await prisma.barberProfileToService.create({
     *   data: {
     *     // ... data to create a BarberProfileToService
     *   }
     * })
     * 
     */
    create<T extends BarberProfileToServiceCreateArgs>(args: SelectSubset<T, BarberProfileToServiceCreateArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BarberProfileToServices.
     * @param {BarberProfileToServiceCreateManyArgs} args - Arguments to create many BarberProfileToServices.
     * @example
     * // Create many BarberProfileToServices
     * const barberProfileToService = await prisma.barberProfileToService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BarberProfileToServiceCreateManyArgs>(args?: SelectSubset<T, BarberProfileToServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BarberProfileToServices and returns the data saved in the database.
     * @param {BarberProfileToServiceCreateManyAndReturnArgs} args - Arguments to create many BarberProfileToServices.
     * @example
     * // Create many BarberProfileToServices
     * const barberProfileToService = await prisma.barberProfileToService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BarberProfileToServices and only return the `barberProfileId`
     * const barberProfileToServiceWithBarberProfileIdOnly = await prisma.barberProfileToService.createManyAndReturn({
     *   select: { barberProfileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BarberProfileToServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BarberProfileToServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BarberProfileToService.
     * @param {BarberProfileToServiceDeleteArgs} args - Arguments to delete one BarberProfileToService.
     * @example
     * // Delete one BarberProfileToService
     * const BarberProfileToService = await prisma.barberProfileToService.delete({
     *   where: {
     *     // ... filter to delete one BarberProfileToService
     *   }
     * })
     * 
     */
    delete<T extends BarberProfileToServiceDeleteArgs>(args: SelectSubset<T, BarberProfileToServiceDeleteArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BarberProfileToService.
     * @param {BarberProfileToServiceUpdateArgs} args - Arguments to update one BarberProfileToService.
     * @example
     * // Update one BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BarberProfileToServiceUpdateArgs>(args: SelectSubset<T, BarberProfileToServiceUpdateArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BarberProfileToServices.
     * @param {BarberProfileToServiceDeleteManyArgs} args - Arguments to filter BarberProfileToServices to delete.
     * @example
     * // Delete a few BarberProfileToServices
     * const { count } = await prisma.barberProfileToService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BarberProfileToServiceDeleteManyArgs>(args?: SelectSubset<T, BarberProfileToServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarberProfileToServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarberProfileToServices
     * const barberProfileToService = await prisma.barberProfileToService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BarberProfileToServiceUpdateManyArgs>(args: SelectSubset<T, BarberProfileToServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BarberProfileToServices and returns the data updated in the database.
     * @param {BarberProfileToServiceUpdateManyAndReturnArgs} args - Arguments to update many BarberProfileToServices.
     * @example
     * // Update many BarberProfileToServices
     * const barberProfileToService = await prisma.barberProfileToService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BarberProfileToServices and only return the `barberProfileId`
     * const barberProfileToServiceWithBarberProfileIdOnly = await prisma.barberProfileToService.updateManyAndReturn({
     *   select: { barberProfileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BarberProfileToServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BarberProfileToServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BarberProfileToService.
     * @param {BarberProfileToServiceUpsertArgs} args - Arguments to update or create a BarberProfileToService.
     * @example
     * // Update or create a BarberProfileToService
     * const barberProfileToService = await prisma.barberProfileToService.upsert({
     *   create: {
     *     // ... data to create a BarberProfileToService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarberProfileToService we want to update
     *   }
     * })
     */
    upsert<T extends BarberProfileToServiceUpsertArgs>(args: SelectSubset<T, BarberProfileToServiceUpsertArgs<ExtArgs>>): Prisma__BarberProfileToServiceClient<$Result.GetResult<Prisma.$BarberProfileToServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BarberProfileToServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceCountArgs} args - Arguments to filter BarberProfileToServices to count.
     * @example
     * // Count the number of BarberProfileToServices
     * const count = await prisma.barberProfileToService.count({
     *   where: {
     *     // ... the filter for the BarberProfileToServices we want to count
     *   }
     * })
    **/
    count<T extends BarberProfileToServiceCountArgs>(
      args?: Subset<T, BarberProfileToServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarberProfileToServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BarberProfileToService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BarberProfileToServiceAggregateArgs>(args: Subset<T, BarberProfileToServiceAggregateArgs>): Prisma.PrismaPromise<GetBarberProfileToServiceAggregateType<T>>

    /**
     * Group by BarberProfileToService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberProfileToServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BarberProfileToServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarberProfileToServiceGroupByArgs['orderBy'] }
        : { orderBy?: BarberProfileToServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BarberProfileToServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBarberProfileToServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BarberProfileToService model
   */
  readonly fields: BarberProfileToServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarberProfileToService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarberProfileToServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barberProfile<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BarberProfileToService model
   */
  interface BarberProfileToServiceFieldRefs {
    readonly barberProfileId: FieldRef<"BarberProfileToService", 'String'>
    readonly serviceId: FieldRef<"BarberProfileToService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BarberProfileToService findUnique
   */
  export type BarberProfileToServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfileToService to fetch.
     */
    where: BarberProfileToServiceWhereUniqueInput
  }

  /**
   * BarberProfileToService findUniqueOrThrow
   */
  export type BarberProfileToServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfileToService to fetch.
     */
    where: BarberProfileToServiceWhereUniqueInput
  }

  /**
   * BarberProfileToService findFirst
   */
  export type BarberProfileToServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfileToService to fetch.
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfileToServices to fetch.
     */
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarberProfileToServices.
     */
    cursor?: BarberProfileToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfileToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfileToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarberProfileToServices.
     */
    distinct?: BarberProfileToServiceScalarFieldEnum | BarberProfileToServiceScalarFieldEnum[]
  }

  /**
   * BarberProfileToService findFirstOrThrow
   */
  export type BarberProfileToServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfileToService to fetch.
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfileToServices to fetch.
     */
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BarberProfileToServices.
     */
    cursor?: BarberProfileToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfileToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfileToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BarberProfileToServices.
     */
    distinct?: BarberProfileToServiceScalarFieldEnum | BarberProfileToServiceScalarFieldEnum[]
  }

  /**
   * BarberProfileToService findMany
   */
  export type BarberProfileToServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter, which BarberProfileToServices to fetch.
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BarberProfileToServices to fetch.
     */
    orderBy?: BarberProfileToServiceOrderByWithRelationInput | BarberProfileToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BarberProfileToServices.
     */
    cursor?: BarberProfileToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BarberProfileToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BarberProfileToServices.
     */
    skip?: number
    distinct?: BarberProfileToServiceScalarFieldEnum | BarberProfileToServiceScalarFieldEnum[]
  }

  /**
   * BarberProfileToService create
   */
  export type BarberProfileToServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BarberProfileToService.
     */
    data: XOR<BarberProfileToServiceCreateInput, BarberProfileToServiceUncheckedCreateInput>
  }

  /**
   * BarberProfileToService createMany
   */
  export type BarberProfileToServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BarberProfileToServices.
     */
    data: BarberProfileToServiceCreateManyInput | BarberProfileToServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BarberProfileToService createManyAndReturn
   */
  export type BarberProfileToServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * The data used to create many BarberProfileToServices.
     */
    data: BarberProfileToServiceCreateManyInput | BarberProfileToServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarberProfileToService update
   */
  export type BarberProfileToServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BarberProfileToService.
     */
    data: XOR<BarberProfileToServiceUpdateInput, BarberProfileToServiceUncheckedUpdateInput>
    /**
     * Choose, which BarberProfileToService to update.
     */
    where: BarberProfileToServiceWhereUniqueInput
  }

  /**
   * BarberProfileToService updateMany
   */
  export type BarberProfileToServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BarberProfileToServices.
     */
    data: XOR<BarberProfileToServiceUpdateManyMutationInput, BarberProfileToServiceUncheckedUpdateManyInput>
    /**
     * Filter which BarberProfileToServices to update
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * Limit how many BarberProfileToServices to update.
     */
    limit?: number
  }

  /**
   * BarberProfileToService updateManyAndReturn
   */
  export type BarberProfileToServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * The data used to update BarberProfileToServices.
     */
    data: XOR<BarberProfileToServiceUpdateManyMutationInput, BarberProfileToServiceUncheckedUpdateManyInput>
    /**
     * Filter which BarberProfileToServices to update
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * Limit how many BarberProfileToServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BarberProfileToService upsert
   */
  export type BarberProfileToServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BarberProfileToService to update in case it exists.
     */
    where: BarberProfileToServiceWhereUniqueInput
    /**
     * In case the BarberProfileToService found by the `where` argument doesn't exist, create a new BarberProfileToService with this data.
     */
    create: XOR<BarberProfileToServiceCreateInput, BarberProfileToServiceUncheckedCreateInput>
    /**
     * In case the BarberProfileToService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarberProfileToServiceUpdateInput, BarberProfileToServiceUncheckedUpdateInput>
  }

  /**
   * BarberProfileToService delete
   */
  export type BarberProfileToServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
    /**
     * Filter which BarberProfileToService to delete.
     */
    where: BarberProfileToServiceWhereUniqueInput
  }

  /**
   * BarberProfileToService deleteMany
   */
  export type BarberProfileToServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BarberProfileToServices to delete
     */
    where?: BarberProfileToServiceWhereInput
    /**
     * Limit how many BarberProfileToServices to delete.
     */
    limit?: number
  }

  /**
   * BarberProfileToService without action
   */
  export type BarberProfileToServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfileToService
     */
    select?: BarberProfileToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfileToService
     */
    omit?: BarberProfileToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileToServiceInclude<ExtArgs> | null
  }


  /**
   * Model BookingService
   */

  export type AggregateBookingService = {
    _count: BookingServiceCountAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  export type BookingServiceMinAggregateOutputType = {
    bookingId: string | null
    serviceId: string | null
  }

  export type BookingServiceMaxAggregateOutputType = {
    bookingId: string | null
    serviceId: string | null
  }

  export type BookingServiceCountAggregateOutputType = {
    bookingId: number
    serviceId: number
    _all: number
  }


  export type BookingServiceMinAggregateInputType = {
    bookingId?: true
    serviceId?: true
  }

  export type BookingServiceMaxAggregateInputType = {
    bookingId?: true
    serviceId?: true
  }

  export type BookingServiceCountAggregateInputType = {
    bookingId?: true
    serviceId?: true
    _all?: true
  }

  export type BookingServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingService to aggregate.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingServices
    **/
    _count?: true | BookingServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingServiceMaxAggregateInputType
  }

  export type GetBookingServiceAggregateType<T extends BookingServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingService[P]>
      : GetScalarType<T[P], AggregateBookingService[P]>
  }




  export type BookingServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithAggregationInput | BookingServiceOrderByWithAggregationInput[]
    by: BookingServiceScalarFieldEnum[] | BookingServiceScalarFieldEnum
    having?: BookingServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingServiceCountAggregateInputType | true
    _min?: BookingServiceMinAggregateInputType
    _max?: BookingServiceMaxAggregateInputType
  }

  export type BookingServiceGroupByOutputType = {
    bookingId: string
    serviceId: string
    _count: BookingServiceCountAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  type GetBookingServiceGroupByPayload<T extends BookingServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
        }
      >
    >


  export type BookingServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    serviceId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    serviceId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bookingId?: boolean
    serviceId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectScalar = {
    bookingId?: boolean
    serviceId?: boolean
  }

  export type BookingServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"bookingId" | "serviceId", ExtArgs["result"]["bookingService"]>
  export type BookingServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BookingServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingService"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bookingId: string
      serviceId: string
    }, ExtArgs["result"]["bookingService"]>
    composites: {}
  }

  type BookingServiceGetPayload<S extends boolean | null | undefined | BookingServiceDefaultArgs> = $Result.GetResult<Prisma.$BookingServicePayload, S>

  type BookingServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingServiceCountAggregateInputType | true
    }

  export interface BookingServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingService'], meta: { name: 'BookingService' } }
    /**
     * Find zero or one BookingService that matches the filter.
     * @param {BookingServiceFindUniqueArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingServiceFindUniqueArgs>(args: SelectSubset<T, BookingServiceFindUniqueArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingServiceFindUniqueOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingServiceFindFirstArgs>(args?: SelectSubset<T, BookingServiceFindFirstArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingServices
     * const bookingServices = await prisma.bookingService.findMany()
     * 
     * // Get first 10 BookingServices
     * const bookingServices = await prisma.bookingService.findMany({ take: 10 })
     * 
     * // Only select the `bookingId`
     * const bookingServiceWithBookingIdOnly = await prisma.bookingService.findMany({ select: { bookingId: true } })
     * 
     */
    findMany<T extends BookingServiceFindManyArgs>(args?: SelectSubset<T, BookingServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingService.
     * @param {BookingServiceCreateArgs} args - Arguments to create a BookingService.
     * @example
     * // Create one BookingService
     * const BookingService = await prisma.bookingService.create({
     *   data: {
     *     // ... data to create a BookingService
     *   }
     * })
     * 
     */
    create<T extends BookingServiceCreateArgs>(args: SelectSubset<T, BookingServiceCreateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingServices.
     * @param {BookingServiceCreateManyArgs} args - Arguments to create many BookingServices.
     * @example
     * // Create many BookingServices
     * const bookingService = await prisma.bookingService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingServiceCreateManyArgs>(args?: SelectSubset<T, BookingServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingServices and returns the data saved in the database.
     * @param {BookingServiceCreateManyAndReturnArgs} args - Arguments to create many BookingServices.
     * @example
     * // Create many BookingServices
     * const bookingService = await prisma.bookingService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingServices and only return the `bookingId`
     * const bookingServiceWithBookingIdOnly = await prisma.bookingService.createManyAndReturn({
     *   select: { bookingId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingService.
     * @param {BookingServiceDeleteArgs} args - Arguments to delete one BookingService.
     * @example
     * // Delete one BookingService
     * const BookingService = await prisma.bookingService.delete({
     *   where: {
     *     // ... filter to delete one BookingService
     *   }
     * })
     * 
     */
    delete<T extends BookingServiceDeleteArgs>(args: SelectSubset<T, BookingServiceDeleteArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingService.
     * @param {BookingServiceUpdateArgs} args - Arguments to update one BookingService.
     * @example
     * // Update one BookingService
     * const bookingService = await prisma.bookingService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingServiceUpdateArgs>(args: SelectSubset<T, BookingServiceUpdateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingServices.
     * @param {BookingServiceDeleteManyArgs} args - Arguments to filter BookingServices to delete.
     * @example
     * // Delete a few BookingServices
     * const { count } = await prisma.bookingService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingServiceDeleteManyArgs>(args?: SelectSubset<T, BookingServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingServices
     * const bookingService = await prisma.bookingService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingServiceUpdateManyArgs>(args: SelectSubset<T, BookingServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServices and returns the data updated in the database.
     * @param {BookingServiceUpdateManyAndReturnArgs} args - Arguments to update many BookingServices.
     * @example
     * // Update many BookingServices
     * const bookingService = await prisma.bookingService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingServices and only return the `bookingId`
     * const bookingServiceWithBookingIdOnly = await prisma.bookingService.updateManyAndReturn({
     *   select: { bookingId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingService.
     * @param {BookingServiceUpsertArgs} args - Arguments to update or create a BookingService.
     * @example
     * // Update or create a BookingService
     * const bookingService = await prisma.bookingService.upsert({
     *   create: {
     *     // ... data to create a BookingService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingService we want to update
     *   }
     * })
     */
    upsert<T extends BookingServiceUpsertArgs>(args: SelectSubset<T, BookingServiceUpsertArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceCountArgs} args - Arguments to filter BookingServices to count.
     * @example
     * // Count the number of BookingServices
     * const count = await prisma.bookingService.count({
     *   where: {
     *     // ... the filter for the BookingServices we want to count
     *   }
     * })
    **/
    count<T extends BookingServiceCountArgs>(
      args?: Subset<T, BookingServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingServiceAggregateArgs>(args: Subset<T, BookingServiceAggregateArgs>): Prisma.PrismaPromise<GetBookingServiceAggregateType<T>>

    /**
     * Group by BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingServiceGroupByArgs['orderBy'] }
        : { orderBy?: BookingServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingService model
   */
  readonly fields: BookingServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingService model
   */
  interface BookingServiceFieldRefs {
    readonly bookingId: FieldRef<"BookingService", 'String'>
    readonly serviceId: FieldRef<"BookingService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingService findUnique
   */
  export type BookingServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findUniqueOrThrow
   */
  export type BookingServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findFirst
   */
  export type BookingServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findFirstOrThrow
   */
  export type BookingServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findMany
   */
  export type BookingServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingServices to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService create
   */
  export type BookingServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingService.
     */
    data: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
  }

  /**
   * BookingService createMany
   */
  export type BookingServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingServices.
     */
    data: BookingServiceCreateManyInput | BookingServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingService createManyAndReturn
   */
  export type BookingServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * The data used to create many BookingServices.
     */
    data: BookingServiceCreateManyInput | BookingServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingService update
   */
  export type BookingServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingService.
     */
    data: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
    /**
     * Choose, which BookingService to update.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService updateMany
   */
  export type BookingServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingServices.
     */
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyInput>
    /**
     * Filter which BookingServices to update
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to update.
     */
    limit?: number
  }

  /**
   * BookingService updateManyAndReturn
   */
  export type BookingServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * The data used to update BookingServices.
     */
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyInput>
    /**
     * Filter which BookingServices to update
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingService upsert
   */
  export type BookingServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingService to update in case it exists.
     */
    where: BookingServiceWhereUniqueInput
    /**
     * In case the BookingService found by the `where` argument doesn't exist, create a new BookingService with this data.
     */
    create: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
    /**
     * In case the BookingService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
  }

  /**
   * BookingService delete
   */
  export type BookingServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter which BookingService to delete.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService deleteMany
   */
  export type BookingServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingServices to delete
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to delete.
     */
    limit?: number
  }

  /**
   * BookingService without action
   */
  export type BookingServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalPrice: number | null
    totalDuration: number | null
  }

  export type BookingSumAggregateOutputType = {
    totalPrice: number | null
    totalDuration: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.BookingStatus | null
    userId: string | null
    planId: string | null
    barberId: string | null
    totalPrice: number | null
    totalDuration: number | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    status: $Enums.BookingStatus | null
    userId: string | null
    planId: string | null
    barberId: string | null
    totalPrice: number | null
    totalDuration: number | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    date: number
    status: number
    userId: number
    planId: number
    barberId: number
    totalPrice: number
    totalDuration: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalPrice?: true
    totalDuration?: true
  }

  export type BookingSumAggregateInputType = {
    totalPrice?: true
    totalDuration?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    date?: true
    status?: true
    userId?: true
    planId?: true
    barberId?: true
    totalPrice?: true
    totalDuration?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    date?: true
    status?: true
    userId?: true
    planId?: true
    barberId?: true
    totalPrice?: true
    totalDuration?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    date?: true
    status?: true
    userId?: true
    planId?: true
    barberId?: true
    totalPrice?: true
    totalDuration?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    date: Date
    status: $Enums.BookingStatus
    userId: string
    planId: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    barberId?: boolean
    totalPrice?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    coupon?: boolean | Booking$couponArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    barberId?: boolean
    totalPrice?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    barberId?: boolean
    totalPrice?: boolean
    totalDuration?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    date?: boolean
    status?: boolean
    userId?: boolean
    planId?: boolean
    barberId?: boolean
    totalPrice?: boolean
    totalDuration?: boolean
    createdAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "status" | "userId" | "planId" | "barberId" | "totalPrice" | "totalDuration" | "createdAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    coupon?: boolean | Booking$couponArgs<ExtArgs>
    notifications?: boolean | Booking$notificationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | Booking$planArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      barber: Prisma.$BarberProfilePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$ClientPlanPayload<ExtArgs> | null
      services: Prisma.$BookingServicePayload<ExtArgs>[]
      coupon: Prisma.$CouponPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      status: $Enums.BookingStatus
      userId: string
      planId: string | null
      barberId: string
      totalPrice: number
      totalDuration: number
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends Booking$planArgs<ExtArgs> = {}>(args?: Subset<T, Booking$planArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    services<T extends Booking$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon<T extends Booking$couponArgs<ExtArgs> = {}>(args?: Subset<T, Booking$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Booking$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly date: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly planId: FieldRef<"Booking", 'String'>
    readonly barberId: FieldRef<"Booking", 'String'>
    readonly totalPrice: FieldRef<"Booking", 'Int'>
    readonly totalDuration: FieldRef<"Booking", 'Int'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.plan
   */
  export type Booking$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    where?: ClientPlanWhereInput
  }

  /**
   * Booking.services
   */
  export type Booking$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Booking.coupon
   */
  export type Booking$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * Booking.notifications
   */
  export type Booking$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model DisabledDay
   */

  export type AggregateDisabledDay = {
    _count: DisabledDayCountAggregateOutputType | null
    _min: DisabledDayMinAggregateOutputType | null
    _max: DisabledDayMaxAggregateOutputType | null
  }

  export type DisabledDayMinAggregateOutputType = {
    id: string | null
    barberId: string | null
    date: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type DisabledDayMaxAggregateOutputType = {
    id: string | null
    barberId: string | null
    date: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type DisabledDayCountAggregateOutputType = {
    id: number
    barberId: number
    date: number
    reason: number
    createdAt: number
    _all: number
  }


  export type DisabledDayMinAggregateInputType = {
    id?: true
    barberId?: true
    date?: true
    reason?: true
    createdAt?: true
  }

  export type DisabledDayMaxAggregateInputType = {
    id?: true
    barberId?: true
    date?: true
    reason?: true
    createdAt?: true
  }

  export type DisabledDayCountAggregateInputType = {
    id?: true
    barberId?: true
    date?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type DisabledDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisabledDay to aggregate.
     */
    where?: DisabledDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledDays to fetch.
     */
    orderBy?: DisabledDayOrderByWithRelationInput | DisabledDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisabledDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisabledDays
    **/
    _count?: true | DisabledDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisabledDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisabledDayMaxAggregateInputType
  }

  export type GetDisabledDayAggregateType<T extends DisabledDayAggregateArgs> = {
        [P in keyof T & keyof AggregateDisabledDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisabledDay[P]>
      : GetScalarType<T[P], AggregateDisabledDay[P]>
  }




  export type DisabledDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisabledDayWhereInput
    orderBy?: DisabledDayOrderByWithAggregationInput | DisabledDayOrderByWithAggregationInput[]
    by: DisabledDayScalarFieldEnum[] | DisabledDayScalarFieldEnum
    having?: DisabledDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisabledDayCountAggregateInputType | true
    _min?: DisabledDayMinAggregateInputType
    _max?: DisabledDayMaxAggregateInputType
  }

  export type DisabledDayGroupByOutputType = {
    id: string
    barberId: string
    date: Date
    reason: string | null
    createdAt: Date
    _count: DisabledDayCountAggregateOutputType | null
    _min: DisabledDayMinAggregateOutputType | null
    _max: DisabledDayMaxAggregateOutputType | null
  }

  type GetDisabledDayGroupByPayload<T extends DisabledDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisabledDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisabledDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisabledDayGroupByOutputType[P]>
            : GetScalarType<T[P], DisabledDayGroupByOutputType[P]>
        }
      >
    >


  export type DisabledDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledDay"]>

  export type DisabledDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledDay"]>

  export type DisabledDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledDay"]>

  export type DisabledDaySelectScalar = {
    id?: boolean
    barberId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type DisabledDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barberId" | "date" | "reason" | "createdAt", ExtArgs["result"]["disabledDay"]>
  export type DisabledDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type DisabledDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type DisabledDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }

  export type $DisabledDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisabledDay"
    objects: {
      barber: Prisma.$BarberProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barberId: string
      date: Date
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["disabledDay"]>
    composites: {}
  }

  type DisabledDayGetPayload<S extends boolean | null | undefined | DisabledDayDefaultArgs> = $Result.GetResult<Prisma.$DisabledDayPayload, S>

  type DisabledDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisabledDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisabledDayCountAggregateInputType | true
    }

  export interface DisabledDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisabledDay'], meta: { name: 'DisabledDay' } }
    /**
     * Find zero or one DisabledDay that matches the filter.
     * @param {DisabledDayFindUniqueArgs} args - Arguments to find a DisabledDay
     * @example
     * // Get one DisabledDay
     * const disabledDay = await prisma.disabledDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisabledDayFindUniqueArgs>(args: SelectSubset<T, DisabledDayFindUniqueArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisabledDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisabledDayFindUniqueOrThrowArgs} args - Arguments to find a DisabledDay
     * @example
     * // Get one DisabledDay
     * const disabledDay = await prisma.disabledDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisabledDayFindUniqueOrThrowArgs>(args: SelectSubset<T, DisabledDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisabledDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayFindFirstArgs} args - Arguments to find a DisabledDay
     * @example
     * // Get one DisabledDay
     * const disabledDay = await prisma.disabledDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisabledDayFindFirstArgs>(args?: SelectSubset<T, DisabledDayFindFirstArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisabledDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayFindFirstOrThrowArgs} args - Arguments to find a DisabledDay
     * @example
     * // Get one DisabledDay
     * const disabledDay = await prisma.disabledDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisabledDayFindFirstOrThrowArgs>(args?: SelectSubset<T, DisabledDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisabledDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisabledDays
     * const disabledDays = await prisma.disabledDay.findMany()
     * 
     * // Get first 10 DisabledDays
     * const disabledDays = await prisma.disabledDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disabledDayWithIdOnly = await prisma.disabledDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisabledDayFindManyArgs>(args?: SelectSubset<T, DisabledDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisabledDay.
     * @param {DisabledDayCreateArgs} args - Arguments to create a DisabledDay.
     * @example
     * // Create one DisabledDay
     * const DisabledDay = await prisma.disabledDay.create({
     *   data: {
     *     // ... data to create a DisabledDay
     *   }
     * })
     * 
     */
    create<T extends DisabledDayCreateArgs>(args: SelectSubset<T, DisabledDayCreateArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisabledDays.
     * @param {DisabledDayCreateManyArgs} args - Arguments to create many DisabledDays.
     * @example
     * // Create many DisabledDays
     * const disabledDay = await prisma.disabledDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisabledDayCreateManyArgs>(args?: SelectSubset<T, DisabledDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisabledDays and returns the data saved in the database.
     * @param {DisabledDayCreateManyAndReturnArgs} args - Arguments to create many DisabledDays.
     * @example
     * // Create many DisabledDays
     * const disabledDay = await prisma.disabledDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisabledDays and only return the `id`
     * const disabledDayWithIdOnly = await prisma.disabledDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisabledDayCreateManyAndReturnArgs>(args?: SelectSubset<T, DisabledDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisabledDay.
     * @param {DisabledDayDeleteArgs} args - Arguments to delete one DisabledDay.
     * @example
     * // Delete one DisabledDay
     * const DisabledDay = await prisma.disabledDay.delete({
     *   where: {
     *     // ... filter to delete one DisabledDay
     *   }
     * })
     * 
     */
    delete<T extends DisabledDayDeleteArgs>(args: SelectSubset<T, DisabledDayDeleteArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisabledDay.
     * @param {DisabledDayUpdateArgs} args - Arguments to update one DisabledDay.
     * @example
     * // Update one DisabledDay
     * const disabledDay = await prisma.disabledDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisabledDayUpdateArgs>(args: SelectSubset<T, DisabledDayUpdateArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisabledDays.
     * @param {DisabledDayDeleteManyArgs} args - Arguments to filter DisabledDays to delete.
     * @example
     * // Delete a few DisabledDays
     * const { count } = await prisma.disabledDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisabledDayDeleteManyArgs>(args?: SelectSubset<T, DisabledDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisabledDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisabledDays
     * const disabledDay = await prisma.disabledDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisabledDayUpdateManyArgs>(args: SelectSubset<T, DisabledDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisabledDays and returns the data updated in the database.
     * @param {DisabledDayUpdateManyAndReturnArgs} args - Arguments to update many DisabledDays.
     * @example
     * // Update many DisabledDays
     * const disabledDay = await prisma.disabledDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisabledDays and only return the `id`
     * const disabledDayWithIdOnly = await prisma.disabledDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisabledDayUpdateManyAndReturnArgs>(args: SelectSubset<T, DisabledDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisabledDay.
     * @param {DisabledDayUpsertArgs} args - Arguments to update or create a DisabledDay.
     * @example
     * // Update or create a DisabledDay
     * const disabledDay = await prisma.disabledDay.upsert({
     *   create: {
     *     // ... data to create a DisabledDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisabledDay we want to update
     *   }
     * })
     */
    upsert<T extends DisabledDayUpsertArgs>(args: SelectSubset<T, DisabledDayUpsertArgs<ExtArgs>>): Prisma__DisabledDayClient<$Result.GetResult<Prisma.$DisabledDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisabledDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayCountArgs} args - Arguments to filter DisabledDays to count.
     * @example
     * // Count the number of DisabledDays
     * const count = await prisma.disabledDay.count({
     *   where: {
     *     // ... the filter for the DisabledDays we want to count
     *   }
     * })
    **/
    count<T extends DisabledDayCountArgs>(
      args?: Subset<T, DisabledDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisabledDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisabledDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisabledDayAggregateArgs>(args: Subset<T, DisabledDayAggregateArgs>): Prisma.PrismaPromise<GetDisabledDayAggregateType<T>>

    /**
     * Group by DisabledDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisabledDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisabledDayGroupByArgs['orderBy'] }
        : { orderBy?: DisabledDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisabledDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisabledDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisabledDay model
   */
  readonly fields: DisabledDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisabledDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisabledDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisabledDay model
   */
  interface DisabledDayFieldRefs {
    readonly id: FieldRef<"DisabledDay", 'String'>
    readonly barberId: FieldRef<"DisabledDay", 'String'>
    readonly date: FieldRef<"DisabledDay", 'DateTime'>
    readonly reason: FieldRef<"DisabledDay", 'String'>
    readonly createdAt: FieldRef<"DisabledDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisabledDay findUnique
   */
  export type DisabledDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter, which DisabledDay to fetch.
     */
    where: DisabledDayWhereUniqueInput
  }

  /**
   * DisabledDay findUniqueOrThrow
   */
  export type DisabledDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter, which DisabledDay to fetch.
     */
    where: DisabledDayWhereUniqueInput
  }

  /**
   * DisabledDay findFirst
   */
  export type DisabledDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter, which DisabledDay to fetch.
     */
    where?: DisabledDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledDays to fetch.
     */
    orderBy?: DisabledDayOrderByWithRelationInput | DisabledDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisabledDays.
     */
    cursor?: DisabledDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisabledDays.
     */
    distinct?: DisabledDayScalarFieldEnum | DisabledDayScalarFieldEnum[]
  }

  /**
   * DisabledDay findFirstOrThrow
   */
  export type DisabledDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter, which DisabledDay to fetch.
     */
    where?: DisabledDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledDays to fetch.
     */
    orderBy?: DisabledDayOrderByWithRelationInput | DisabledDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisabledDays.
     */
    cursor?: DisabledDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisabledDays.
     */
    distinct?: DisabledDayScalarFieldEnum | DisabledDayScalarFieldEnum[]
  }

  /**
   * DisabledDay findMany
   */
  export type DisabledDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter, which DisabledDays to fetch.
     */
    where?: DisabledDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledDays to fetch.
     */
    orderBy?: DisabledDayOrderByWithRelationInput | DisabledDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisabledDays.
     */
    cursor?: DisabledDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledDays.
     */
    skip?: number
    distinct?: DisabledDayScalarFieldEnum | DisabledDayScalarFieldEnum[]
  }

  /**
   * DisabledDay create
   */
  export type DisabledDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * The data needed to create a DisabledDay.
     */
    data: XOR<DisabledDayCreateInput, DisabledDayUncheckedCreateInput>
  }

  /**
   * DisabledDay createMany
   */
  export type DisabledDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisabledDays.
     */
    data: DisabledDayCreateManyInput | DisabledDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisabledDay createManyAndReturn
   */
  export type DisabledDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * The data used to create many DisabledDays.
     */
    data: DisabledDayCreateManyInput | DisabledDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisabledDay update
   */
  export type DisabledDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * The data needed to update a DisabledDay.
     */
    data: XOR<DisabledDayUpdateInput, DisabledDayUncheckedUpdateInput>
    /**
     * Choose, which DisabledDay to update.
     */
    where: DisabledDayWhereUniqueInput
  }

  /**
   * DisabledDay updateMany
   */
  export type DisabledDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisabledDays.
     */
    data: XOR<DisabledDayUpdateManyMutationInput, DisabledDayUncheckedUpdateManyInput>
    /**
     * Filter which DisabledDays to update
     */
    where?: DisabledDayWhereInput
    /**
     * Limit how many DisabledDays to update.
     */
    limit?: number
  }

  /**
   * DisabledDay updateManyAndReturn
   */
  export type DisabledDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * The data used to update DisabledDays.
     */
    data: XOR<DisabledDayUpdateManyMutationInput, DisabledDayUncheckedUpdateManyInput>
    /**
     * Filter which DisabledDays to update
     */
    where?: DisabledDayWhereInput
    /**
     * Limit how many DisabledDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisabledDay upsert
   */
  export type DisabledDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * The filter to search for the DisabledDay to update in case it exists.
     */
    where: DisabledDayWhereUniqueInput
    /**
     * In case the DisabledDay found by the `where` argument doesn't exist, create a new DisabledDay with this data.
     */
    create: XOR<DisabledDayCreateInput, DisabledDayUncheckedCreateInput>
    /**
     * In case the DisabledDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisabledDayUpdateInput, DisabledDayUncheckedUpdateInput>
  }

  /**
   * DisabledDay delete
   */
  export type DisabledDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
    /**
     * Filter which DisabledDay to delete.
     */
    where: DisabledDayWhereUniqueInput
  }

  /**
   * DisabledDay deleteMany
   */
  export type DisabledDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisabledDays to delete
     */
    where?: DisabledDayWhereInput
    /**
     * Limit how many DisabledDays to delete.
     */
    limit?: number
  }

  /**
   * DisabledDay without action
   */
  export type DisabledDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledDay
     */
    select?: DisabledDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledDay
     */
    omit?: DisabledDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledDayInclude<ExtArgs> | null
  }


  /**
   * Model DisabledTime
   */

  export type AggregateDisabledTime = {
    _count: DisabledTimeCountAggregateOutputType | null
    _min: DisabledTimeMinAggregateOutputType | null
    _max: DisabledTimeMaxAggregateOutputType | null
  }

  export type DisabledTimeMinAggregateOutputType = {
    id: string | null
    date: Date | null
    barberId: string | null
    createdAt: Date | null
  }

  export type DisabledTimeMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    barberId: string | null
    createdAt: Date | null
  }

  export type DisabledTimeCountAggregateOutputType = {
    id: number
    date: number
    barberId: number
    createdAt: number
    _all: number
  }


  export type DisabledTimeMinAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    createdAt?: true
  }

  export type DisabledTimeMaxAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    createdAt?: true
  }

  export type DisabledTimeCountAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    createdAt?: true
    _all?: true
  }

  export type DisabledTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisabledTime to aggregate.
     */
    where?: DisabledTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledTimes to fetch.
     */
    orderBy?: DisabledTimeOrderByWithRelationInput | DisabledTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisabledTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisabledTimes
    **/
    _count?: true | DisabledTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisabledTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisabledTimeMaxAggregateInputType
  }

  export type GetDisabledTimeAggregateType<T extends DisabledTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateDisabledTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisabledTime[P]>
      : GetScalarType<T[P], AggregateDisabledTime[P]>
  }




  export type DisabledTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisabledTimeWhereInput
    orderBy?: DisabledTimeOrderByWithAggregationInput | DisabledTimeOrderByWithAggregationInput[]
    by: DisabledTimeScalarFieldEnum[] | DisabledTimeScalarFieldEnum
    having?: DisabledTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisabledTimeCountAggregateInputType | true
    _min?: DisabledTimeMinAggregateInputType
    _max?: DisabledTimeMaxAggregateInputType
  }

  export type DisabledTimeGroupByOutputType = {
    id: string
    date: Date
    barberId: string
    createdAt: Date
    _count: DisabledTimeCountAggregateOutputType | null
    _min: DisabledTimeMinAggregateOutputType | null
    _max: DisabledTimeMaxAggregateOutputType | null
  }

  type GetDisabledTimeGroupByPayload<T extends DisabledTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisabledTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisabledTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisabledTimeGroupByOutputType[P]>
            : GetScalarType<T[P], DisabledTimeGroupByOutputType[P]>
        }
      >
    >


  export type DisabledTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledTime"]>

  export type DisabledTimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledTime"]>

  export type DisabledTimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    createdAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disabledTime"]>

  export type DisabledTimeSelectScalar = {
    id?: boolean
    date?: boolean
    barberId?: boolean
    createdAt?: boolean
  }

  export type DisabledTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "barberId" | "createdAt", ExtArgs["result"]["disabledTime"]>
  export type DisabledTimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type DisabledTimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type DisabledTimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }

  export type $DisabledTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisabledTime"
    objects: {
      barber: Prisma.$BarberProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      barberId: string
      createdAt: Date
    }, ExtArgs["result"]["disabledTime"]>
    composites: {}
  }

  type DisabledTimeGetPayload<S extends boolean | null | undefined | DisabledTimeDefaultArgs> = $Result.GetResult<Prisma.$DisabledTimePayload, S>

  type DisabledTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisabledTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisabledTimeCountAggregateInputType | true
    }

  export interface DisabledTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisabledTime'], meta: { name: 'DisabledTime' } }
    /**
     * Find zero or one DisabledTime that matches the filter.
     * @param {DisabledTimeFindUniqueArgs} args - Arguments to find a DisabledTime
     * @example
     * // Get one DisabledTime
     * const disabledTime = await prisma.disabledTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisabledTimeFindUniqueArgs>(args: SelectSubset<T, DisabledTimeFindUniqueArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisabledTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisabledTimeFindUniqueOrThrowArgs} args - Arguments to find a DisabledTime
     * @example
     * // Get one DisabledTime
     * const disabledTime = await prisma.disabledTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisabledTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisabledTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisabledTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeFindFirstArgs} args - Arguments to find a DisabledTime
     * @example
     * // Get one DisabledTime
     * const disabledTime = await prisma.disabledTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisabledTimeFindFirstArgs>(args?: SelectSubset<T, DisabledTimeFindFirstArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisabledTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeFindFirstOrThrowArgs} args - Arguments to find a DisabledTime
     * @example
     * // Get one DisabledTime
     * const disabledTime = await prisma.disabledTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisabledTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisabledTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisabledTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisabledTimes
     * const disabledTimes = await prisma.disabledTime.findMany()
     * 
     * // Get first 10 DisabledTimes
     * const disabledTimes = await prisma.disabledTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disabledTimeWithIdOnly = await prisma.disabledTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisabledTimeFindManyArgs>(args?: SelectSubset<T, DisabledTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisabledTime.
     * @param {DisabledTimeCreateArgs} args - Arguments to create a DisabledTime.
     * @example
     * // Create one DisabledTime
     * const DisabledTime = await prisma.disabledTime.create({
     *   data: {
     *     // ... data to create a DisabledTime
     *   }
     * })
     * 
     */
    create<T extends DisabledTimeCreateArgs>(args: SelectSubset<T, DisabledTimeCreateArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisabledTimes.
     * @param {DisabledTimeCreateManyArgs} args - Arguments to create many DisabledTimes.
     * @example
     * // Create many DisabledTimes
     * const disabledTime = await prisma.disabledTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisabledTimeCreateManyArgs>(args?: SelectSubset<T, DisabledTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisabledTimes and returns the data saved in the database.
     * @param {DisabledTimeCreateManyAndReturnArgs} args - Arguments to create many DisabledTimes.
     * @example
     * // Create many DisabledTimes
     * const disabledTime = await prisma.disabledTime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisabledTimes and only return the `id`
     * const disabledTimeWithIdOnly = await prisma.disabledTime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisabledTimeCreateManyAndReturnArgs>(args?: SelectSubset<T, DisabledTimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisabledTime.
     * @param {DisabledTimeDeleteArgs} args - Arguments to delete one DisabledTime.
     * @example
     * // Delete one DisabledTime
     * const DisabledTime = await prisma.disabledTime.delete({
     *   where: {
     *     // ... filter to delete one DisabledTime
     *   }
     * })
     * 
     */
    delete<T extends DisabledTimeDeleteArgs>(args: SelectSubset<T, DisabledTimeDeleteArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisabledTime.
     * @param {DisabledTimeUpdateArgs} args - Arguments to update one DisabledTime.
     * @example
     * // Update one DisabledTime
     * const disabledTime = await prisma.disabledTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisabledTimeUpdateArgs>(args: SelectSubset<T, DisabledTimeUpdateArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisabledTimes.
     * @param {DisabledTimeDeleteManyArgs} args - Arguments to filter DisabledTimes to delete.
     * @example
     * // Delete a few DisabledTimes
     * const { count } = await prisma.disabledTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisabledTimeDeleteManyArgs>(args?: SelectSubset<T, DisabledTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisabledTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisabledTimes
     * const disabledTime = await prisma.disabledTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisabledTimeUpdateManyArgs>(args: SelectSubset<T, DisabledTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisabledTimes and returns the data updated in the database.
     * @param {DisabledTimeUpdateManyAndReturnArgs} args - Arguments to update many DisabledTimes.
     * @example
     * // Update many DisabledTimes
     * const disabledTime = await prisma.disabledTime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisabledTimes and only return the `id`
     * const disabledTimeWithIdOnly = await prisma.disabledTime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisabledTimeUpdateManyAndReturnArgs>(args: SelectSubset<T, DisabledTimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisabledTime.
     * @param {DisabledTimeUpsertArgs} args - Arguments to update or create a DisabledTime.
     * @example
     * // Update or create a DisabledTime
     * const disabledTime = await prisma.disabledTime.upsert({
     *   create: {
     *     // ... data to create a DisabledTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisabledTime we want to update
     *   }
     * })
     */
    upsert<T extends DisabledTimeUpsertArgs>(args: SelectSubset<T, DisabledTimeUpsertArgs<ExtArgs>>): Prisma__DisabledTimeClient<$Result.GetResult<Prisma.$DisabledTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisabledTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeCountArgs} args - Arguments to filter DisabledTimes to count.
     * @example
     * // Count the number of DisabledTimes
     * const count = await prisma.disabledTime.count({
     *   where: {
     *     // ... the filter for the DisabledTimes we want to count
     *   }
     * })
    **/
    count<T extends DisabledTimeCountArgs>(
      args?: Subset<T, DisabledTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisabledTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisabledTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisabledTimeAggregateArgs>(args: Subset<T, DisabledTimeAggregateArgs>): Prisma.PrismaPromise<GetDisabledTimeAggregateType<T>>

    /**
     * Group by DisabledTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisabledTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisabledTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisabledTimeGroupByArgs['orderBy'] }
        : { orderBy?: DisabledTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisabledTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisabledTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisabledTime model
   */
  readonly fields: DisabledTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisabledTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisabledTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisabledTime model
   */
  interface DisabledTimeFieldRefs {
    readonly id: FieldRef<"DisabledTime", 'String'>
    readonly date: FieldRef<"DisabledTime", 'DateTime'>
    readonly barberId: FieldRef<"DisabledTime", 'String'>
    readonly createdAt: FieldRef<"DisabledTime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisabledTime findUnique
   */
  export type DisabledTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter, which DisabledTime to fetch.
     */
    where: DisabledTimeWhereUniqueInput
  }

  /**
   * DisabledTime findUniqueOrThrow
   */
  export type DisabledTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter, which DisabledTime to fetch.
     */
    where: DisabledTimeWhereUniqueInput
  }

  /**
   * DisabledTime findFirst
   */
  export type DisabledTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter, which DisabledTime to fetch.
     */
    where?: DisabledTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledTimes to fetch.
     */
    orderBy?: DisabledTimeOrderByWithRelationInput | DisabledTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisabledTimes.
     */
    cursor?: DisabledTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisabledTimes.
     */
    distinct?: DisabledTimeScalarFieldEnum | DisabledTimeScalarFieldEnum[]
  }

  /**
   * DisabledTime findFirstOrThrow
   */
  export type DisabledTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter, which DisabledTime to fetch.
     */
    where?: DisabledTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledTimes to fetch.
     */
    orderBy?: DisabledTimeOrderByWithRelationInput | DisabledTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisabledTimes.
     */
    cursor?: DisabledTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisabledTimes.
     */
    distinct?: DisabledTimeScalarFieldEnum | DisabledTimeScalarFieldEnum[]
  }

  /**
   * DisabledTime findMany
   */
  export type DisabledTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter, which DisabledTimes to fetch.
     */
    where?: DisabledTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisabledTimes to fetch.
     */
    orderBy?: DisabledTimeOrderByWithRelationInput | DisabledTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisabledTimes.
     */
    cursor?: DisabledTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisabledTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisabledTimes.
     */
    skip?: number
    distinct?: DisabledTimeScalarFieldEnum | DisabledTimeScalarFieldEnum[]
  }

  /**
   * DisabledTime create
   */
  export type DisabledTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * The data needed to create a DisabledTime.
     */
    data: XOR<DisabledTimeCreateInput, DisabledTimeUncheckedCreateInput>
  }

  /**
   * DisabledTime createMany
   */
  export type DisabledTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisabledTimes.
     */
    data: DisabledTimeCreateManyInput | DisabledTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisabledTime createManyAndReturn
   */
  export type DisabledTimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * The data used to create many DisabledTimes.
     */
    data: DisabledTimeCreateManyInput | DisabledTimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisabledTime update
   */
  export type DisabledTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * The data needed to update a DisabledTime.
     */
    data: XOR<DisabledTimeUpdateInput, DisabledTimeUncheckedUpdateInput>
    /**
     * Choose, which DisabledTime to update.
     */
    where: DisabledTimeWhereUniqueInput
  }

  /**
   * DisabledTime updateMany
   */
  export type DisabledTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisabledTimes.
     */
    data: XOR<DisabledTimeUpdateManyMutationInput, DisabledTimeUncheckedUpdateManyInput>
    /**
     * Filter which DisabledTimes to update
     */
    where?: DisabledTimeWhereInput
    /**
     * Limit how many DisabledTimes to update.
     */
    limit?: number
  }

  /**
   * DisabledTime updateManyAndReturn
   */
  export type DisabledTimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * The data used to update DisabledTimes.
     */
    data: XOR<DisabledTimeUpdateManyMutationInput, DisabledTimeUncheckedUpdateManyInput>
    /**
     * Filter which DisabledTimes to update
     */
    where?: DisabledTimeWhereInput
    /**
     * Limit how many DisabledTimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisabledTime upsert
   */
  export type DisabledTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * The filter to search for the DisabledTime to update in case it exists.
     */
    where: DisabledTimeWhereUniqueInput
    /**
     * In case the DisabledTime found by the `where` argument doesn't exist, create a new DisabledTime with this data.
     */
    create: XOR<DisabledTimeCreateInput, DisabledTimeUncheckedCreateInput>
    /**
     * In case the DisabledTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisabledTimeUpdateInput, DisabledTimeUncheckedUpdateInput>
  }

  /**
   * DisabledTime delete
   */
  export type DisabledTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
    /**
     * Filter which DisabledTime to delete.
     */
    where: DisabledTimeWhereUniqueInput
  }

  /**
   * DisabledTime deleteMany
   */
  export type DisabledTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisabledTimes to delete
     */
    where?: DisabledTimeWhereInput
    /**
     * Limit how many DisabledTimes to delete.
     */
    limit?: number
  }

  /**
   * DisabledTime without action
   */
  export type DisabledTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisabledTime
     */
    select?: DisabledTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisabledTime
     */
    omit?: DisabledTimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisabledTimeInclude<ExtArgs> | null
  }


  /**
   * Model ExtraTimeDay
   */

  export type AggregateExtraTimeDay = {
    _count: ExtraTimeDayCountAggregateOutputType | null
    _avg: ExtraTimeDayAvgAggregateOutputType | null
    _sum: ExtraTimeDaySumAggregateOutputType | null
    _min: ExtraTimeDayMinAggregateOutputType | null
    _max: ExtraTimeDayMaxAggregateOutputType | null
  }

  export type ExtraTimeDayAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExtraTimeDaySumAggregateOutputType = {
    amount: number | null
  }

  export type ExtraTimeDayMinAggregateOutputType = {
    id: string | null
    date: Date | null
    barberId: string | null
    amount: number | null
    createdAT: Date | null
  }

  export type ExtraTimeDayMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    barberId: string | null
    amount: number | null
    createdAT: Date | null
  }

  export type ExtraTimeDayCountAggregateOutputType = {
    id: number
    date: number
    barberId: number
    amount: number
    createdAT: number
    _all: number
  }


  export type ExtraTimeDayAvgAggregateInputType = {
    amount?: true
  }

  export type ExtraTimeDaySumAggregateInputType = {
    amount?: true
  }

  export type ExtraTimeDayMinAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    amount?: true
    createdAT?: true
  }

  export type ExtraTimeDayMaxAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    amount?: true
    createdAT?: true
  }

  export type ExtraTimeDayCountAggregateInputType = {
    id?: true
    date?: true
    barberId?: true
    amount?: true
    createdAT?: true
    _all?: true
  }

  export type ExtraTimeDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraTimeDay to aggregate.
     */
    where?: ExtraTimeDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraTimeDays to fetch.
     */
    orderBy?: ExtraTimeDayOrderByWithRelationInput | ExtraTimeDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtraTimeDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraTimeDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraTimeDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtraTimeDays
    **/
    _count?: true | ExtraTimeDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtraTimeDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtraTimeDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtraTimeDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtraTimeDayMaxAggregateInputType
  }

  export type GetExtraTimeDayAggregateType<T extends ExtraTimeDayAggregateArgs> = {
        [P in keyof T & keyof AggregateExtraTimeDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtraTimeDay[P]>
      : GetScalarType<T[P], AggregateExtraTimeDay[P]>
  }




  export type ExtraTimeDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtraTimeDayWhereInput
    orderBy?: ExtraTimeDayOrderByWithAggregationInput | ExtraTimeDayOrderByWithAggregationInput[]
    by: ExtraTimeDayScalarFieldEnum[] | ExtraTimeDayScalarFieldEnum
    having?: ExtraTimeDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtraTimeDayCountAggregateInputType | true
    _avg?: ExtraTimeDayAvgAggregateInputType
    _sum?: ExtraTimeDaySumAggregateInputType
    _min?: ExtraTimeDayMinAggregateInputType
    _max?: ExtraTimeDayMaxAggregateInputType
  }

  export type ExtraTimeDayGroupByOutputType = {
    id: string
    date: Date
    barberId: string
    amount: number
    createdAT: Date
    _count: ExtraTimeDayCountAggregateOutputType | null
    _avg: ExtraTimeDayAvgAggregateOutputType | null
    _sum: ExtraTimeDaySumAggregateOutputType | null
    _min: ExtraTimeDayMinAggregateOutputType | null
    _max: ExtraTimeDayMaxAggregateOutputType | null
  }

  type GetExtraTimeDayGroupByPayload<T extends ExtraTimeDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtraTimeDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtraTimeDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtraTimeDayGroupByOutputType[P]>
            : GetScalarType<T[P], ExtraTimeDayGroupByOutputType[P]>
        }
      >
    >


  export type ExtraTimeDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    amount?: boolean
    createdAT?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraTimeDay"]>

  export type ExtraTimeDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    amount?: boolean
    createdAT?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraTimeDay"]>

  export type ExtraTimeDaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    barberId?: boolean
    amount?: boolean
    createdAT?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extraTimeDay"]>

  export type ExtraTimeDaySelectScalar = {
    id?: boolean
    date?: boolean
    barberId?: boolean
    amount?: boolean
    createdAT?: boolean
  }

  export type ExtraTimeDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "barberId" | "amount" | "createdAT", ExtArgs["result"]["extraTimeDay"]>
  export type ExtraTimeDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type ExtraTimeDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type ExtraTimeDayIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }

  export type $ExtraTimeDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtraTimeDay"
    objects: {
      barber: Prisma.$BarberProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      barberId: string
      amount: number
      createdAT: Date
    }, ExtArgs["result"]["extraTimeDay"]>
    composites: {}
  }

  type ExtraTimeDayGetPayload<S extends boolean | null | undefined | ExtraTimeDayDefaultArgs> = $Result.GetResult<Prisma.$ExtraTimeDayPayload, S>

  type ExtraTimeDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExtraTimeDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtraTimeDayCountAggregateInputType | true
    }

  export interface ExtraTimeDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtraTimeDay'], meta: { name: 'ExtraTimeDay' } }
    /**
     * Find zero or one ExtraTimeDay that matches the filter.
     * @param {ExtraTimeDayFindUniqueArgs} args - Arguments to find a ExtraTimeDay
     * @example
     * // Get one ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtraTimeDayFindUniqueArgs>(args: SelectSubset<T, ExtraTimeDayFindUniqueArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExtraTimeDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtraTimeDayFindUniqueOrThrowArgs} args - Arguments to find a ExtraTimeDay
     * @example
     * // Get one ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtraTimeDayFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtraTimeDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtraTimeDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayFindFirstArgs} args - Arguments to find a ExtraTimeDay
     * @example
     * // Get one ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtraTimeDayFindFirstArgs>(args?: SelectSubset<T, ExtraTimeDayFindFirstArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtraTimeDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayFindFirstOrThrowArgs} args - Arguments to find a ExtraTimeDay
     * @example
     * // Get one ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtraTimeDayFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtraTimeDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExtraTimeDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtraTimeDays
     * const extraTimeDays = await prisma.extraTimeDay.findMany()
     * 
     * // Get first 10 ExtraTimeDays
     * const extraTimeDays = await prisma.extraTimeDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extraTimeDayWithIdOnly = await prisma.extraTimeDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtraTimeDayFindManyArgs>(args?: SelectSubset<T, ExtraTimeDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExtraTimeDay.
     * @param {ExtraTimeDayCreateArgs} args - Arguments to create a ExtraTimeDay.
     * @example
     * // Create one ExtraTimeDay
     * const ExtraTimeDay = await prisma.extraTimeDay.create({
     *   data: {
     *     // ... data to create a ExtraTimeDay
     *   }
     * })
     * 
     */
    create<T extends ExtraTimeDayCreateArgs>(args: SelectSubset<T, ExtraTimeDayCreateArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExtraTimeDays.
     * @param {ExtraTimeDayCreateManyArgs} args - Arguments to create many ExtraTimeDays.
     * @example
     * // Create many ExtraTimeDays
     * const extraTimeDay = await prisma.extraTimeDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtraTimeDayCreateManyArgs>(args?: SelectSubset<T, ExtraTimeDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtraTimeDays and returns the data saved in the database.
     * @param {ExtraTimeDayCreateManyAndReturnArgs} args - Arguments to create many ExtraTimeDays.
     * @example
     * // Create many ExtraTimeDays
     * const extraTimeDay = await prisma.extraTimeDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtraTimeDays and only return the `id`
     * const extraTimeDayWithIdOnly = await prisma.extraTimeDay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtraTimeDayCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtraTimeDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExtraTimeDay.
     * @param {ExtraTimeDayDeleteArgs} args - Arguments to delete one ExtraTimeDay.
     * @example
     * // Delete one ExtraTimeDay
     * const ExtraTimeDay = await prisma.extraTimeDay.delete({
     *   where: {
     *     // ... filter to delete one ExtraTimeDay
     *   }
     * })
     * 
     */
    delete<T extends ExtraTimeDayDeleteArgs>(args: SelectSubset<T, ExtraTimeDayDeleteArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExtraTimeDay.
     * @param {ExtraTimeDayUpdateArgs} args - Arguments to update one ExtraTimeDay.
     * @example
     * // Update one ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtraTimeDayUpdateArgs>(args: SelectSubset<T, ExtraTimeDayUpdateArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExtraTimeDays.
     * @param {ExtraTimeDayDeleteManyArgs} args - Arguments to filter ExtraTimeDays to delete.
     * @example
     * // Delete a few ExtraTimeDays
     * const { count } = await prisma.extraTimeDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtraTimeDayDeleteManyArgs>(args?: SelectSubset<T, ExtraTimeDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtraTimeDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtraTimeDays
     * const extraTimeDay = await prisma.extraTimeDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtraTimeDayUpdateManyArgs>(args: SelectSubset<T, ExtraTimeDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtraTimeDays and returns the data updated in the database.
     * @param {ExtraTimeDayUpdateManyAndReturnArgs} args - Arguments to update many ExtraTimeDays.
     * @example
     * // Update many ExtraTimeDays
     * const extraTimeDay = await prisma.extraTimeDay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExtraTimeDays and only return the `id`
     * const extraTimeDayWithIdOnly = await prisma.extraTimeDay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExtraTimeDayUpdateManyAndReturnArgs>(args: SelectSubset<T, ExtraTimeDayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExtraTimeDay.
     * @param {ExtraTimeDayUpsertArgs} args - Arguments to update or create a ExtraTimeDay.
     * @example
     * // Update or create a ExtraTimeDay
     * const extraTimeDay = await prisma.extraTimeDay.upsert({
     *   create: {
     *     // ... data to create a ExtraTimeDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtraTimeDay we want to update
     *   }
     * })
     */
    upsert<T extends ExtraTimeDayUpsertArgs>(args: SelectSubset<T, ExtraTimeDayUpsertArgs<ExtArgs>>): Prisma__ExtraTimeDayClient<$Result.GetResult<Prisma.$ExtraTimeDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExtraTimeDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayCountArgs} args - Arguments to filter ExtraTimeDays to count.
     * @example
     * // Count the number of ExtraTimeDays
     * const count = await prisma.extraTimeDay.count({
     *   where: {
     *     // ... the filter for the ExtraTimeDays we want to count
     *   }
     * })
    **/
    count<T extends ExtraTimeDayCountArgs>(
      args?: Subset<T, ExtraTimeDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtraTimeDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtraTimeDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtraTimeDayAggregateArgs>(args: Subset<T, ExtraTimeDayAggregateArgs>): Prisma.PrismaPromise<GetExtraTimeDayAggregateType<T>>

    /**
     * Group by ExtraTimeDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtraTimeDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtraTimeDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtraTimeDayGroupByArgs['orderBy'] }
        : { orderBy?: ExtraTimeDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtraTimeDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtraTimeDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtraTimeDay model
   */
  readonly fields: ExtraTimeDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtraTimeDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtraTimeDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExtraTimeDay model
   */
  interface ExtraTimeDayFieldRefs {
    readonly id: FieldRef<"ExtraTimeDay", 'String'>
    readonly date: FieldRef<"ExtraTimeDay", 'DateTime'>
    readonly barberId: FieldRef<"ExtraTimeDay", 'String'>
    readonly amount: FieldRef<"ExtraTimeDay", 'Int'>
    readonly createdAT: FieldRef<"ExtraTimeDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExtraTimeDay findUnique
   */
  export type ExtraTimeDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter, which ExtraTimeDay to fetch.
     */
    where: ExtraTimeDayWhereUniqueInput
  }

  /**
   * ExtraTimeDay findUniqueOrThrow
   */
  export type ExtraTimeDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter, which ExtraTimeDay to fetch.
     */
    where: ExtraTimeDayWhereUniqueInput
  }

  /**
   * ExtraTimeDay findFirst
   */
  export type ExtraTimeDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter, which ExtraTimeDay to fetch.
     */
    where?: ExtraTimeDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraTimeDays to fetch.
     */
    orderBy?: ExtraTimeDayOrderByWithRelationInput | ExtraTimeDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraTimeDays.
     */
    cursor?: ExtraTimeDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraTimeDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraTimeDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraTimeDays.
     */
    distinct?: ExtraTimeDayScalarFieldEnum | ExtraTimeDayScalarFieldEnum[]
  }

  /**
   * ExtraTimeDay findFirstOrThrow
   */
  export type ExtraTimeDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter, which ExtraTimeDay to fetch.
     */
    where?: ExtraTimeDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraTimeDays to fetch.
     */
    orderBy?: ExtraTimeDayOrderByWithRelationInput | ExtraTimeDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtraTimeDays.
     */
    cursor?: ExtraTimeDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraTimeDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraTimeDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtraTimeDays.
     */
    distinct?: ExtraTimeDayScalarFieldEnum | ExtraTimeDayScalarFieldEnum[]
  }

  /**
   * ExtraTimeDay findMany
   */
  export type ExtraTimeDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter, which ExtraTimeDays to fetch.
     */
    where?: ExtraTimeDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtraTimeDays to fetch.
     */
    orderBy?: ExtraTimeDayOrderByWithRelationInput | ExtraTimeDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtraTimeDays.
     */
    cursor?: ExtraTimeDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtraTimeDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtraTimeDays.
     */
    skip?: number
    distinct?: ExtraTimeDayScalarFieldEnum | ExtraTimeDayScalarFieldEnum[]
  }

  /**
   * ExtraTimeDay create
   */
  export type ExtraTimeDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtraTimeDay.
     */
    data: XOR<ExtraTimeDayCreateInput, ExtraTimeDayUncheckedCreateInput>
  }

  /**
   * ExtraTimeDay createMany
   */
  export type ExtraTimeDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtraTimeDays.
     */
    data: ExtraTimeDayCreateManyInput | ExtraTimeDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtraTimeDay createManyAndReturn
   */
  export type ExtraTimeDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * The data used to create many ExtraTimeDays.
     */
    data: ExtraTimeDayCreateManyInput | ExtraTimeDayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtraTimeDay update
   */
  export type ExtraTimeDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtraTimeDay.
     */
    data: XOR<ExtraTimeDayUpdateInput, ExtraTimeDayUncheckedUpdateInput>
    /**
     * Choose, which ExtraTimeDay to update.
     */
    where: ExtraTimeDayWhereUniqueInput
  }

  /**
   * ExtraTimeDay updateMany
   */
  export type ExtraTimeDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtraTimeDays.
     */
    data: XOR<ExtraTimeDayUpdateManyMutationInput, ExtraTimeDayUncheckedUpdateManyInput>
    /**
     * Filter which ExtraTimeDays to update
     */
    where?: ExtraTimeDayWhereInput
    /**
     * Limit how many ExtraTimeDays to update.
     */
    limit?: number
  }

  /**
   * ExtraTimeDay updateManyAndReturn
   */
  export type ExtraTimeDayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * The data used to update ExtraTimeDays.
     */
    data: XOR<ExtraTimeDayUpdateManyMutationInput, ExtraTimeDayUncheckedUpdateManyInput>
    /**
     * Filter which ExtraTimeDays to update
     */
    where?: ExtraTimeDayWhereInput
    /**
     * Limit how many ExtraTimeDays to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtraTimeDay upsert
   */
  export type ExtraTimeDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtraTimeDay to update in case it exists.
     */
    where: ExtraTimeDayWhereUniqueInput
    /**
     * In case the ExtraTimeDay found by the `where` argument doesn't exist, create a new ExtraTimeDay with this data.
     */
    create: XOR<ExtraTimeDayCreateInput, ExtraTimeDayUncheckedCreateInput>
    /**
     * In case the ExtraTimeDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtraTimeDayUpdateInput, ExtraTimeDayUncheckedUpdateInput>
  }

  /**
   * ExtraTimeDay delete
   */
  export type ExtraTimeDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
    /**
     * Filter which ExtraTimeDay to delete.
     */
    where: ExtraTimeDayWhereUniqueInput
  }

  /**
   * ExtraTimeDay deleteMany
   */
  export type ExtraTimeDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtraTimeDays to delete
     */
    where?: ExtraTimeDayWhereInput
    /**
     * Limit how many ExtraTimeDays to delete.
     */
    limit?: number
  }

  /**
   * ExtraTimeDay without action
   */
  export type ExtraTimeDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtraTimeDay
     */
    select?: ExtraTimeDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtraTimeDay
     */
    omit?: ExtraTimeDayOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtraTimeDayInclude<ExtArgs> | null
  }


  /**
   * Model PointSystem
   */

  export type AggregatePointSystem = {
    _count: PointSystemCountAggregateOutputType | null
    _avg: PointSystemAvgAggregateOutputType | null
    _sum: PointSystemSumAggregateOutputType | null
    _min: PointSystemMinAggregateOutputType | null
    _max: PointSystemMaxAggregateOutputType | null
  }

  export type PointSystemAvgAggregateOutputType = {
    currentPoints: number | null
    pointsPerService: number | null
    pointsNeededForReward: number | null
    discountPercentage: number | null
  }

  export type PointSystemSumAggregateOutputType = {
    currentPoints: number | null
    pointsPerService: number | null
    pointsNeededForReward: number | null
    discountPercentage: number | null
  }

  export type PointSystemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentPoints: number | null
    pointsPerService: number | null
    pointsNeededForReward: number | null
    discountPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointSystemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentPoints: number | null
    pointsPerService: number | null
    pointsNeededForReward: number | null
    discountPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PointSystemCountAggregateOutputType = {
    id: number
    userId: number
    currentPoints: number
    pointsPerService: number
    pointsNeededForReward: number
    discountPercentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PointSystemAvgAggregateInputType = {
    currentPoints?: true
    pointsPerService?: true
    pointsNeededForReward?: true
    discountPercentage?: true
  }

  export type PointSystemSumAggregateInputType = {
    currentPoints?: true
    pointsPerService?: true
    pointsNeededForReward?: true
    discountPercentage?: true
  }

  export type PointSystemMinAggregateInputType = {
    id?: true
    userId?: true
    currentPoints?: true
    pointsPerService?: true
    pointsNeededForReward?: true
    discountPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointSystemMaxAggregateInputType = {
    id?: true
    userId?: true
    currentPoints?: true
    pointsPerService?: true
    pointsNeededForReward?: true
    discountPercentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PointSystemCountAggregateInputType = {
    id?: true
    userId?: true
    currentPoints?: true
    pointsPerService?: true
    pointsNeededForReward?: true
    discountPercentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PointSystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointSystem to aggregate.
     */
    where?: PointSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointSystems to fetch.
     */
    orderBy?: PointSystemOrderByWithRelationInput | PointSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointSystems
    **/
    _count?: true | PointSystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointSystemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointSystemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointSystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointSystemMaxAggregateInputType
  }

  export type GetPointSystemAggregateType<T extends PointSystemAggregateArgs> = {
        [P in keyof T & keyof AggregatePointSystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointSystem[P]>
      : GetScalarType<T[P], AggregatePointSystem[P]>
  }




  export type PointSystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointSystemWhereInput
    orderBy?: PointSystemOrderByWithAggregationInput | PointSystemOrderByWithAggregationInput[]
    by: PointSystemScalarFieldEnum[] | PointSystemScalarFieldEnum
    having?: PointSystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointSystemCountAggregateInputType | true
    _avg?: PointSystemAvgAggregateInputType
    _sum?: PointSystemSumAggregateInputType
    _min?: PointSystemMinAggregateInputType
    _max?: PointSystemMaxAggregateInputType
  }

  export type PointSystemGroupByOutputType = {
    id: string
    userId: string
    currentPoints: number
    pointsPerService: number
    pointsNeededForReward: number
    discountPercentage: number
    createdAt: Date
    updatedAt: Date
    _count: PointSystemCountAggregateOutputType | null
    _avg: PointSystemAvgAggregateOutputType | null
    _sum: PointSystemSumAggregateOutputType | null
    _min: PointSystemMinAggregateOutputType | null
    _max: PointSystemMaxAggregateOutputType | null
  }

  type GetPointSystemGroupByPayload<T extends PointSystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointSystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointSystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointSystemGroupByOutputType[P]>
            : GetScalarType<T[P], PointSystemGroupByOutputType[P]>
        }
      >
    >


  export type PointSystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentPoints?: boolean
    pointsPerService?: boolean
    pointsNeededForReward?: boolean
    discountPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupons?: boolean | PointSystem$couponsArgs<ExtArgs>
    pointTransactions?: boolean | PointSystem$pointTransactionsArgs<ExtArgs>
    _count?: boolean | PointSystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointSystem"]>

  export type PointSystemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentPoints?: boolean
    pointsPerService?: boolean
    pointsNeededForReward?: boolean
    discountPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointSystem"]>

  export type PointSystemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentPoints?: boolean
    pointsPerService?: boolean
    pointsNeededForReward?: boolean
    discountPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointSystem"]>

  export type PointSystemSelectScalar = {
    id?: boolean
    userId?: boolean
    currentPoints?: boolean
    pointsPerService?: boolean
    pointsNeededForReward?: boolean
    discountPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PointSystemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentPoints" | "pointsPerService" | "pointsNeededForReward" | "discountPercentage" | "createdAt" | "updatedAt", ExtArgs["result"]["pointSystem"]>
  export type PointSystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupons?: boolean | PointSystem$couponsArgs<ExtArgs>
    pointTransactions?: boolean | PointSystem$pointTransactionsArgs<ExtArgs>
    _count?: boolean | PointSystemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PointSystemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointSystemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointSystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointSystem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coupons: Prisma.$CouponPayload<ExtArgs>[]
      pointTransactions: Prisma.$PointTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentPoints: number
      pointsPerService: number
      pointsNeededForReward: number
      discountPercentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pointSystem"]>
    composites: {}
  }

  type PointSystemGetPayload<S extends boolean | null | undefined | PointSystemDefaultArgs> = $Result.GetResult<Prisma.$PointSystemPayload, S>

  type PointSystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointSystemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointSystemCountAggregateInputType | true
    }

  export interface PointSystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointSystem'], meta: { name: 'PointSystem' } }
    /**
     * Find zero or one PointSystem that matches the filter.
     * @param {PointSystemFindUniqueArgs} args - Arguments to find a PointSystem
     * @example
     * // Get one PointSystem
     * const pointSystem = await prisma.pointSystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointSystemFindUniqueArgs>(args: SelectSubset<T, PointSystemFindUniqueArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointSystem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointSystemFindUniqueOrThrowArgs} args - Arguments to find a PointSystem
     * @example
     * // Get one PointSystem
     * const pointSystem = await prisma.pointSystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointSystemFindUniqueOrThrowArgs>(args: SelectSubset<T, PointSystemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointSystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemFindFirstArgs} args - Arguments to find a PointSystem
     * @example
     * // Get one PointSystem
     * const pointSystem = await prisma.pointSystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointSystemFindFirstArgs>(args?: SelectSubset<T, PointSystemFindFirstArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointSystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemFindFirstOrThrowArgs} args - Arguments to find a PointSystem
     * @example
     * // Get one PointSystem
     * const pointSystem = await prisma.pointSystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointSystemFindFirstOrThrowArgs>(args?: SelectSubset<T, PointSystemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointSystems
     * const pointSystems = await prisma.pointSystem.findMany()
     * 
     * // Get first 10 PointSystems
     * const pointSystems = await prisma.pointSystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointSystemWithIdOnly = await prisma.pointSystem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointSystemFindManyArgs>(args?: SelectSubset<T, PointSystemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointSystem.
     * @param {PointSystemCreateArgs} args - Arguments to create a PointSystem.
     * @example
     * // Create one PointSystem
     * const PointSystem = await prisma.pointSystem.create({
     *   data: {
     *     // ... data to create a PointSystem
     *   }
     * })
     * 
     */
    create<T extends PointSystemCreateArgs>(args: SelectSubset<T, PointSystemCreateArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointSystems.
     * @param {PointSystemCreateManyArgs} args - Arguments to create many PointSystems.
     * @example
     * // Create many PointSystems
     * const pointSystem = await prisma.pointSystem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointSystemCreateManyArgs>(args?: SelectSubset<T, PointSystemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointSystems and returns the data saved in the database.
     * @param {PointSystemCreateManyAndReturnArgs} args - Arguments to create many PointSystems.
     * @example
     * // Create many PointSystems
     * const pointSystem = await prisma.pointSystem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointSystems and only return the `id`
     * const pointSystemWithIdOnly = await prisma.pointSystem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointSystemCreateManyAndReturnArgs>(args?: SelectSubset<T, PointSystemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointSystem.
     * @param {PointSystemDeleteArgs} args - Arguments to delete one PointSystem.
     * @example
     * // Delete one PointSystem
     * const PointSystem = await prisma.pointSystem.delete({
     *   where: {
     *     // ... filter to delete one PointSystem
     *   }
     * })
     * 
     */
    delete<T extends PointSystemDeleteArgs>(args: SelectSubset<T, PointSystemDeleteArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointSystem.
     * @param {PointSystemUpdateArgs} args - Arguments to update one PointSystem.
     * @example
     * // Update one PointSystem
     * const pointSystem = await prisma.pointSystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointSystemUpdateArgs>(args: SelectSubset<T, PointSystemUpdateArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointSystems.
     * @param {PointSystemDeleteManyArgs} args - Arguments to filter PointSystems to delete.
     * @example
     * // Delete a few PointSystems
     * const { count } = await prisma.pointSystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointSystemDeleteManyArgs>(args?: SelectSubset<T, PointSystemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointSystems
     * const pointSystem = await prisma.pointSystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointSystemUpdateManyArgs>(args: SelectSubset<T, PointSystemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointSystems and returns the data updated in the database.
     * @param {PointSystemUpdateManyAndReturnArgs} args - Arguments to update many PointSystems.
     * @example
     * // Update many PointSystems
     * const pointSystem = await prisma.pointSystem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointSystems and only return the `id`
     * const pointSystemWithIdOnly = await prisma.pointSystem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointSystemUpdateManyAndReturnArgs>(args: SelectSubset<T, PointSystemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointSystem.
     * @param {PointSystemUpsertArgs} args - Arguments to update or create a PointSystem.
     * @example
     * // Update or create a PointSystem
     * const pointSystem = await prisma.pointSystem.upsert({
     *   create: {
     *     // ... data to create a PointSystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointSystem we want to update
     *   }
     * })
     */
    upsert<T extends PointSystemUpsertArgs>(args: SelectSubset<T, PointSystemUpsertArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemCountArgs} args - Arguments to filter PointSystems to count.
     * @example
     * // Count the number of PointSystems
     * const count = await prisma.pointSystem.count({
     *   where: {
     *     // ... the filter for the PointSystems we want to count
     *   }
     * })
    **/
    count<T extends PointSystemCountArgs>(
      args?: Subset<T, PointSystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointSystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointSystemAggregateArgs>(args: Subset<T, PointSystemAggregateArgs>): Prisma.PrismaPromise<GetPointSystemAggregateType<T>>

    /**
     * Group by PointSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointSystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointSystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointSystemGroupByArgs['orderBy'] }
        : { orderBy?: PointSystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointSystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointSystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointSystem model
   */
  readonly fields: PointSystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointSystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointSystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coupons<T extends PointSystem$couponsArgs<ExtArgs> = {}>(args?: Subset<T, PointSystem$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointTransactions<T extends PointSystem$pointTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, PointSystem$pointTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointSystem model
   */
  interface PointSystemFieldRefs {
    readonly id: FieldRef<"PointSystem", 'String'>
    readonly userId: FieldRef<"PointSystem", 'String'>
    readonly currentPoints: FieldRef<"PointSystem", 'Int'>
    readonly pointsPerService: FieldRef<"PointSystem", 'Int'>
    readonly pointsNeededForReward: FieldRef<"PointSystem", 'Int'>
    readonly discountPercentage: FieldRef<"PointSystem", 'Int'>
    readonly createdAt: FieldRef<"PointSystem", 'DateTime'>
    readonly updatedAt: FieldRef<"PointSystem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointSystem findUnique
   */
  export type PointSystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter, which PointSystem to fetch.
     */
    where: PointSystemWhereUniqueInput
  }

  /**
   * PointSystem findUniqueOrThrow
   */
  export type PointSystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter, which PointSystem to fetch.
     */
    where: PointSystemWhereUniqueInput
  }

  /**
   * PointSystem findFirst
   */
  export type PointSystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter, which PointSystem to fetch.
     */
    where?: PointSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointSystems to fetch.
     */
    orderBy?: PointSystemOrderByWithRelationInput | PointSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointSystems.
     */
    cursor?: PointSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointSystems.
     */
    distinct?: PointSystemScalarFieldEnum | PointSystemScalarFieldEnum[]
  }

  /**
   * PointSystem findFirstOrThrow
   */
  export type PointSystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter, which PointSystem to fetch.
     */
    where?: PointSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointSystems to fetch.
     */
    orderBy?: PointSystemOrderByWithRelationInput | PointSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointSystems.
     */
    cursor?: PointSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointSystems.
     */
    distinct?: PointSystemScalarFieldEnum | PointSystemScalarFieldEnum[]
  }

  /**
   * PointSystem findMany
   */
  export type PointSystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter, which PointSystems to fetch.
     */
    where?: PointSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointSystems to fetch.
     */
    orderBy?: PointSystemOrderByWithRelationInput | PointSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointSystems.
     */
    cursor?: PointSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointSystems.
     */
    skip?: number
    distinct?: PointSystemScalarFieldEnum | PointSystemScalarFieldEnum[]
  }

  /**
   * PointSystem create
   */
  export type PointSystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * The data needed to create a PointSystem.
     */
    data: XOR<PointSystemCreateInput, PointSystemUncheckedCreateInput>
  }

  /**
   * PointSystem createMany
   */
  export type PointSystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointSystems.
     */
    data: PointSystemCreateManyInput | PointSystemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointSystem createManyAndReturn
   */
  export type PointSystemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * The data used to create many PointSystems.
     */
    data: PointSystemCreateManyInput | PointSystemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointSystem update
   */
  export type PointSystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * The data needed to update a PointSystem.
     */
    data: XOR<PointSystemUpdateInput, PointSystemUncheckedUpdateInput>
    /**
     * Choose, which PointSystem to update.
     */
    where: PointSystemWhereUniqueInput
  }

  /**
   * PointSystem updateMany
   */
  export type PointSystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointSystems.
     */
    data: XOR<PointSystemUpdateManyMutationInput, PointSystemUncheckedUpdateManyInput>
    /**
     * Filter which PointSystems to update
     */
    where?: PointSystemWhereInput
    /**
     * Limit how many PointSystems to update.
     */
    limit?: number
  }

  /**
   * PointSystem updateManyAndReturn
   */
  export type PointSystemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * The data used to update PointSystems.
     */
    data: XOR<PointSystemUpdateManyMutationInput, PointSystemUncheckedUpdateManyInput>
    /**
     * Filter which PointSystems to update
     */
    where?: PointSystemWhereInput
    /**
     * Limit how many PointSystems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointSystem upsert
   */
  export type PointSystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * The filter to search for the PointSystem to update in case it exists.
     */
    where: PointSystemWhereUniqueInput
    /**
     * In case the PointSystem found by the `where` argument doesn't exist, create a new PointSystem with this data.
     */
    create: XOR<PointSystemCreateInput, PointSystemUncheckedCreateInput>
    /**
     * In case the PointSystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointSystemUpdateInput, PointSystemUncheckedUpdateInput>
  }

  /**
   * PointSystem delete
   */
  export type PointSystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
    /**
     * Filter which PointSystem to delete.
     */
    where: PointSystemWhereUniqueInput
  }

  /**
   * PointSystem deleteMany
   */
  export type PointSystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointSystems to delete
     */
    where?: PointSystemWhereInput
    /**
     * Limit how many PointSystems to delete.
     */
    limit?: number
  }

  /**
   * PointSystem.coupons
   */
  export type PointSystem$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * PointSystem.pointTransactions
   */
  export type PointSystem$pointTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    cursor?: PointTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointSystem without action
   */
  export type PointSystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointSystem
     */
    select?: PointSystemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointSystem
     */
    omit?: PointSystemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointSystemInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discountPercent: number | null
  }

  export type CouponSumAggregateOutputType = {
    discountPercent: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    pointSystemId: string | null
    discountPercent: number | null
    isUsed: boolean | null
    usedAt: Date | null
    bookingId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    pointSystemId: string | null
    discountPercent: number | null
    isUsed: boolean | null
    usedAt: Date | null
    bookingId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    pointSystemId: number
    discountPercent: number
    isUsed: number
    usedAt: number
    bookingId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discountPercent?: true
  }

  export type CouponSumAggregateInputType = {
    discountPercent?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    pointSystemId?: true
    discountPercent?: true
    isUsed?: true
    usedAt?: true
    bookingId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    pointSystemId?: true
    discountPercent?: true
    isUsed?: true
    usedAt?: true
    bookingId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    pointSystemId?: true
    discountPercent?: true
    isUsed?: true
    usedAt?: true
    bookingId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    pointSystemId: string
    discountPercent: number
    isUsed: boolean
    usedAt: Date | null
    bookingId: string | null
    createdAt: Date
    expiresAt: Date | null
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    discountPercent?: boolean
    isUsed?: boolean
    usedAt?: boolean
    bookingId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
    notifications?: boolean | Coupon$notificationsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    discountPercent?: boolean
    isUsed?: boolean
    usedAt?: boolean
    bookingId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    discountPercent?: boolean
    isUsed?: boolean
    usedAt?: boolean
    bookingId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    pointSystemId?: boolean
    discountPercent?: boolean
    isUsed?: boolean
    usedAt?: boolean
    bookingId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pointSystemId" | "discountPercent" | "isUsed" | "usedAt" | "bookingId" | "createdAt" | "expiresAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
    notifications?: boolean | Coupon$notificationsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
  }
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    booking?: boolean | Coupon$bookingArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      pointSystem: Prisma.$PointSystemPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pointSystemId: string
      discountPercent: number
      isUsed: boolean
      usedAt: Date | null
      bookingId: string | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pointSystem<T extends PointSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PointSystemDefaultArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends Coupon$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends Coupon$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly pointSystemId: FieldRef<"Coupon", 'String'>
    readonly discountPercent: FieldRef<"Coupon", 'Int'>
    readonly isUsed: FieldRef<"Coupon", 'Boolean'>
    readonly usedAt: FieldRef<"Coupon", 'DateTime'>
    readonly bookingId: FieldRef<"Coupon", 'String'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly expiresAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.booking
   */
  export type Coupon$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Coupon.notifications
   */
  export type Coupon$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model PointTransaction
   */

  export type AggregatePointTransaction = {
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  export type PointTransactionAvgAggregateOutputType = {
    points: number | null
  }

  export type PointTransactionSumAggregateOutputType = {
    points: number | null
  }

  export type PointTransactionMinAggregateOutputType = {
    id: string | null
    pointSystemId: string | null
    points: number | null
    type: $Enums.TransactionType | null
    description: string | null
    bookingId: string | null
    createdAt: Date | null
    status: $Enums.TransactionStatus | null
    confirmedAt: Date | null
    confirmedBy: string | null
  }

  export type PointTransactionMaxAggregateOutputType = {
    id: string | null
    pointSystemId: string | null
    points: number | null
    type: $Enums.TransactionType | null
    description: string | null
    bookingId: string | null
    createdAt: Date | null
    status: $Enums.TransactionStatus | null
    confirmedAt: Date | null
    confirmedBy: string | null
  }

  export type PointTransactionCountAggregateOutputType = {
    id: number
    pointSystemId: number
    points: number
    type: number
    description: number
    bookingId: number
    createdAt: number
    status: number
    confirmedAt: number
    confirmedBy: number
    _all: number
  }


  export type PointTransactionAvgAggregateInputType = {
    points?: true
  }

  export type PointTransactionSumAggregateInputType = {
    points?: true
  }

  export type PointTransactionMinAggregateInputType = {
    id?: true
    pointSystemId?: true
    points?: true
    type?: true
    description?: true
    bookingId?: true
    createdAt?: true
    status?: true
    confirmedAt?: true
    confirmedBy?: true
  }

  export type PointTransactionMaxAggregateInputType = {
    id?: true
    pointSystemId?: true
    points?: true
    type?: true
    description?: true
    bookingId?: true
    createdAt?: true
    status?: true
    confirmedAt?: true
    confirmedBy?: true
  }

  export type PointTransactionCountAggregateInputType = {
    id?: true
    pointSystemId?: true
    points?: true
    type?: true
    description?: true
    bookingId?: true
    createdAt?: true
    status?: true
    confirmedAt?: true
    confirmedBy?: true
    _all?: true
  }

  export type PointTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransaction to aggregate.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointTransactions
    **/
    _count?: true | PointTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointTransactionMaxAggregateInputType
  }

  export type GetPointTransactionAggregateType<T extends PointTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePointTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointTransaction[P]>
      : GetScalarType<T[P], AggregatePointTransaction[P]>
  }




  export type PointTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointTransactionWhereInput
    orderBy?: PointTransactionOrderByWithAggregationInput | PointTransactionOrderByWithAggregationInput[]
    by: PointTransactionScalarFieldEnum[] | PointTransactionScalarFieldEnum
    having?: PointTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointTransactionCountAggregateInputType | true
    _avg?: PointTransactionAvgAggregateInputType
    _sum?: PointTransactionSumAggregateInputType
    _min?: PointTransactionMinAggregateInputType
    _max?: PointTransactionMaxAggregateInputType
  }

  export type PointTransactionGroupByOutputType = {
    id: string
    pointSystemId: string
    points: number
    type: $Enums.TransactionType
    description: string | null
    bookingId: string | null
    createdAt: Date
    status: $Enums.TransactionStatus
    confirmedAt: Date | null
    confirmedBy: string | null
    _count: PointTransactionCountAggregateOutputType | null
    _avg: PointTransactionAvgAggregateOutputType | null
    _sum: PointTransactionSumAggregateOutputType | null
    _min: PointTransactionMinAggregateOutputType | null
    _max: PointTransactionMaxAggregateOutputType | null
  }

  type GetPointTransactionGroupByPayload<T extends PointTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PointTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PointTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    bookingId?: boolean
    createdAt?: boolean
    status?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    notifications?: boolean | PointTransaction$notificationsArgs<ExtArgs>
    _count?: boolean | PointTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    bookingId?: boolean
    createdAt?: boolean
    status?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointSystemId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    bookingId?: boolean
    createdAt?: boolean
    status?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointTransaction"]>

  export type PointTransactionSelectScalar = {
    id?: boolean
    pointSystemId?: boolean
    points?: boolean
    type?: boolean
    description?: boolean
    bookingId?: boolean
    createdAt?: boolean
    status?: boolean
    confirmedAt?: boolean
    confirmedBy?: boolean
  }

  export type PointTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pointSystemId" | "points" | "type" | "description" | "bookingId" | "createdAt" | "status" | "confirmedAt" | "confirmedBy", ExtArgs["result"]["pointTransaction"]>
  export type PointTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
    notifications?: boolean | PointTransaction$notificationsArgs<ExtArgs>
    _count?: boolean | PointTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PointTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
  }
  export type PointTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pointSystem?: boolean | PointSystemDefaultArgs<ExtArgs>
  }

  export type $PointTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointTransaction"
    objects: {
      pointSystem: Prisma.$PointSystemPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pointSystemId: string
      points: number
      type: $Enums.TransactionType
      description: string | null
      bookingId: string | null
      createdAt: Date
      status: $Enums.TransactionStatus
      confirmedAt: Date | null
      confirmedBy: string | null
    }, ExtArgs["result"]["pointTransaction"]>
    composites: {}
  }

  type PointTransactionGetPayload<S extends boolean | null | undefined | PointTransactionDefaultArgs> = $Result.GetResult<Prisma.$PointTransactionPayload, S>

  type PointTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointTransactionCountAggregateInputType | true
    }

  export interface PointTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointTransaction'], meta: { name: 'PointTransaction' } }
    /**
     * Find zero or one PointTransaction that matches the filter.
     * @param {PointTransactionFindUniqueArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointTransactionFindUniqueArgs>(args: SelectSubset<T, PointTransactionFindUniqueArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointTransactionFindUniqueOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PointTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointTransactionFindFirstArgs>(args?: SelectSubset<T, PointTransactionFindFirstArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindFirstOrThrowArgs} args - Arguments to find a PointTransaction
     * @example
     * // Get one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PointTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany()
     * 
     * // Get first 10 PointTransactions
     * const pointTransactions = await prisma.pointTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointTransactionFindManyArgs>(args?: SelectSubset<T, PointTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointTransaction.
     * @param {PointTransactionCreateArgs} args - Arguments to create a PointTransaction.
     * @example
     * // Create one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.create({
     *   data: {
     *     // ... data to create a PointTransaction
     *   }
     * })
     * 
     */
    create<T extends PointTransactionCreateArgs>(args: SelectSubset<T, PointTransactionCreateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointTransactions.
     * @param {PointTransactionCreateManyArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointTransactionCreateManyArgs>(args?: SelectSubset<T, PointTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointTransactions and returns the data saved in the database.
     * @param {PointTransactionCreateManyAndReturnArgs} args - Arguments to create many PointTransactions.
     * @example
     * // Create many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointTransactions and only return the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PointTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointTransaction.
     * @param {PointTransactionDeleteArgs} args - Arguments to delete one PointTransaction.
     * @example
     * // Delete one PointTransaction
     * const PointTransaction = await prisma.pointTransaction.delete({
     *   where: {
     *     // ... filter to delete one PointTransaction
     *   }
     * })
     * 
     */
    delete<T extends PointTransactionDeleteArgs>(args: SelectSubset<T, PointTransactionDeleteArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointTransaction.
     * @param {PointTransactionUpdateArgs} args - Arguments to update one PointTransaction.
     * @example
     * // Update one PointTransaction
     * const pointTransaction = await prisma.pointTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointTransactionUpdateArgs>(args: SelectSubset<T, PointTransactionUpdateArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointTransactions.
     * @param {PointTransactionDeleteManyArgs} args - Arguments to filter PointTransactions to delete.
     * @example
     * // Delete a few PointTransactions
     * const { count } = await prisma.pointTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointTransactionDeleteManyArgs>(args?: SelectSubset<T, PointTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointTransactionUpdateManyArgs>(args: SelectSubset<T, PointTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointTransactions and returns the data updated in the database.
     * @param {PointTransactionUpdateManyAndReturnArgs} args - Arguments to update many PointTransactions.
     * @example
     * // Update many PointTransactions
     * const pointTransaction = await prisma.pointTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointTransactions and only return the `id`
     * const pointTransactionWithIdOnly = await prisma.pointTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PointTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointTransaction.
     * @param {PointTransactionUpsertArgs} args - Arguments to update or create a PointTransaction.
     * @example
     * // Update or create a PointTransaction
     * const pointTransaction = await prisma.pointTransaction.upsert({
     *   create: {
     *     // ... data to create a PointTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PointTransactionUpsertArgs>(args: SelectSubset<T, PointTransactionUpsertArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionCountArgs} args - Arguments to filter PointTransactions to count.
     * @example
     * // Count the number of PointTransactions
     * const count = await prisma.pointTransaction.count({
     *   where: {
     *     // ... the filter for the PointTransactions we want to count
     *   }
     * })
    **/
    count<T extends PointTransactionCountArgs>(
      args?: Subset<T, PointTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointTransactionAggregateArgs>(args: Subset<T, PointTransactionAggregateArgs>): Prisma.PrismaPromise<GetPointTransactionAggregateType<T>>

    /**
     * Group by PointTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PointTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointTransaction model
   */
  readonly fields: PointTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pointSystem<T extends PointSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PointSystemDefaultArgs<ExtArgs>>): Prisma__PointSystemClient<$Result.GetResult<Prisma.$PointSystemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends PointTransaction$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, PointTransaction$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointTransaction model
   */
  interface PointTransactionFieldRefs {
    readonly id: FieldRef<"PointTransaction", 'String'>
    readonly pointSystemId: FieldRef<"PointTransaction", 'String'>
    readonly points: FieldRef<"PointTransaction", 'Int'>
    readonly type: FieldRef<"PointTransaction", 'TransactionType'>
    readonly description: FieldRef<"PointTransaction", 'String'>
    readonly bookingId: FieldRef<"PointTransaction", 'String'>
    readonly createdAt: FieldRef<"PointTransaction", 'DateTime'>
    readonly status: FieldRef<"PointTransaction", 'TransactionStatus'>
    readonly confirmedAt: FieldRef<"PointTransaction", 'DateTime'>
    readonly confirmedBy: FieldRef<"PointTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PointTransaction findUnique
   */
  export type PointTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findUniqueOrThrow
   */
  export type PointTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction findFirst
   */
  export type PointTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findFirstOrThrow
   */
  export type PointTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransaction to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointTransactions.
     */
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction findMany
   */
  export type PointTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PointTransactions to fetch.
     */
    where?: PointTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointTransactions to fetch.
     */
    orderBy?: PointTransactionOrderByWithRelationInput | PointTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointTransactions.
     */
    cursor?: PointTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointTransactions.
     */
    skip?: number
    distinct?: PointTransactionScalarFieldEnum | PointTransactionScalarFieldEnum[]
  }

  /**
   * PointTransaction create
   */
  export type PointTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PointTransaction.
     */
    data: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
  }

  /**
   * PointTransaction createMany
   */
  export type PointTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointTransaction createManyAndReturn
   */
  export type PointTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PointTransactions.
     */
    data: PointTransactionCreateManyInput | PointTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointTransaction update
   */
  export type PointTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PointTransaction.
     */
    data: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
    /**
     * Choose, which PointTransaction to update.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction updateMany
   */
  export type PointTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to update.
     */
    limit?: number
  }

  /**
   * PointTransaction updateManyAndReturn
   */
  export type PointTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PointTransactions.
     */
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PointTransactions to update
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointTransaction upsert
   */
  export type PointTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PointTransaction to update in case it exists.
     */
    where: PointTransactionWhereUniqueInput
    /**
     * In case the PointTransaction found by the `where` argument doesn't exist, create a new PointTransaction with this data.
     */
    create: XOR<PointTransactionCreateInput, PointTransactionUncheckedCreateInput>
    /**
     * In case the PointTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointTransactionUpdateInput, PointTransactionUncheckedUpdateInput>
  }

  /**
   * PointTransaction delete
   */
  export type PointTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    /**
     * Filter which PointTransaction to delete.
     */
    where: PointTransactionWhereUniqueInput
  }

  /**
   * PointTransaction deleteMany
   */
  export type PointTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointTransactions to delete
     */
    where?: PointTransactionWhereInput
    /**
     * Limit how many PointTransactions to delete.
     */
    limit?: number
  }

  /**
   * PointTransaction.notifications
   */
  export type PointTransaction$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * PointTransaction without action
   */
  export type PointTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    recipientType: $Enums.NotificationRecipient | null
    barberId: string | null
    userId: string | null
    bookingId: string | null
    couponId: string | null
    transactionId: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    read: boolean | null
    recipientType: $Enums.NotificationRecipient | null
    barberId: string | null
    userId: string | null
    bookingId: string | null
    couponId: string | null
    transactionId: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    read: number
    recipientType: number
    barberId: number
    userId: number
    bookingId: number
    couponId: number
    transactionId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    recipientType?: true
    barberId?: true
    userId?: true
    bookingId?: true
    couponId?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    recipientType?: true
    barberId?: true
    userId?: true
    bookingId?: true
    couponId?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    read?: true
    recipientType?: true
    barberId?: true
    userId?: true
    bookingId?: true
    couponId?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    read: boolean
    recipientType: $Enums.NotificationRecipient
    barberId: string | null
    userId: string | null
    bookingId: string | null
    couponId: string | null
    transactionId: string | null
    metadata: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    recipientType?: boolean
    barberId?: boolean
    userId?: boolean
    bookingId?: boolean
    couponId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    recipientType?: boolean
    barberId?: boolean
    userId?: boolean
    bookingId?: boolean
    couponId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    recipientType?: boolean
    barberId?: boolean
    userId?: boolean
    bookingId?: boolean
    couponId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    recipientType?: boolean
    barberId?: boolean
    userId?: boolean
    bookingId?: boolean
    couponId?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "read" | "recipientType" | "barberId" | "userId" | "bookingId" | "couponId" | "transactionId" | "metadata" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    booking?: boolean | Notification$bookingArgs<ExtArgs>
    coupon?: boolean | Notification$couponArgs<ExtArgs>
    transaction?: boolean | Notification$transactionArgs<ExtArgs>
    barber?: boolean | Notification$barberArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
      coupon: Prisma.$CouponPayload<ExtArgs> | null
      transaction: Prisma.$PointTransactionPayload<ExtArgs> | null
      barber: Prisma.$BarberProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      read: boolean
      recipientType: $Enums.NotificationRecipient
      barberId: string | null
      userId: string | null
      bookingId: string | null
      couponId: string | null
      transactionId: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends Notification$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Notification$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends Notification$couponArgs<ExtArgs> = {}>(args?: Subset<T, Notification$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends Notification$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Notification$transactionArgs<ExtArgs>>): Prisma__PointTransactionClient<$Result.GetResult<Prisma.$PointTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    barber<T extends Notification$barberArgs<ExtArgs> = {}>(args?: Subset<T, Notification$barberArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly recipientType: FieldRef<"Notification", 'NotificationRecipient'>
    readonly barberId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly bookingId: FieldRef<"Notification", 'String'>
    readonly couponId: FieldRef<"Notification", 'String'>
    readonly transactionId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification.booking
   */
  export type Notification$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Notification.coupon
   */
  export type Notification$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * Notification.transaction
   */
  export type Notification$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointTransaction
     */
    select?: PointTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointTransaction
     */
    omit?: PointTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointTransactionInclude<ExtArgs> | null
    where?: PointTransactionWhereInput
  }

  /**
   * Notification.barber
   */
  export type Notification$barberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BarberProfile
     */
    select?: BarberProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BarberProfile
     */
    omit?: BarberProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberProfileInclude<ExtArgs> | null
    where?: BarberProfileWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ClientPlan
   */

  export type AggregateClientPlan = {
    _count: ClientPlanCountAggregateOutputType | null
    _avg: ClientPlanAvgAggregateOutputType | null
    _sum: ClientPlanSumAggregateOutputType | null
    _min: ClientPlanMinAggregateOutputType | null
    _max: ClientPlanMaxAggregateOutputType | null
  }

  export type ClientPlanAvgAggregateOutputType = {
    useAmount: number | null
  }

  export type ClientPlanSumAggregateOutputType = {
    useAmount: number | null
  }

  export type ClientPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    barberId: string | null
    planId: string | null
    useAmount: number | null
    starts: Date | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    barberId: string | null
    planId: string | null
    useAmount: number | null
    starts: Date | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientPlanCountAggregateOutputType = {
    id: number
    userId: number
    barberId: number
    planId: number
    useAmount: number
    starts: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientPlanAvgAggregateInputType = {
    useAmount?: true
  }

  export type ClientPlanSumAggregateInputType = {
    useAmount?: true
  }

  export type ClientPlanMinAggregateInputType = {
    id?: true
    userId?: true
    barberId?: true
    planId?: true
    useAmount?: true
    starts?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    barberId?: true
    planId?: true
    useAmount?: true
    starts?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientPlanCountAggregateInputType = {
    id?: true
    userId?: true
    barberId?: true
    planId?: true
    useAmount?: true
    starts?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPlan to aggregate.
     */
    where?: ClientPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientPlans
    **/
    _count?: true | ClientPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientPlanMaxAggregateInputType
  }

  export type GetClientPlanAggregateType<T extends ClientPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateClientPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientPlan[P]>
      : GetScalarType<T[P], AggregateClientPlan[P]>
  }




  export type ClientPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientPlanWhereInput
    orderBy?: ClientPlanOrderByWithAggregationInput | ClientPlanOrderByWithAggregationInput[]
    by: ClientPlanScalarFieldEnum[] | ClientPlanScalarFieldEnum
    having?: ClientPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientPlanCountAggregateInputType | true
    _avg?: ClientPlanAvgAggregateInputType
    _sum?: ClientPlanSumAggregateInputType
    _min?: ClientPlanMinAggregateInputType
    _max?: ClientPlanMaxAggregateInputType
  }

  export type ClientPlanGroupByOutputType = {
    id: string
    userId: string
    barberId: string
    planId: string
    useAmount: number
    starts: Date
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: ClientPlanCountAggregateOutputType | null
    _avg: ClientPlanAvgAggregateOutputType | null
    _sum: ClientPlanSumAggregateOutputType | null
    _min: ClientPlanMinAggregateOutputType | null
    _max: ClientPlanMaxAggregateOutputType | null
  }

  type GetClientPlanGroupByPayload<T extends ClientPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ClientPlanGroupByOutputType[P]>
        }
      >
    >


  export type ClientPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barberId?: boolean
    planId?: boolean
    useAmount?: boolean
    starts?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    booking?: boolean | ClientPlan$bookingArgs<ExtArgs>
    _count?: boolean | ClientPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPlan"]>

  export type ClientPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barberId?: boolean
    planId?: boolean
    useAmount?: boolean
    starts?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPlan"]>

  export type ClientPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    barberId?: boolean
    planId?: boolean
    useAmount?: boolean
    starts?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientPlan"]>

  export type ClientPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    barberId?: boolean
    planId?: boolean
    useAmount?: boolean
    starts?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "barberId" | "planId" | "useAmount" | "starts" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["clientPlan"]>
  export type ClientPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    booking?: boolean | ClientPlan$bookingArgs<ExtArgs>
    _count?: boolean | ClientPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type ClientPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $ClientPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      barber: Prisma.$BarberProfilePayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      barberId: string
      planId: string
      useAmount: number
      starts: Date
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientPlan"]>
    composites: {}
  }

  type ClientPlanGetPayload<S extends boolean | null | undefined | ClientPlanDefaultArgs> = $Result.GetResult<Prisma.$ClientPlanPayload, S>

  type ClientPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientPlanCountAggregateInputType | true
    }

  export interface ClientPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientPlan'], meta: { name: 'ClientPlan' } }
    /**
     * Find zero or one ClientPlan that matches the filter.
     * @param {ClientPlanFindUniqueArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientPlanFindUniqueArgs>(args: SelectSubset<T, ClientPlanFindUniqueArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientPlanFindUniqueOrThrowArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindFirstArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientPlanFindFirstArgs>(args?: SelectSubset<T, ClientPlanFindFirstArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindFirstOrThrowArgs} args - Arguments to find a ClientPlan
     * @example
     * // Get one ClientPlan
     * const clientPlan = await prisma.clientPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientPlans
     * const clientPlans = await prisma.clientPlan.findMany()
     * 
     * // Get first 10 ClientPlans
     * const clientPlans = await prisma.clientPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientPlanFindManyArgs>(args?: SelectSubset<T, ClientPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientPlan.
     * @param {ClientPlanCreateArgs} args - Arguments to create a ClientPlan.
     * @example
     * // Create one ClientPlan
     * const ClientPlan = await prisma.clientPlan.create({
     *   data: {
     *     // ... data to create a ClientPlan
     *   }
     * })
     * 
     */
    create<T extends ClientPlanCreateArgs>(args: SelectSubset<T, ClientPlanCreateArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientPlans.
     * @param {ClientPlanCreateManyArgs} args - Arguments to create many ClientPlans.
     * @example
     * // Create many ClientPlans
     * const clientPlan = await prisma.clientPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientPlanCreateManyArgs>(args?: SelectSubset<T, ClientPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientPlans and returns the data saved in the database.
     * @param {ClientPlanCreateManyAndReturnArgs} args - Arguments to create many ClientPlans.
     * @example
     * // Create many ClientPlans
     * const clientPlan = await prisma.clientPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientPlans and only return the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientPlan.
     * @param {ClientPlanDeleteArgs} args - Arguments to delete one ClientPlan.
     * @example
     * // Delete one ClientPlan
     * const ClientPlan = await prisma.clientPlan.delete({
     *   where: {
     *     // ... filter to delete one ClientPlan
     *   }
     * })
     * 
     */
    delete<T extends ClientPlanDeleteArgs>(args: SelectSubset<T, ClientPlanDeleteArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientPlan.
     * @param {ClientPlanUpdateArgs} args - Arguments to update one ClientPlan.
     * @example
     * // Update one ClientPlan
     * const clientPlan = await prisma.clientPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientPlanUpdateArgs>(args: SelectSubset<T, ClientPlanUpdateArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientPlans.
     * @param {ClientPlanDeleteManyArgs} args - Arguments to filter ClientPlans to delete.
     * @example
     * // Delete a few ClientPlans
     * const { count } = await prisma.clientPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientPlanDeleteManyArgs>(args?: SelectSubset<T, ClientPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientPlans
     * const clientPlan = await prisma.clientPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientPlanUpdateManyArgs>(args: SelectSubset<T, ClientPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientPlans and returns the data updated in the database.
     * @param {ClientPlanUpdateManyAndReturnArgs} args - Arguments to update many ClientPlans.
     * @example
     * // Update many ClientPlans
     * const clientPlan = await prisma.clientPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientPlans and only return the `id`
     * const clientPlanWithIdOnly = await prisma.clientPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientPlan.
     * @param {ClientPlanUpsertArgs} args - Arguments to update or create a ClientPlan.
     * @example
     * // Update or create a ClientPlan
     * const clientPlan = await prisma.clientPlan.upsert({
     *   create: {
     *     // ... data to create a ClientPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientPlan we want to update
     *   }
     * })
     */
    upsert<T extends ClientPlanUpsertArgs>(args: SelectSubset<T, ClientPlanUpsertArgs<ExtArgs>>): Prisma__ClientPlanClient<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanCountArgs} args - Arguments to filter ClientPlans to count.
     * @example
     * // Count the number of ClientPlans
     * const count = await prisma.clientPlan.count({
     *   where: {
     *     // ... the filter for the ClientPlans we want to count
     *   }
     * })
    **/
    count<T extends ClientPlanCountArgs>(
      args?: Subset<T, ClientPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientPlanAggregateArgs>(args: Subset<T, ClientPlanAggregateArgs>): Prisma.PrismaPromise<GetClientPlanAggregateType<T>>

    /**
     * Group by ClientPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientPlanGroupByArgs['orderBy'] }
        : { orderBy?: ClientPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientPlan model
   */
  readonly fields: ClientPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends ClientPlan$bookingArgs<ExtArgs> = {}>(args?: Subset<T, ClientPlan$bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientPlan model
   */
  interface ClientPlanFieldRefs {
    readonly id: FieldRef<"ClientPlan", 'String'>
    readonly userId: FieldRef<"ClientPlan", 'String'>
    readonly barberId: FieldRef<"ClientPlan", 'String'>
    readonly planId: FieldRef<"ClientPlan", 'String'>
    readonly useAmount: FieldRef<"ClientPlan", 'Int'>
    readonly starts: FieldRef<"ClientPlan", 'DateTime'>
    readonly expires: FieldRef<"ClientPlan", 'DateTime'>
    readonly createdAt: FieldRef<"ClientPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientPlan findUnique
   */
  export type ClientPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClientPlan to fetch.
     */
    where: ClientPlanWhereUniqueInput
  }

  /**
   * ClientPlan findUniqueOrThrow
   */
  export type ClientPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClientPlan to fetch.
     */
    where: ClientPlanWhereUniqueInput
  }

  /**
   * ClientPlan findFirst
   */
  export type ClientPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClientPlan to fetch.
     */
    where?: ClientPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPlans.
     */
    cursor?: ClientPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPlans.
     */
    distinct?: ClientPlanScalarFieldEnum | ClientPlanScalarFieldEnum[]
  }

  /**
   * ClientPlan findFirstOrThrow
   */
  export type ClientPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClientPlan to fetch.
     */
    where?: ClientPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientPlans.
     */
    cursor?: ClientPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientPlans.
     */
    distinct?: ClientPlanScalarFieldEnum | ClientPlanScalarFieldEnum[]
  }

  /**
   * ClientPlan findMany
   */
  export type ClientPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter, which ClientPlans to fetch.
     */
    where?: ClientPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientPlans to fetch.
     */
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientPlans.
     */
    cursor?: ClientPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientPlans.
     */
    skip?: number
    distinct?: ClientPlanScalarFieldEnum | ClientPlanScalarFieldEnum[]
  }

  /**
   * ClientPlan create
   */
  export type ClientPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientPlan.
     */
    data: XOR<ClientPlanCreateInput, ClientPlanUncheckedCreateInput>
  }

  /**
   * ClientPlan createMany
   */
  export type ClientPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientPlans.
     */
    data: ClientPlanCreateManyInput | ClientPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientPlan createManyAndReturn
   */
  export type ClientPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * The data used to create many ClientPlans.
     */
    data: ClientPlanCreateManyInput | ClientPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPlan update
   */
  export type ClientPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientPlan.
     */
    data: XOR<ClientPlanUpdateInput, ClientPlanUncheckedUpdateInput>
    /**
     * Choose, which ClientPlan to update.
     */
    where: ClientPlanWhereUniqueInput
  }

  /**
   * ClientPlan updateMany
   */
  export type ClientPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientPlans.
     */
    data: XOR<ClientPlanUpdateManyMutationInput, ClientPlanUncheckedUpdateManyInput>
    /**
     * Filter which ClientPlans to update
     */
    where?: ClientPlanWhereInput
    /**
     * Limit how many ClientPlans to update.
     */
    limit?: number
  }

  /**
   * ClientPlan updateManyAndReturn
   */
  export type ClientPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * The data used to update ClientPlans.
     */
    data: XOR<ClientPlanUpdateManyMutationInput, ClientPlanUncheckedUpdateManyInput>
    /**
     * Filter which ClientPlans to update
     */
    where?: ClientPlanWhereInput
    /**
     * Limit how many ClientPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientPlan upsert
   */
  export type ClientPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientPlan to update in case it exists.
     */
    where: ClientPlanWhereUniqueInput
    /**
     * In case the ClientPlan found by the `where` argument doesn't exist, create a new ClientPlan with this data.
     */
    create: XOR<ClientPlanCreateInput, ClientPlanUncheckedCreateInput>
    /**
     * In case the ClientPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientPlanUpdateInput, ClientPlanUncheckedUpdateInput>
  }

  /**
   * ClientPlan delete
   */
  export type ClientPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    /**
     * Filter which ClientPlan to delete.
     */
    where: ClientPlanWhereUniqueInput
  }

  /**
   * ClientPlan deleteMany
   */
  export type ClientPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientPlans to delete
     */
    where?: ClientPlanWhereInput
    /**
     * Limit how many ClientPlans to delete.
     */
    limit?: number
  }

  /**
   * ClientPlan.booking
   */
  export type ClientPlan$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * ClientPlan without action
   */
  export type ClientPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    barberId: string | null
    name: string | null
    price: number | null
    keyword: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    barberId: string | null
    name: string | null
    price: number | null
    keyword: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    barberId: number
    name: number
    price: number
    keyword: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    barberId?: true
    name?: true
    price?: true
    keyword?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    barberId?: true
    name?: true
    price?: true
    keyword?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    barberId?: true
    name?: true
    price?: true
    keyword?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    barberId: string
    name: string
    price: number
    keyword: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    name?: boolean
    price?: boolean
    keyword?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planToService?: boolean | Plan$planToServiceArgs<ExtArgs>
    clientPlans?: boolean | Plan$clientPlansArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    name?: boolean
    price?: boolean
    keyword?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    barberId?: boolean
    name?: boolean
    price?: boolean
    keyword?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    barberId?: boolean
    name?: boolean
    price?: boolean
    keyword?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "barberId" | "name" | "price" | "keyword" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planToService?: boolean | Plan$planToServiceArgs<ExtArgs>
    clientPlans?: boolean | Plan$clientPlansArgs<ExtArgs>
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    barber?: boolean | BarberProfileDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      planToService: Prisma.$PlanToServicePayload<ExtArgs>[]
      clientPlans: Prisma.$ClientPlanPayload<ExtArgs>[]
      barber: Prisma.$BarberProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      barberId: string
      name: string
      price: number
      keyword: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planToService<T extends Plan$planToServiceArgs<ExtArgs> = {}>(args?: Subset<T, Plan$planToServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientPlans<T extends Plan$clientPlansArgs<ExtArgs> = {}>(args?: Subset<T, Plan$clientPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    barber<T extends BarberProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BarberProfileDefaultArgs<ExtArgs>>): Prisma__BarberProfileClient<$Result.GetResult<Prisma.$BarberProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly barberId: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Int'>
    readonly keyword: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.planToService
   */
  export type Plan$planToServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    where?: PlanToServiceWhereInput
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    cursor?: PlanToServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanToServiceScalarFieldEnum | PlanToServiceScalarFieldEnum[]
  }

  /**
   * Plan.clientPlans
   */
  export type Plan$clientPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientPlan
     */
    select?: ClientPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientPlan
     */
    omit?: ClientPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientPlanInclude<ExtArgs> | null
    where?: ClientPlanWhereInput
    orderBy?: ClientPlanOrderByWithRelationInput | ClientPlanOrderByWithRelationInput[]
    cursor?: ClientPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientPlanScalarFieldEnum | ClientPlanScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanToService
   */

  export type AggregatePlanToService = {
    _count: PlanToServiceCountAggregateOutputType | null
    _min: PlanToServiceMinAggregateOutputType | null
    _max: PlanToServiceMaxAggregateOutputType | null
  }

  export type PlanToServiceMinAggregateOutputType = {
    planId: string | null
    serviceId: string | null
  }

  export type PlanToServiceMaxAggregateOutputType = {
    planId: string | null
    serviceId: string | null
  }

  export type PlanToServiceCountAggregateOutputType = {
    planId: number
    serviceId: number
    _all: number
  }


  export type PlanToServiceMinAggregateInputType = {
    planId?: true
    serviceId?: true
  }

  export type PlanToServiceMaxAggregateInputType = {
    planId?: true
    serviceId?: true
  }

  export type PlanToServiceCountAggregateInputType = {
    planId?: true
    serviceId?: true
    _all?: true
  }

  export type PlanToServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanToService to aggregate.
     */
    where?: PlanToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanToServices to fetch.
     */
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanToServices
    **/
    _count?: true | PlanToServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanToServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanToServiceMaxAggregateInputType
  }

  export type GetPlanToServiceAggregateType<T extends PlanToServiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanToService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanToService[P]>
      : GetScalarType<T[P], AggregatePlanToService[P]>
  }




  export type PlanToServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanToServiceWhereInput
    orderBy?: PlanToServiceOrderByWithAggregationInput | PlanToServiceOrderByWithAggregationInput[]
    by: PlanToServiceScalarFieldEnum[] | PlanToServiceScalarFieldEnum
    having?: PlanToServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanToServiceCountAggregateInputType | true
    _min?: PlanToServiceMinAggregateInputType
    _max?: PlanToServiceMaxAggregateInputType
  }

  export type PlanToServiceGroupByOutputType = {
    planId: string
    serviceId: string
    _count: PlanToServiceCountAggregateOutputType | null
    _min: PlanToServiceMinAggregateOutputType | null
    _max: PlanToServiceMaxAggregateOutputType | null
  }

  type GetPlanToServiceGroupByPayload<T extends PlanToServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanToServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanToServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanToServiceGroupByOutputType[P]>
            : GetScalarType<T[P], PlanToServiceGroupByOutputType[P]>
        }
      >
    >


  export type PlanToServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    planId?: boolean
    serviceId?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planToService"]>

  export type PlanToServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    planId?: boolean
    serviceId?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planToService"]>

  export type PlanToServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    planId?: boolean
    serviceId?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planToService"]>

  export type PlanToServiceSelectScalar = {
    planId?: boolean
    serviceId?: boolean
  }

  export type PlanToServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"planId" | "serviceId", ExtArgs["result"]["planToService"]>
  export type PlanToServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type PlanToServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type PlanToServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $PlanToServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanToService"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      planId: string
      serviceId: string
    }, ExtArgs["result"]["planToService"]>
    composites: {}
  }

  type PlanToServiceGetPayload<S extends boolean | null | undefined | PlanToServiceDefaultArgs> = $Result.GetResult<Prisma.$PlanToServicePayload, S>

  type PlanToServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanToServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanToServiceCountAggregateInputType | true
    }

  export interface PlanToServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanToService'], meta: { name: 'PlanToService' } }
    /**
     * Find zero or one PlanToService that matches the filter.
     * @param {PlanToServiceFindUniqueArgs} args - Arguments to find a PlanToService
     * @example
     * // Get one PlanToService
     * const planToService = await prisma.planToService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanToServiceFindUniqueArgs>(args: SelectSubset<T, PlanToServiceFindUniqueArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanToService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanToServiceFindUniqueOrThrowArgs} args - Arguments to find a PlanToService
     * @example
     * // Get one PlanToService
     * const planToService = await prisma.planToService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanToServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanToServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanToService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceFindFirstArgs} args - Arguments to find a PlanToService
     * @example
     * // Get one PlanToService
     * const planToService = await prisma.planToService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanToServiceFindFirstArgs>(args?: SelectSubset<T, PlanToServiceFindFirstArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanToService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceFindFirstOrThrowArgs} args - Arguments to find a PlanToService
     * @example
     * // Get one PlanToService
     * const planToService = await prisma.planToService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanToServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanToServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanToServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanToServices
     * const planToServices = await prisma.planToService.findMany()
     * 
     * // Get first 10 PlanToServices
     * const planToServices = await prisma.planToService.findMany({ take: 10 })
     * 
     * // Only select the `planId`
     * const planToServiceWithPlanIdOnly = await prisma.planToService.findMany({ select: { planId: true } })
     * 
     */
    findMany<T extends PlanToServiceFindManyArgs>(args?: SelectSubset<T, PlanToServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanToService.
     * @param {PlanToServiceCreateArgs} args - Arguments to create a PlanToService.
     * @example
     * // Create one PlanToService
     * const PlanToService = await prisma.planToService.create({
     *   data: {
     *     // ... data to create a PlanToService
     *   }
     * })
     * 
     */
    create<T extends PlanToServiceCreateArgs>(args: SelectSubset<T, PlanToServiceCreateArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanToServices.
     * @param {PlanToServiceCreateManyArgs} args - Arguments to create many PlanToServices.
     * @example
     * // Create many PlanToServices
     * const planToService = await prisma.planToService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanToServiceCreateManyArgs>(args?: SelectSubset<T, PlanToServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanToServices and returns the data saved in the database.
     * @param {PlanToServiceCreateManyAndReturnArgs} args - Arguments to create many PlanToServices.
     * @example
     * // Create many PlanToServices
     * const planToService = await prisma.planToService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanToServices and only return the `planId`
     * const planToServiceWithPlanIdOnly = await prisma.planToService.createManyAndReturn({
     *   select: { planId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanToServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanToServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanToService.
     * @param {PlanToServiceDeleteArgs} args - Arguments to delete one PlanToService.
     * @example
     * // Delete one PlanToService
     * const PlanToService = await prisma.planToService.delete({
     *   where: {
     *     // ... filter to delete one PlanToService
     *   }
     * })
     * 
     */
    delete<T extends PlanToServiceDeleteArgs>(args: SelectSubset<T, PlanToServiceDeleteArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanToService.
     * @param {PlanToServiceUpdateArgs} args - Arguments to update one PlanToService.
     * @example
     * // Update one PlanToService
     * const planToService = await prisma.planToService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanToServiceUpdateArgs>(args: SelectSubset<T, PlanToServiceUpdateArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanToServices.
     * @param {PlanToServiceDeleteManyArgs} args - Arguments to filter PlanToServices to delete.
     * @example
     * // Delete a few PlanToServices
     * const { count } = await prisma.planToService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanToServiceDeleteManyArgs>(args?: SelectSubset<T, PlanToServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanToServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanToServices
     * const planToService = await prisma.planToService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanToServiceUpdateManyArgs>(args: SelectSubset<T, PlanToServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanToServices and returns the data updated in the database.
     * @param {PlanToServiceUpdateManyAndReturnArgs} args - Arguments to update many PlanToServices.
     * @example
     * // Update many PlanToServices
     * const planToService = await prisma.planToService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanToServices and only return the `planId`
     * const planToServiceWithPlanIdOnly = await prisma.planToService.updateManyAndReturn({
     *   select: { planId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanToServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanToServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanToService.
     * @param {PlanToServiceUpsertArgs} args - Arguments to update or create a PlanToService.
     * @example
     * // Update or create a PlanToService
     * const planToService = await prisma.planToService.upsert({
     *   create: {
     *     // ... data to create a PlanToService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanToService we want to update
     *   }
     * })
     */
    upsert<T extends PlanToServiceUpsertArgs>(args: SelectSubset<T, PlanToServiceUpsertArgs<ExtArgs>>): Prisma__PlanToServiceClient<$Result.GetResult<Prisma.$PlanToServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanToServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceCountArgs} args - Arguments to filter PlanToServices to count.
     * @example
     * // Count the number of PlanToServices
     * const count = await prisma.planToService.count({
     *   where: {
     *     // ... the filter for the PlanToServices we want to count
     *   }
     * })
    **/
    count<T extends PlanToServiceCountArgs>(
      args?: Subset<T, PlanToServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanToServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanToService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanToServiceAggregateArgs>(args: Subset<T, PlanToServiceAggregateArgs>): Prisma.PrismaPromise<GetPlanToServiceAggregateType<T>>

    /**
     * Group by PlanToService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanToServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanToServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanToServiceGroupByArgs['orderBy'] }
        : { orderBy?: PlanToServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanToServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanToServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanToService model
   */
  readonly fields: PlanToServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanToService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanToServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanToService model
   */
  interface PlanToServiceFieldRefs {
    readonly planId: FieldRef<"PlanToService", 'String'>
    readonly serviceId: FieldRef<"PlanToService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlanToService findUnique
   */
  export type PlanToServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter, which PlanToService to fetch.
     */
    where: PlanToServiceWhereUniqueInput
  }

  /**
   * PlanToService findUniqueOrThrow
   */
  export type PlanToServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter, which PlanToService to fetch.
     */
    where: PlanToServiceWhereUniqueInput
  }

  /**
   * PlanToService findFirst
   */
  export type PlanToServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter, which PlanToService to fetch.
     */
    where?: PlanToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanToServices to fetch.
     */
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanToServices.
     */
    cursor?: PlanToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanToServices.
     */
    distinct?: PlanToServiceScalarFieldEnum | PlanToServiceScalarFieldEnum[]
  }

  /**
   * PlanToService findFirstOrThrow
   */
  export type PlanToServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter, which PlanToService to fetch.
     */
    where?: PlanToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanToServices to fetch.
     */
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanToServices.
     */
    cursor?: PlanToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanToServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanToServices.
     */
    distinct?: PlanToServiceScalarFieldEnum | PlanToServiceScalarFieldEnum[]
  }

  /**
   * PlanToService findMany
   */
  export type PlanToServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter, which PlanToServices to fetch.
     */
    where?: PlanToServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanToServices to fetch.
     */
    orderBy?: PlanToServiceOrderByWithRelationInput | PlanToServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanToServices.
     */
    cursor?: PlanToServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanToServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanToServices.
     */
    skip?: number
    distinct?: PlanToServiceScalarFieldEnum | PlanToServiceScalarFieldEnum[]
  }

  /**
   * PlanToService create
   */
  export type PlanToServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanToService.
     */
    data: XOR<PlanToServiceCreateInput, PlanToServiceUncheckedCreateInput>
  }

  /**
   * PlanToService createMany
   */
  export type PlanToServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanToServices.
     */
    data: PlanToServiceCreateManyInput | PlanToServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanToService createManyAndReturn
   */
  export type PlanToServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * The data used to create many PlanToServices.
     */
    data: PlanToServiceCreateManyInput | PlanToServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanToService update
   */
  export type PlanToServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanToService.
     */
    data: XOR<PlanToServiceUpdateInput, PlanToServiceUncheckedUpdateInput>
    /**
     * Choose, which PlanToService to update.
     */
    where: PlanToServiceWhereUniqueInput
  }

  /**
   * PlanToService updateMany
   */
  export type PlanToServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanToServices.
     */
    data: XOR<PlanToServiceUpdateManyMutationInput, PlanToServiceUncheckedUpdateManyInput>
    /**
     * Filter which PlanToServices to update
     */
    where?: PlanToServiceWhereInput
    /**
     * Limit how many PlanToServices to update.
     */
    limit?: number
  }

  /**
   * PlanToService updateManyAndReturn
   */
  export type PlanToServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * The data used to update PlanToServices.
     */
    data: XOR<PlanToServiceUpdateManyMutationInput, PlanToServiceUncheckedUpdateManyInput>
    /**
     * Filter which PlanToServices to update
     */
    where?: PlanToServiceWhereInput
    /**
     * Limit how many PlanToServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanToService upsert
   */
  export type PlanToServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanToService to update in case it exists.
     */
    where: PlanToServiceWhereUniqueInput
    /**
     * In case the PlanToService found by the `where` argument doesn't exist, create a new PlanToService with this data.
     */
    create: XOR<PlanToServiceCreateInput, PlanToServiceUncheckedCreateInput>
    /**
     * In case the PlanToService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanToServiceUpdateInput, PlanToServiceUncheckedUpdateInput>
  }

  /**
   * PlanToService delete
   */
  export type PlanToServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
    /**
     * Filter which PlanToService to delete.
     */
    where: PlanToServiceWhereUniqueInput
  }

  /**
   * PlanToService deleteMany
   */
  export type PlanToServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanToServices to delete
     */
    where?: PlanToServiceWhereInput
    /**
     * Limit how many PlanToServices to delete.
     */
    limit?: number
  }

  /**
   * PlanToService without action
   */
  export type PlanToServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanToService
     */
    select?: PlanToServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanToService
     */
    omit?: PlanToServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanToServiceInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dh: number
    auth: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    createdAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    createdAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent: string | null
    createdAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "endpoint" | "p256dh" | "auth" | "userAgent" | "createdAt", ExtArgs["result"]["pushSubscription"]>
  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PushSubscription$userArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      endpoint: string
      p256dh: string
      auth: string
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PushSubscription$userArgs<ExtArgs> = {}>(args?: Subset<T, PushSubscription$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly userAgent: FieldRef<"PushSubscription", 'String'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription.user
   */
  export type PushSubscription$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    phone: 'phone',
    createdAt: 'createdAt',
    role: 'role',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BarberProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    bio: 'bio',
    timeInterval: 'timeInterval',
    createdAt: 'createdAt'
  };

  export type BarberProfileScalarFieldEnum = (typeof BarberProfileScalarFieldEnum)[keyof typeof BarberProfileScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    keyword: 'keyword',
    imagePath: 'imagePath'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BarberProfileToServiceScalarFieldEnum: {
    barberProfileId: 'barberProfileId',
    serviceId: 'serviceId'
  };

  export type BarberProfileToServiceScalarFieldEnum = (typeof BarberProfileToServiceScalarFieldEnum)[keyof typeof BarberProfileToServiceScalarFieldEnum]


  export const BookingServiceScalarFieldEnum: {
    bookingId: 'bookingId',
    serviceId: 'serviceId'
  };

  export type BookingServiceScalarFieldEnum = (typeof BookingServiceScalarFieldEnum)[keyof typeof BookingServiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    date: 'date',
    status: 'status',
    userId: 'userId',
    planId: 'planId',
    barberId: 'barberId',
    totalPrice: 'totalPrice',
    totalDuration: 'totalDuration',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const DisabledDayScalarFieldEnum: {
    id: 'id',
    barberId: 'barberId',
    date: 'date',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type DisabledDayScalarFieldEnum = (typeof DisabledDayScalarFieldEnum)[keyof typeof DisabledDayScalarFieldEnum]


  export const DisabledTimeScalarFieldEnum: {
    id: 'id',
    date: 'date',
    barberId: 'barberId',
    createdAt: 'createdAt'
  };

  export type DisabledTimeScalarFieldEnum = (typeof DisabledTimeScalarFieldEnum)[keyof typeof DisabledTimeScalarFieldEnum]


  export const ExtraTimeDayScalarFieldEnum: {
    id: 'id',
    date: 'date',
    barberId: 'barberId',
    amount: 'amount',
    createdAT: 'createdAT'
  };

  export type ExtraTimeDayScalarFieldEnum = (typeof ExtraTimeDayScalarFieldEnum)[keyof typeof ExtraTimeDayScalarFieldEnum]


  export const PointSystemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentPoints: 'currentPoints',
    pointsPerService: 'pointsPerService',
    pointsNeededForReward: 'pointsNeededForReward',
    discountPercentage: 'discountPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PointSystemScalarFieldEnum = (typeof PointSystemScalarFieldEnum)[keyof typeof PointSystemScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    pointSystemId: 'pointSystemId',
    discountPercent: 'discountPercent',
    isUsed: 'isUsed',
    usedAt: 'usedAt',
    bookingId: 'bookingId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const PointTransactionScalarFieldEnum: {
    id: 'id',
    pointSystemId: 'pointSystemId',
    points: 'points',
    type: 'type',
    description: 'description',
    bookingId: 'bookingId',
    createdAt: 'createdAt',
    status: 'status',
    confirmedAt: 'confirmedAt',
    confirmedBy: 'confirmedBy'
  };

  export type PointTransactionScalarFieldEnum = (typeof PointTransactionScalarFieldEnum)[keyof typeof PointTransactionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    recipientType: 'recipientType',
    barberId: 'barberId',
    userId: 'userId',
    bookingId: 'bookingId',
    couponId: 'couponId',
    transactionId: 'transactionId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ClientPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    barberId: 'barberId',
    planId: 'planId',
    useAmount: 'useAmount',
    starts: 'starts',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientPlanScalarFieldEnum = (typeof ClientPlanScalarFieldEnum)[keyof typeof ClientPlanScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    barberId: 'barberId',
    name: 'name',
    price: 'price',
    keyword: 'keyword',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanToServiceScalarFieldEnum: {
    planId: 'planId',
    serviceId: 'serviceId'
  };

  export type PlanToServiceScalarFieldEnum = (typeof PlanToServiceScalarFieldEnum)[keyof typeof PlanToServiceScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationRecipient'
   */
  export type EnumNotificationRecipientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationRecipient'>
    


  /**
   * Reference to a field of type 'NotificationRecipient[]'
   */
  export type ListEnumNotificationRecipientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationRecipient[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    barberProfile?: XOR<BarberProfileNullableScalarRelationFilter, BarberProfileWhereInput> | null
    bookings?: BookingListRelationFilter
    sessions?: SessionListRelationFilter
    pointSystem?: XOR<PointSystemNullableScalarRelationFilter, PointSystemWhereInput> | null
    plan?: XOR<ClientPlanNullableScalarRelationFilter, ClientPlanWhereInput> | null
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    barberProfile?: BarberProfileOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    pointSystem?: PointSystemOrderByWithRelationInput
    plan?: ClientPlanOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    barberProfile?: XOR<BarberProfileNullableScalarRelationFilter, BarberProfileWhereInput> | null
    bookings?: BookingListRelationFilter
    sessions?: SessionListRelationFilter
    pointSystem?: XOR<PointSystemNullableScalarRelationFilter, PointSystemWhereInput> | null
    plan?: XOR<ClientPlanNullableScalarRelationFilter, ClientPlanWhereInput> | null
    notifications?: NotificationListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BarberProfileWhereInput = {
    AND?: BarberProfileWhereInput | BarberProfileWhereInput[]
    OR?: BarberProfileWhereInput[]
    NOT?: BarberProfileWhereInput | BarberProfileWhereInput[]
    id?: StringFilter<"BarberProfile"> | string
    userId?: StringFilter<"BarberProfile"> | string
    displayName?: StringFilter<"BarberProfile"> | string
    bio?: StringNullableFilter<"BarberProfile"> | string | null
    timeInterval?: IntFilter<"BarberProfile"> | number
    createdAt?: DateTimeFilter<"BarberProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    services?: BarberProfileToServiceListRelationFilter
    disabledDays?: DisabledDayListRelationFilter
    clientPlans?: ClientPlanListRelationFilter
    plans?: PlanListRelationFilter
    extraTimeDays?: ExtraTimeDayListRelationFilter
    disabledTimes?: DisabledTimeListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type BarberProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrderInput | SortOrder
    timeInterval?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    services?: BarberProfileToServiceOrderByRelationAggregateInput
    disabledDays?: DisabledDayOrderByRelationAggregateInput
    clientPlans?: ClientPlanOrderByRelationAggregateInput
    plans?: PlanOrderByRelationAggregateInput
    extraTimeDays?: ExtraTimeDayOrderByRelationAggregateInput
    disabledTimes?: DisabledTimeOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type BarberProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: BarberProfileWhereInput | BarberProfileWhereInput[]
    OR?: BarberProfileWhereInput[]
    NOT?: BarberProfileWhereInput | BarberProfileWhereInput[]
    displayName?: StringFilter<"BarberProfile"> | string
    bio?: StringNullableFilter<"BarberProfile"> | string | null
    timeInterval?: IntFilter<"BarberProfile"> | number
    createdAt?: DateTimeFilter<"BarberProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    services?: BarberProfileToServiceListRelationFilter
    disabledDays?: DisabledDayListRelationFilter
    clientPlans?: ClientPlanListRelationFilter
    plans?: PlanListRelationFilter
    extraTimeDays?: ExtraTimeDayListRelationFilter
    disabledTimes?: DisabledTimeListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "userId">

  export type BarberProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrderInput | SortOrder
    timeInterval?: SortOrder
    createdAt?: SortOrder
    _count?: BarberProfileCountOrderByAggregateInput
    _avg?: BarberProfileAvgOrderByAggregateInput
    _max?: BarberProfileMaxOrderByAggregateInput
    _min?: BarberProfileMinOrderByAggregateInput
    _sum?: BarberProfileSumOrderByAggregateInput
  }

  export type BarberProfileScalarWhereWithAggregatesInput = {
    AND?: BarberProfileScalarWhereWithAggregatesInput | BarberProfileScalarWhereWithAggregatesInput[]
    OR?: BarberProfileScalarWhereWithAggregatesInput[]
    NOT?: BarberProfileScalarWhereWithAggregatesInput | BarberProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BarberProfile"> | string
    userId?: StringWithAggregatesFilter<"BarberProfile"> | string
    displayName?: StringWithAggregatesFilter<"BarberProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"BarberProfile"> | string | null
    timeInterval?: IntWithAggregatesFilter<"BarberProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BarberProfile"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    price?: IntFilter<"Service"> | number
    duration?: IntFilter<"Service"> | number
    keyword?: StringFilter<"Service"> | string
    imagePath?: StringFilter<"Service"> | string
    bookings?: BookingServiceListRelationFilter
    barbers?: BarberProfileToServiceListRelationFilter
    planToService?: PlanToServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    keyword?: SortOrder
    imagePath?: SortOrder
    bookings?: BookingServiceOrderByRelationAggregateInput
    barbers?: BarberProfileToServiceOrderByRelationAggregateInput
    planToService?: PlanToServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyword?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    price?: IntFilter<"Service"> | number
    duration?: IntFilter<"Service"> | number
    imagePath?: StringFilter<"Service"> | string
    bookings?: BookingServiceListRelationFilter
    barbers?: BarberProfileToServiceListRelationFilter
    planToService?: PlanToServiceListRelationFilter
  }, "id" | "keyword">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    keyword?: SortOrder
    imagePath?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    price?: IntWithAggregatesFilter<"Service"> | number
    duration?: IntWithAggregatesFilter<"Service"> | number
    keyword?: StringWithAggregatesFilter<"Service"> | string
    imagePath?: StringWithAggregatesFilter<"Service"> | string
  }

  export type BarberProfileToServiceWhereInput = {
    AND?: BarberProfileToServiceWhereInput | BarberProfileToServiceWhereInput[]
    OR?: BarberProfileToServiceWhereInput[]
    NOT?: BarberProfileToServiceWhereInput | BarberProfileToServiceWhereInput[]
    barberProfileId?: StringFilter<"BarberProfileToService"> | string
    serviceId?: StringFilter<"BarberProfileToService"> | string
    barberProfile?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type BarberProfileToServiceOrderByWithRelationInput = {
    barberProfileId?: SortOrder
    serviceId?: SortOrder
    barberProfile?: BarberProfileOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BarberProfileToServiceWhereUniqueInput = Prisma.AtLeast<{
    barberProfileId_serviceId?: BarberProfileToServiceBarberProfileIdServiceIdCompoundUniqueInput
    AND?: BarberProfileToServiceWhereInput | BarberProfileToServiceWhereInput[]
    OR?: BarberProfileToServiceWhereInput[]
    NOT?: BarberProfileToServiceWhereInput | BarberProfileToServiceWhereInput[]
    barberProfileId?: StringFilter<"BarberProfileToService"> | string
    serviceId?: StringFilter<"BarberProfileToService"> | string
    barberProfile?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "barberProfileId_serviceId">

  export type BarberProfileToServiceOrderByWithAggregationInput = {
    barberProfileId?: SortOrder
    serviceId?: SortOrder
    _count?: BarberProfileToServiceCountOrderByAggregateInput
    _max?: BarberProfileToServiceMaxOrderByAggregateInput
    _min?: BarberProfileToServiceMinOrderByAggregateInput
  }

  export type BarberProfileToServiceScalarWhereWithAggregatesInput = {
    AND?: BarberProfileToServiceScalarWhereWithAggregatesInput | BarberProfileToServiceScalarWhereWithAggregatesInput[]
    OR?: BarberProfileToServiceScalarWhereWithAggregatesInput[]
    NOT?: BarberProfileToServiceScalarWhereWithAggregatesInput | BarberProfileToServiceScalarWhereWithAggregatesInput[]
    barberProfileId?: StringWithAggregatesFilter<"BarberProfileToService"> | string
    serviceId?: StringWithAggregatesFilter<"BarberProfileToService"> | string
  }

  export type BookingServiceWhereInput = {
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    bookingId?: StringFilter<"BookingService"> | string
    serviceId?: StringFilter<"BookingService"> | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type BookingServiceOrderByWithRelationInput = {
    bookingId?: SortOrder
    serviceId?: SortOrder
    booking?: BookingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BookingServiceWhereUniqueInput = Prisma.AtLeast<{
    bookingId_serviceId?: BookingServiceBookingIdServiceIdCompoundUniqueInput
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    bookingId?: StringFilter<"BookingService"> | string
    serviceId?: StringFilter<"BookingService"> | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "bookingId_serviceId">

  export type BookingServiceOrderByWithAggregationInput = {
    bookingId?: SortOrder
    serviceId?: SortOrder
    _count?: BookingServiceCountOrderByAggregateInput
    _max?: BookingServiceMaxOrderByAggregateInput
    _min?: BookingServiceMinOrderByAggregateInput
  }

  export type BookingServiceScalarWhereWithAggregatesInput = {
    AND?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    OR?: BookingServiceScalarWhereWithAggregatesInput[]
    NOT?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    bookingId?: StringWithAggregatesFilter<"BookingService"> | string
    serviceId?: StringWithAggregatesFilter<"BookingService"> | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    userId?: StringFilter<"Booking"> | string
    planId?: StringNullableFilter<"Booking"> | string | null
    barberId?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    totalDuration?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<ClientPlanNullableScalarRelationFilter, ClientPlanWhereInput> | null
    services?: BookingServiceListRelationFilter
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrderInput | SortOrder
    barberId?: SortOrder
    totalPrice?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    barber?: BarberProfileOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    plan?: ClientPlanOrderByWithRelationInput
    services?: BookingServiceOrderByRelationAggregateInput
    coupon?: CouponOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    date?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    userId?: StringFilter<"Booking"> | string
    planId?: StringNullableFilter<"Booking"> | string | null
    barberId?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    totalDuration?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<ClientPlanNullableScalarRelationFilter, ClientPlanWhereInput> | null
    services?: BookingServiceListRelationFilter
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrderInput | SortOrder
    barberId?: SortOrder
    totalPrice?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    date?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    userId?: StringWithAggregatesFilter<"Booking"> | string
    planId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    barberId?: StringWithAggregatesFilter<"Booking"> | string
    totalPrice?: IntWithAggregatesFilter<"Booking"> | number
    totalDuration?: IntWithAggregatesFilter<"Booking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type DisabledDayWhereInput = {
    AND?: DisabledDayWhereInput | DisabledDayWhereInput[]
    OR?: DisabledDayWhereInput[]
    NOT?: DisabledDayWhereInput | DisabledDayWhereInput[]
    id?: StringFilter<"DisabledDay"> | string
    barberId?: StringFilter<"DisabledDay"> | string
    date?: DateTimeFilter<"DisabledDay"> | Date | string
    reason?: StringNullableFilter<"DisabledDay"> | string | null
    createdAt?: DateTimeFilter<"DisabledDay"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }

  export type DisabledDayOrderByWithRelationInput = {
    id?: SortOrder
    barberId?: SortOrder
    date?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    barber?: BarberProfileOrderByWithRelationInput
  }

  export type DisabledDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barberId_date?: DisabledDayBarberIdDateCompoundUniqueInput
    AND?: DisabledDayWhereInput | DisabledDayWhereInput[]
    OR?: DisabledDayWhereInput[]
    NOT?: DisabledDayWhereInput | DisabledDayWhereInput[]
    barberId?: StringFilter<"DisabledDay"> | string
    date?: DateTimeFilter<"DisabledDay"> | Date | string
    reason?: StringNullableFilter<"DisabledDay"> | string | null
    createdAt?: DateTimeFilter<"DisabledDay"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }, "id" | "barberId_date">

  export type DisabledDayOrderByWithAggregationInput = {
    id?: SortOrder
    barberId?: SortOrder
    date?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DisabledDayCountOrderByAggregateInput
    _max?: DisabledDayMaxOrderByAggregateInput
    _min?: DisabledDayMinOrderByAggregateInput
  }

  export type DisabledDayScalarWhereWithAggregatesInput = {
    AND?: DisabledDayScalarWhereWithAggregatesInput | DisabledDayScalarWhereWithAggregatesInput[]
    OR?: DisabledDayScalarWhereWithAggregatesInput[]
    NOT?: DisabledDayScalarWhereWithAggregatesInput | DisabledDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisabledDay"> | string
    barberId?: StringWithAggregatesFilter<"DisabledDay"> | string
    date?: DateTimeWithAggregatesFilter<"DisabledDay"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"DisabledDay"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DisabledDay"> | Date | string
  }

  export type DisabledTimeWhereInput = {
    AND?: DisabledTimeWhereInput | DisabledTimeWhereInput[]
    OR?: DisabledTimeWhereInput[]
    NOT?: DisabledTimeWhereInput | DisabledTimeWhereInput[]
    id?: StringFilter<"DisabledTime"> | string
    date?: DateTimeFilter<"DisabledTime"> | Date | string
    barberId?: StringFilter<"DisabledTime"> | string
    createdAt?: DateTimeFilter<"DisabledTime"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }

  export type DisabledTimeOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    createdAt?: SortOrder
    barber?: BarberProfileOrderByWithRelationInput
  }

  export type DisabledTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barberId_date?: DisabledTimeBarberIdDateCompoundUniqueInput
    AND?: DisabledTimeWhereInput | DisabledTimeWhereInput[]
    OR?: DisabledTimeWhereInput[]
    NOT?: DisabledTimeWhereInput | DisabledTimeWhereInput[]
    date?: DateTimeFilter<"DisabledTime"> | Date | string
    barberId?: StringFilter<"DisabledTime"> | string
    createdAt?: DateTimeFilter<"DisabledTime"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }, "id" | "barberId_date">

  export type DisabledTimeOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    createdAt?: SortOrder
    _count?: DisabledTimeCountOrderByAggregateInput
    _max?: DisabledTimeMaxOrderByAggregateInput
    _min?: DisabledTimeMinOrderByAggregateInput
  }

  export type DisabledTimeScalarWhereWithAggregatesInput = {
    AND?: DisabledTimeScalarWhereWithAggregatesInput | DisabledTimeScalarWhereWithAggregatesInput[]
    OR?: DisabledTimeScalarWhereWithAggregatesInput[]
    NOT?: DisabledTimeScalarWhereWithAggregatesInput | DisabledTimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisabledTime"> | string
    date?: DateTimeWithAggregatesFilter<"DisabledTime"> | Date | string
    barberId?: StringWithAggregatesFilter<"DisabledTime"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DisabledTime"> | Date | string
  }

  export type ExtraTimeDayWhereInput = {
    AND?: ExtraTimeDayWhereInput | ExtraTimeDayWhereInput[]
    OR?: ExtraTimeDayWhereInput[]
    NOT?: ExtraTimeDayWhereInput | ExtraTimeDayWhereInput[]
    id?: StringFilter<"ExtraTimeDay"> | string
    date?: DateTimeFilter<"ExtraTimeDay"> | Date | string
    barberId?: StringFilter<"ExtraTimeDay"> | string
    amount?: IntFilter<"ExtraTimeDay"> | number
    createdAT?: DateTimeFilter<"ExtraTimeDay"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }

  export type ExtraTimeDayOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    amount?: SortOrder
    createdAT?: SortOrder
    barber?: BarberProfileOrderByWithRelationInput
  }

  export type ExtraTimeDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barberId_date?: ExtraTimeDayBarberIdDateCompoundUniqueInput
    AND?: ExtraTimeDayWhereInput | ExtraTimeDayWhereInput[]
    OR?: ExtraTimeDayWhereInput[]
    NOT?: ExtraTimeDayWhereInput | ExtraTimeDayWhereInput[]
    date?: DateTimeFilter<"ExtraTimeDay"> | Date | string
    barberId?: StringFilter<"ExtraTimeDay"> | string
    amount?: IntFilter<"ExtraTimeDay"> | number
    createdAT?: DateTimeFilter<"ExtraTimeDay"> | Date | string
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }, "id" | "barberId_date">

  export type ExtraTimeDayOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    amount?: SortOrder
    createdAT?: SortOrder
    _count?: ExtraTimeDayCountOrderByAggregateInput
    _avg?: ExtraTimeDayAvgOrderByAggregateInput
    _max?: ExtraTimeDayMaxOrderByAggregateInput
    _min?: ExtraTimeDayMinOrderByAggregateInput
    _sum?: ExtraTimeDaySumOrderByAggregateInput
  }

  export type ExtraTimeDayScalarWhereWithAggregatesInput = {
    AND?: ExtraTimeDayScalarWhereWithAggregatesInput | ExtraTimeDayScalarWhereWithAggregatesInput[]
    OR?: ExtraTimeDayScalarWhereWithAggregatesInput[]
    NOT?: ExtraTimeDayScalarWhereWithAggregatesInput | ExtraTimeDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtraTimeDay"> | string
    date?: DateTimeWithAggregatesFilter<"ExtraTimeDay"> | Date | string
    barberId?: StringWithAggregatesFilter<"ExtraTimeDay"> | string
    amount?: IntWithAggregatesFilter<"ExtraTimeDay"> | number
    createdAT?: DateTimeWithAggregatesFilter<"ExtraTimeDay"> | Date | string
  }

  export type PointSystemWhereInput = {
    AND?: PointSystemWhereInput | PointSystemWhereInput[]
    OR?: PointSystemWhereInput[]
    NOT?: PointSystemWhereInput | PointSystemWhereInput[]
    id?: StringFilter<"PointSystem"> | string
    userId?: StringFilter<"PointSystem"> | string
    currentPoints?: IntFilter<"PointSystem"> | number
    pointsPerService?: IntFilter<"PointSystem"> | number
    pointsNeededForReward?: IntFilter<"PointSystem"> | number
    discountPercentage?: IntFilter<"PointSystem"> | number
    createdAt?: DateTimeFilter<"PointSystem"> | Date | string
    updatedAt?: DateTimeFilter<"PointSystem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupons?: CouponListRelationFilter
    pointTransactions?: PointTransactionListRelationFilter
  }

  export type PointSystemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coupons?: CouponOrderByRelationAggregateInput
    pointTransactions?: PointTransactionOrderByRelationAggregateInput
  }

  export type PointSystemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PointSystemWhereInput | PointSystemWhereInput[]
    OR?: PointSystemWhereInput[]
    NOT?: PointSystemWhereInput | PointSystemWhereInput[]
    currentPoints?: IntFilter<"PointSystem"> | number
    pointsPerService?: IntFilter<"PointSystem"> | number
    pointsNeededForReward?: IntFilter<"PointSystem"> | number
    discountPercentage?: IntFilter<"PointSystem"> | number
    createdAt?: DateTimeFilter<"PointSystem"> | Date | string
    updatedAt?: DateTimeFilter<"PointSystem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coupons?: CouponListRelationFilter
    pointTransactions?: PointTransactionListRelationFilter
  }, "id" | "userId">

  export type PointSystemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PointSystemCountOrderByAggregateInput
    _avg?: PointSystemAvgOrderByAggregateInput
    _max?: PointSystemMaxOrderByAggregateInput
    _min?: PointSystemMinOrderByAggregateInput
    _sum?: PointSystemSumOrderByAggregateInput
  }

  export type PointSystemScalarWhereWithAggregatesInput = {
    AND?: PointSystemScalarWhereWithAggregatesInput | PointSystemScalarWhereWithAggregatesInput[]
    OR?: PointSystemScalarWhereWithAggregatesInput[]
    NOT?: PointSystemScalarWhereWithAggregatesInput | PointSystemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointSystem"> | string
    userId?: StringWithAggregatesFilter<"PointSystem"> | string
    currentPoints?: IntWithAggregatesFilter<"PointSystem"> | number
    pointsPerService?: IntWithAggregatesFilter<"PointSystem"> | number
    pointsNeededForReward?: IntWithAggregatesFilter<"PointSystem"> | number
    discountPercentage?: IntWithAggregatesFilter<"PointSystem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PointSystem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PointSystem"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    pointSystemId?: StringFilter<"Coupon"> | string
    discountPercent?: IntFilter<"Coupon"> | number
    isUsed?: BoolFilter<"Coupon"> | boolean
    usedAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    bookingId?: StringNullableFilter<"Coupon"> | string | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    pointSystem?: XOR<PointSystemScalarRelationFilter, PointSystemWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    notifications?: NotificationListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    discountPercent?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    pointSystem?: PointSystemOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    pointSystemId?: StringFilter<"Coupon"> | string
    discountPercent?: IntFilter<"Coupon"> | number
    isUsed?: BoolFilter<"Coupon"> | boolean
    usedAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    pointSystem?: XOR<PointSystemScalarRelationFilter, PointSystemWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    notifications?: NotificationListRelationFilter
  }, "id" | "bookingId">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    discountPercent?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    pointSystemId?: StringWithAggregatesFilter<"Coupon"> | string
    discountPercent?: IntWithAggregatesFilter<"Coupon"> | number
    isUsed?: BoolWithAggregatesFilter<"Coupon"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    bookingId?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
  }

  export type PointTransactionWhereInput = {
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    pointSystemId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"PointTransaction"> | string | null
    bookingId?: StringNullableFilter<"PointTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
    status?: EnumTransactionStatusFilter<"PointTransaction"> | $Enums.TransactionStatus
    confirmedAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    confirmedBy?: StringNullableFilter<"PointTransaction"> | string | null
    pointSystem?: XOR<PointSystemScalarRelationFilter, PointSystemWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type PointTransactionOrderByWithRelationInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    pointSystem?: PointSystemOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PointTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointTransactionWhereInput | PointTransactionWhereInput[]
    OR?: PointTransactionWhereInput[]
    NOT?: PointTransactionWhereInput | PointTransactionWhereInput[]
    pointSystemId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"PointTransaction"> | string | null
    bookingId?: StringNullableFilter<"PointTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
    status?: EnumTransactionStatusFilter<"PointTransaction"> | $Enums.TransactionStatus
    confirmedAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    confirmedBy?: StringNullableFilter<"PointTransaction"> | string | null
    pointSystem?: XOR<PointSystemScalarRelationFilter, PointSystemWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PointTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    confirmedBy?: SortOrderInput | SortOrder
    _count?: PointTransactionCountOrderByAggregateInput
    _avg?: PointTransactionAvgOrderByAggregateInput
    _max?: PointTransactionMaxOrderByAggregateInput
    _min?: PointTransactionMinOrderByAggregateInput
    _sum?: PointTransactionSumOrderByAggregateInput
  }

  export type PointTransactionScalarWhereWithAggregatesInput = {
    AND?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    OR?: PointTransactionScalarWhereWithAggregatesInput[]
    NOT?: PointTransactionScalarWhereWithAggregatesInput | PointTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointTransaction"> | string
    pointSystemId?: StringWithAggregatesFilter<"PointTransaction"> | string
    points?: IntWithAggregatesFilter<"PointTransaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"PointTransaction"> | $Enums.TransactionType
    description?: StringNullableWithAggregatesFilter<"PointTransaction"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"PointTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PointTransaction"> | Date | string
    status?: EnumTransactionStatusWithAggregatesFilter<"PointTransaction"> | $Enums.TransactionStatus
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"PointTransaction"> | Date | string | null
    confirmedBy?: StringNullableWithAggregatesFilter<"PointTransaction"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    recipientType?: EnumNotificationRecipientFilter<"Notification"> | $Enums.NotificationRecipient
    barberId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringNullableFilter<"Notification"> | string | null
    bookingId?: StringNullableFilter<"Notification"> | string | null
    couponId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    metadata?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
    transaction?: XOR<PointTransactionNullableScalarRelationFilter, PointTransactionWhereInput> | null
    barber?: XOR<BarberProfileNullableScalarRelationFilter, BarberProfileWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    recipientType?: SortOrder
    barberId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
    transaction?: PointTransactionOrderByWithRelationInput
    barber?: BarberProfileOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    recipientType?: EnumNotificationRecipientFilter<"Notification"> | $Enums.NotificationRecipient
    barberId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringNullableFilter<"Notification"> | string | null
    bookingId?: StringNullableFilter<"Notification"> | string | null
    couponId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    metadata?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
    transaction?: XOR<PointTransactionNullableScalarRelationFilter, PointTransactionWhereInput> | null
    barber?: XOR<BarberProfileNullableScalarRelationFilter, BarberProfileWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    recipientType?: SortOrder
    barberId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    recipientType?: EnumNotificationRecipientWithAggregatesFilter<"Notification"> | $Enums.NotificationRecipient
    barberId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    couponId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ClientPlanWhereInput = {
    AND?: ClientPlanWhereInput | ClientPlanWhereInput[]
    OR?: ClientPlanWhereInput[]
    NOT?: ClientPlanWhereInput | ClientPlanWhereInput[]
    id?: StringFilter<"ClientPlan"> | string
    userId?: StringFilter<"ClientPlan"> | string
    barberId?: StringFilter<"ClientPlan"> | string
    planId?: StringFilter<"ClientPlan"> | string
    useAmount?: IntFilter<"ClientPlan"> | number
    starts?: DateTimeFilter<"ClientPlan"> | Date | string
    expires?: DateTimeFilter<"ClientPlan"> | Date | string
    createdAt?: DateTimeFilter<"ClientPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    booking?: BookingListRelationFilter
  }

  export type ClientPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    barberId?: SortOrder
    planId?: SortOrder
    useAmount?: SortOrder
    starts?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    barber?: BarberProfileOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    booking?: BookingOrderByRelationAggregateInput
  }

  export type ClientPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    userId_barberId?: ClientPlanUserIdBarberIdCompoundUniqueInput
    AND?: ClientPlanWhereInput | ClientPlanWhereInput[]
    OR?: ClientPlanWhereInput[]
    NOT?: ClientPlanWhereInput | ClientPlanWhereInput[]
    barberId?: StringFilter<"ClientPlan"> | string
    planId?: StringFilter<"ClientPlan"> | string
    useAmount?: IntFilter<"ClientPlan"> | number
    starts?: DateTimeFilter<"ClientPlan"> | Date | string
    expires?: DateTimeFilter<"ClientPlan"> | Date | string
    createdAt?: DateTimeFilter<"ClientPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    booking?: BookingListRelationFilter
  }, "id" | "userId" | "userId_barberId">

  export type ClientPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    barberId?: SortOrder
    planId?: SortOrder
    useAmount?: SortOrder
    starts?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientPlanCountOrderByAggregateInput
    _avg?: ClientPlanAvgOrderByAggregateInput
    _max?: ClientPlanMaxOrderByAggregateInput
    _min?: ClientPlanMinOrderByAggregateInput
    _sum?: ClientPlanSumOrderByAggregateInput
  }

  export type ClientPlanScalarWhereWithAggregatesInput = {
    AND?: ClientPlanScalarWhereWithAggregatesInput | ClientPlanScalarWhereWithAggregatesInput[]
    OR?: ClientPlanScalarWhereWithAggregatesInput[]
    NOT?: ClientPlanScalarWhereWithAggregatesInput | ClientPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientPlan"> | string
    userId?: StringWithAggregatesFilter<"ClientPlan"> | string
    barberId?: StringWithAggregatesFilter<"ClientPlan"> | string
    planId?: StringWithAggregatesFilter<"ClientPlan"> | string
    useAmount?: IntWithAggregatesFilter<"ClientPlan"> | number
    starts?: DateTimeWithAggregatesFilter<"ClientPlan"> | Date | string
    expires?: DateTimeWithAggregatesFilter<"ClientPlan"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientPlan"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    barberId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: IntFilter<"Plan"> | number
    keyword?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    planToService?: PlanToServiceListRelationFilter
    clientPlans?: ClientPlanListRelationFilter
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    barberId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    keyword?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planToService?: PlanToServiceOrderByRelationAggregateInput
    clientPlans?: ClientPlanOrderByRelationAggregateInput
    barber?: BarberProfileOrderByWithRelationInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    barberId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: IntFilter<"Plan"> | number
    keyword?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    planToService?: PlanToServiceListRelationFilter
    clientPlans?: ClientPlanListRelationFilter
    barber?: XOR<BarberProfileScalarRelationFilter, BarberProfileWhereInput>
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    barberId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    keyword?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    barberId?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    price?: IntWithAggregatesFilter<"Plan"> | number
    keyword?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PlanToServiceWhereInput = {
    AND?: PlanToServiceWhereInput | PlanToServiceWhereInput[]
    OR?: PlanToServiceWhereInput[]
    NOT?: PlanToServiceWhereInput | PlanToServiceWhereInput[]
    planId?: StringFilter<"PlanToService"> | string
    serviceId?: StringFilter<"PlanToService"> | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type PlanToServiceOrderByWithRelationInput = {
    planId?: SortOrder
    serviceId?: SortOrder
    plan?: PlanOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type PlanToServiceWhereUniqueInput = Prisma.AtLeast<{
    planId_serviceId?: PlanToServicePlanIdServiceIdCompoundUniqueInput
    AND?: PlanToServiceWhereInput | PlanToServiceWhereInput[]
    OR?: PlanToServiceWhereInput[]
    NOT?: PlanToServiceWhereInput | PlanToServiceWhereInput[]
    planId?: StringFilter<"PlanToService"> | string
    serviceId?: StringFilter<"PlanToService"> | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "planId_serviceId">

  export type PlanToServiceOrderByWithAggregationInput = {
    planId?: SortOrder
    serviceId?: SortOrder
    _count?: PlanToServiceCountOrderByAggregateInput
    _max?: PlanToServiceMaxOrderByAggregateInput
    _min?: PlanToServiceMinOrderByAggregateInput
  }

  export type PlanToServiceScalarWhereWithAggregatesInput = {
    AND?: PlanToServiceScalarWhereWithAggregatesInput | PlanToServiceScalarWhereWithAggregatesInput[]
    OR?: PlanToServiceScalarWhereWithAggregatesInput[]
    NOT?: PlanToServiceScalarWhereWithAggregatesInput | PlanToServiceScalarWhereWithAggregatesInput[]
    planId?: StringWithAggregatesFilter<"PlanToService"> | string
    serviceId?: StringWithAggregatesFilter<"PlanToService"> | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringNullableFilter<"PushSubscription"> | string | null
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    endpoint?: string
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: StringNullableFilter<"PushSubscription"> | string | null
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarberProfileCreateInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileCreateManyInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
  }

  export type BarberProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarberProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceCreateNestedManyWithoutServiceInput
    barbers?: BarberProfileToServiceCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
    barbers?: BarberProfileToServiceUncheckedCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUpdateManyWithoutServiceNestedInput
    barbers?: BarberProfileToServiceUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
    barbers?: BarberProfileToServiceUncheckedUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
  }

  export type BarberProfileToServiceCreateInput = {
    barberProfile: BarberProfileCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutBarbersInput
  }

  export type BarberProfileToServiceUncheckedCreateInput = {
    barberProfileId: string
    serviceId: string
  }

  export type BarberProfileToServiceUpdateInput = {
    barberProfile?: BarberProfileUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutBarbersNestedInput
  }

  export type BarberProfileToServiceUncheckedUpdateInput = {
    barberProfileId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BarberProfileToServiceCreateManyInput = {
    barberProfileId: string
    serviceId: string
  }

  export type BarberProfileToServiceUpdateManyMutationInput = {

  }

  export type BarberProfileToServiceUncheckedUpdateManyInput = {
    barberProfileId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingServiceCreateInput = {
    booking: BookingCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingServiceUncheckedCreateInput = {
    bookingId: string
    serviceId: string
  }

  export type BookingServiceUpdateInput = {
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingServiceUncheckedUpdateInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingServiceCreateManyInput = {
    bookingId: string
    serviceId: string
  }

  export type BookingServiceUpdateManyMutationInput = {

  }

  export type BookingServiceUncheckedUpdateManyInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledDayCreateInput = {
    id?: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutDisabledDaysInput
  }

  export type DisabledDayUncheckedCreateInput = {
    id?: string
    barberId: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type DisabledDayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutDisabledDaysNestedInput
  }

  export type DisabledDayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledDayCreateManyInput = {
    id?: string
    barberId: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type DisabledDayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledDayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutDisabledTimesInput
  }

  export type DisabledTimeUncheckedCreateInput = {
    id?: string
    date: Date | string
    barberId: string
    createdAt?: Date | string
  }

  export type DisabledTimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutDisabledTimesNestedInput
  }

  export type DisabledTimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    barberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeCreateManyInput = {
    id?: string
    date: Date | string
    barberId: string
    createdAt?: Date | string
  }

  export type DisabledTimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    barberId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayCreateInput = {
    id?: string
    date: Date | string
    amount: number
    createdAT?: Date | string
    barber: BarberProfileCreateNestedOneWithoutExtraTimeDaysInput
  }

  export type ExtraTimeDayUncheckedCreateInput = {
    id?: string
    date: Date | string
    barberId: string
    amount: number
    createdAT?: Date | string
  }

  export type ExtraTimeDayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutExtraTimeDaysNestedInput
  }

  export type ExtraTimeDayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    barberId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayCreateManyInput = {
    id?: string
    date: Date | string
    barberId: string
    amount: number
    createdAT?: Date | string
  }

  export type ExtraTimeDayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    barberId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointSystemCreateInput = {
    id?: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPointSystemInput
    coupons?: CouponCreateNestedManyWithoutPointSystemInput
    pointTransactions?: PointTransactionCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemUncheckedCreateInput = {
    id?: string
    userId: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponUncheckedCreateNestedManyWithoutPointSystemInput
    pointTransactions?: PointTransactionUncheckedCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointSystemNestedInput
    coupons?: CouponUpdateManyWithoutPointSystemNestedInput
    pointTransactions?: PointTransactionUpdateManyWithoutPointSystemNestedInput
  }

  export type PointSystemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUncheckedUpdateManyWithoutPointSystemNestedInput
    pointTransactions?: PointTransactionUncheckedUpdateManyWithoutPointSystemNestedInput
  }

  export type PointSystemCreateManyInput = {
    id?: string
    userId: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointSystemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointSystemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    pointSystem: PointSystemCreateNestedOneWithoutCouponsInput
    booking?: BookingCreateNestedOneWithoutCouponInput
    notifications?: NotificationCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    pointSystemId: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    bookingId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pointSystem?: PointSystemUpdateOneRequiredWithoutCouponsNestedInput
    booking?: BookingUpdateOneWithoutCouponNestedInput
    notifications?: NotificationUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    pointSystemId: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    bookingId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointTransactionCreateInput = {
    id?: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    pointSystem: PointSystemCreateNestedOneWithoutPointTransactionsInput
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type PointTransactionUncheckedCreateInput = {
    id?: string
    pointSystemId: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PointTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pointSystem?: PointSystemUpdateOneRequiredWithoutPointTransactionsNestedInput
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type PointTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PointTransactionCreateManyInput = {
    id?: string
    pointSystemId: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
  }

  export type PointTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PointTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    coupon?: CouponCreateNestedOneWithoutNotificationsInput
    transaction?: PointTransactionCreateNestedOneWithoutNotificationsInput
    barber?: BarberProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    coupon?: CouponUpdateOneWithoutNotificationsNestedInput
    transaction?: PointTransactionUpdateOneWithoutNotificationsNestedInput
    barber?: BarberProfileUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPlanCreateInput = {
    id?: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanInput
    barber: BarberProfileCreateNestedOneWithoutClientPlansInput
    plan: PlanCreateNestedOneWithoutClientPlansInput
    booking?: BookingCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanUncheckedCreateInput = {
    id?: string
    userId: string
    barberId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutClientPlansNestedInput
    plan?: PlanUpdateOneRequiredWithoutClientPlansNestedInput
    booking?: BookingUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanCreateManyInput = {
    id?: string
    userId: string
    barberId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceCreateNestedManyWithoutPlanInput
    clientPlans?: ClientPlanCreateNestedManyWithoutPlanInput
    barber?: BarberProfileCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    barberId?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutPlanInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUpdateManyWithoutPlanNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUncheckedUpdateManyWithoutPlanNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    barberId?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanToServiceCreateInput = {
    plan: PlanCreateNestedOneWithoutPlanToServiceInput
    service: ServiceCreateNestedOneWithoutPlanToServiceInput
  }

  export type PlanToServiceUncheckedCreateInput = {
    planId: string
    serviceId: string
  }

  export type PlanToServiceUpdateInput = {
    plan?: PlanUpdateOneRequiredWithoutPlanToServiceNestedInput
    service?: ServiceUpdateOneRequiredWithoutPlanToServiceNestedInput
  }

  export type PlanToServiceUncheckedUpdateInput = {
    planId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanToServiceCreateManyInput = {
    planId: string
    serviceId: string
  }

  export type PlanToServiceUpdateManyMutationInput = {

  }

  export type PlanToServiceUncheckedUpdateManyInput = {
    planId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId?: string | null
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type BarberProfileNullableScalarRelationFilter = {
    is?: BarberProfileWhereInput | null
    isNot?: BarberProfileWhereInput | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PointSystemNullableScalarRelationFilter = {
    is?: PointSystemWhereInput | null
    isNot?: PointSystemWhereInput | null
  }

  export type ClientPlanNullableScalarRelationFilter = {
    is?: ClientPlanWhereInput | null
    isNot?: ClientPlanWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BarberProfileToServiceListRelationFilter = {
    every?: BarberProfileToServiceWhereInput
    some?: BarberProfileToServiceWhereInput
    none?: BarberProfileToServiceWhereInput
  }

  export type DisabledDayListRelationFilter = {
    every?: DisabledDayWhereInput
    some?: DisabledDayWhereInput
    none?: DisabledDayWhereInput
  }

  export type ClientPlanListRelationFilter = {
    every?: ClientPlanWhereInput
    some?: ClientPlanWhereInput
    none?: ClientPlanWhereInput
  }

  export type PlanListRelationFilter = {
    every?: PlanWhereInput
    some?: PlanWhereInput
    none?: PlanWhereInput
  }

  export type ExtraTimeDayListRelationFilter = {
    every?: ExtraTimeDayWhereInput
    some?: ExtraTimeDayWhereInput
    none?: ExtraTimeDayWhereInput
  }

  export type DisabledTimeListRelationFilter = {
    every?: DisabledTimeWhereInput
    some?: DisabledTimeWhereInput
    none?: DisabledTimeWhereInput
  }

  export type BarberProfileToServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisabledDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExtraTimeDayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisabledTimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BarberProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    timeInterval?: SortOrder
    createdAt?: SortOrder
  }

  export type BarberProfileAvgOrderByAggregateInput = {
    timeInterval?: SortOrder
  }

  export type BarberProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    timeInterval?: SortOrder
    createdAt?: SortOrder
  }

  export type BarberProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    bio?: SortOrder
    timeInterval?: SortOrder
    createdAt?: SortOrder
  }

  export type BarberProfileSumOrderByAggregateInput = {
    timeInterval?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type BookingServiceListRelationFilter = {
    every?: BookingServiceWhereInput
    some?: BookingServiceWhereInput
    none?: BookingServiceWhereInput
  }

  export type PlanToServiceListRelationFilter = {
    every?: PlanToServiceWhereInput
    some?: PlanToServiceWhereInput
    none?: PlanToServiceWhereInput
  }

  export type BookingServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanToServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    keyword?: SortOrder
    imagePath?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    keyword?: SortOrder
    imagePath?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    keyword?: SortOrder
    imagePath?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type BarberProfileScalarRelationFilter = {
    is?: BarberProfileWhereInput
    isNot?: BarberProfileWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type BarberProfileToServiceBarberProfileIdServiceIdCompoundUniqueInput = {
    barberProfileId: string
    serviceId: string
  }

  export type BarberProfileToServiceCountOrderByAggregateInput = {
    barberProfileId?: SortOrder
    serviceId?: SortOrder
  }

  export type BarberProfileToServiceMaxOrderByAggregateInput = {
    barberProfileId?: SortOrder
    serviceId?: SortOrder
  }

  export type BarberProfileToServiceMinOrderByAggregateInput = {
    barberProfileId?: SortOrder
    serviceId?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingServiceBookingIdServiceIdCompoundUniqueInput = {
    bookingId: string
    serviceId: string
  }

  export type BookingServiceCountOrderByAggregateInput = {
    bookingId?: SortOrder
    serviceId?: SortOrder
  }

  export type BookingServiceMaxOrderByAggregateInput = {
    bookingId?: SortOrder
    serviceId?: SortOrder
  }

  export type BookingServiceMinOrderByAggregateInput = {
    bookingId?: SortOrder
    serviceId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type CouponNullableScalarRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    barberId?: SortOrder
    totalPrice?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    totalDuration?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    barberId?: SortOrder
    totalPrice?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    barberId?: SortOrder
    totalPrice?: SortOrder
    totalDuration?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    totalDuration?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type DisabledDayBarberIdDateCompoundUniqueInput = {
    barberId: string
    date: Date | string
  }

  export type DisabledDayCountOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type DisabledDayMaxOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type DisabledDayMinOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type DisabledTimeBarberIdDateCompoundUniqueInput = {
    barberId: string
    date: Date | string
  }

  export type DisabledTimeCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    createdAt?: SortOrder
  }

  export type DisabledTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    createdAt?: SortOrder
  }

  export type DisabledTimeMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtraTimeDayBarberIdDateCompoundUniqueInput = {
    barberId: string
    date: Date | string
  }

  export type ExtraTimeDayCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    amount?: SortOrder
    createdAT?: SortOrder
  }

  export type ExtraTimeDayAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExtraTimeDayMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    amount?: SortOrder
    createdAT?: SortOrder
  }

  export type ExtraTimeDayMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    barberId?: SortOrder
    amount?: SortOrder
    createdAT?: SortOrder
  }

  export type ExtraTimeDaySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type PointTransactionListRelationFilter = {
    every?: PointTransactionWhereInput
    some?: PointTransactionWhereInput
    none?: PointTransactionWhereInput
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointSystemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointSystemAvgOrderByAggregateInput = {
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
  }

  export type PointSystemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointSystemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PointSystemSumOrderByAggregateInput = {
    currentPoints?: SortOrder
    pointsPerService?: SortOrder
    pointsNeededForReward?: SortOrder
    discountPercentage?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PointSystemScalarRelationFilter = {
    is?: PointSystemWhereInput
    isNot?: PointSystemWhereInput
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    discountPercent?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    discountPercent?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    discountPercent?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type PointTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
  }

  export type PointTransactionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type PointTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
  }

  export type PointTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    pointSystemId?: SortOrder
    points?: SortOrder
    type?: SortOrder
    description?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    confirmedAt?: SortOrder
    confirmedBy?: SortOrder
  }

  export type PointTransactionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationRecipientFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationRecipient | EnumNotificationRecipientFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationRecipientFilter<$PrismaModel> | $Enums.NotificationRecipient
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PointTransactionNullableScalarRelationFilter = {
    is?: PointTransactionWhereInput | null
    isNot?: PointTransactionWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    recipientType?: SortOrder
    barberId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    couponId?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    recipientType?: SortOrder
    barberId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    couponId?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    recipientType?: SortOrder
    barberId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    couponId?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationRecipientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationRecipient | EnumNotificationRecipientFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationRecipientWithAggregatesFilter<$PrismaModel> | $Enums.NotificationRecipient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationRecipientFilter<$PrismaModel>
    _max?: NestedEnumNotificationRecipientFilter<$PrismaModel>
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type ClientPlanUserIdBarberIdCompoundUniqueInput = {
    userId: string
    barberId: string
  }

  export type ClientPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barberId?: SortOrder
    planId?: SortOrder
    useAmount?: SortOrder
    starts?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPlanAvgOrderByAggregateInput = {
    useAmount?: SortOrder
  }

  export type ClientPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barberId?: SortOrder
    planId?: SortOrder
    useAmount?: SortOrder
    starts?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    barberId?: SortOrder
    planId?: SortOrder
    useAmount?: SortOrder
    starts?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientPlanSumOrderByAggregateInput = {
    useAmount?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    barberId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    keyword?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanToServicePlanIdServiceIdCompoundUniqueInput = {
    planId: string
    serviceId: string
  }

  export type PlanToServiceCountOrderByAggregateInput = {
    planId?: SortOrder
    serviceId?: SortOrder
  }

  export type PlanToServiceMaxOrderByAggregateInput = {
    planId?: SortOrder
    serviceId?: SortOrder
  }

  export type PlanToServiceMinOrderByAggregateInput = {
    planId?: SortOrder
    serviceId?: SortOrder
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type BarberProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutUserInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PointSystemCreateNestedOneWithoutUserInput = {
    create?: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutUserInput
    connect?: PointSystemWhereUniqueInput
  }

  export type ClientPlanCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutUserInput
    connect?: ClientPlanWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type BarberProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutUserInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PointSystemUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutUserInput
    connect?: PointSystemWhereUniqueInput
  }

  export type ClientPlanUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutUserInput
    connect?: ClientPlanWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type BarberProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutUserInput
    upsert?: BarberProfileUpsertWithoutUserInput
    disconnect?: BarberProfileWhereInput | boolean
    delete?: BarberProfileWhereInput | boolean
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutUserInput, BarberProfileUpdateWithoutUserInput>, BarberProfileUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PointSystemUpdateOneWithoutUserNestedInput = {
    create?: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutUserInput
    upsert?: PointSystemUpsertWithoutUserInput
    disconnect?: PointSystemWhereInput | boolean
    delete?: PointSystemWhereInput | boolean
    connect?: PointSystemWhereUniqueInput
    update?: XOR<XOR<PointSystemUpdateToOneWithWhereWithoutUserInput, PointSystemUpdateWithoutUserInput>, PointSystemUncheckedUpdateWithoutUserInput>
  }

  export type ClientPlanUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutUserInput
    upsert?: ClientPlanUpsertWithoutUserInput
    disconnect?: ClientPlanWhereInput | boolean
    delete?: ClientPlanWhereInput | boolean
    connect?: ClientPlanWhereUniqueInput
    update?: XOR<XOR<ClientPlanUpdateToOneWithWhereWithoutUserInput, ClientPlanUpdateWithoutUserInput>, ClientPlanUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type BarberProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutUserInput
    upsert?: BarberProfileUpsertWithoutUserInput
    disconnect?: BarberProfileWhereInput | boolean
    delete?: BarberProfileWhereInput | boolean
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutUserInput, BarberProfileUpdateWithoutUserInput>, BarberProfileUncheckedUpdateWithoutUserInput>
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PointSystemUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutUserInput
    upsert?: PointSystemUpsertWithoutUserInput
    disconnect?: PointSystemWhereInput | boolean
    delete?: PointSystemWhereInput | boolean
    connect?: PointSystemWhereUniqueInput
    update?: XOR<XOR<PointSystemUpdateToOneWithWhereWithoutUserInput, PointSystemUpdateWithoutUserInput>, PointSystemUncheckedUpdateWithoutUserInput>
  }

  export type ClientPlanUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutUserInput
    upsert?: ClientPlanUpsertWithoutUserInput
    disconnect?: ClientPlanWhereInput | boolean
    delete?: ClientPlanWhereInput | boolean
    connect?: ClientPlanWhereUniqueInput
    update?: XOR<XOR<ClientPlanUpdateToOneWithWhereWithoutUserInput, ClientPlanUpdateWithoutUserInput>, ClientPlanUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBarberProfileInput = {
    create?: XOR<UserCreateWithoutBarberProfileInput, UserUncheckedCreateWithoutBarberProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBarberProfileInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutBarberInput = {
    create?: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput> | BookingCreateWithoutBarberInput[] | BookingUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBarberInput | BookingCreateOrConnectWithoutBarberInput[]
    createMany?: BookingCreateManyBarberInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput> | BarberProfileToServiceCreateWithoutBarberProfileInput[] | BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput | BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput[]
    createMany?: BarberProfileToServiceCreateManyBarberProfileInputEnvelope
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
  }

  export type DisabledDayCreateNestedManyWithoutBarberInput = {
    create?: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput> | DisabledDayCreateWithoutBarberInput[] | DisabledDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledDayCreateOrConnectWithoutBarberInput | DisabledDayCreateOrConnectWithoutBarberInput[]
    createMany?: DisabledDayCreateManyBarberInputEnvelope
    connect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
  }

  export type ClientPlanCreateNestedManyWithoutBarberInput = {
    create?: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput> | ClientPlanCreateWithoutBarberInput[] | ClientPlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBarberInput | ClientPlanCreateOrConnectWithoutBarberInput[]
    createMany?: ClientPlanCreateManyBarberInputEnvelope
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
  }

  export type PlanCreateNestedManyWithoutBarberInput = {
    create?: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput> | PlanCreateWithoutBarberInput[] | PlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBarberInput | PlanCreateOrConnectWithoutBarberInput[]
    createMany?: PlanCreateManyBarberInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type ExtraTimeDayCreateNestedManyWithoutBarberInput = {
    create?: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput> | ExtraTimeDayCreateWithoutBarberInput[] | ExtraTimeDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ExtraTimeDayCreateOrConnectWithoutBarberInput | ExtraTimeDayCreateOrConnectWithoutBarberInput[]
    createMany?: ExtraTimeDayCreateManyBarberInputEnvelope
    connect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
  }

  export type DisabledTimeCreateNestedManyWithoutBarberInput = {
    create?: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput> | DisabledTimeCreateWithoutBarberInput[] | DisabledTimeUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledTimeCreateOrConnectWithoutBarberInput | DisabledTimeCreateOrConnectWithoutBarberInput[]
    createMany?: DisabledTimeCreateManyBarberInputEnvelope
    connect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutBarberInput = {
    create?: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput> | NotificationCreateWithoutBarberInput[] | NotificationUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBarberInput | NotificationCreateOrConnectWithoutBarberInput[]
    createMany?: NotificationCreateManyBarberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput> | BookingCreateWithoutBarberInput[] | BookingUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBarberInput | BookingCreateOrConnectWithoutBarberInput[]
    createMany?: BookingCreateManyBarberInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput> | BarberProfileToServiceCreateWithoutBarberProfileInput[] | BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput | BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput[]
    createMany?: BarberProfileToServiceCreateManyBarberProfileInputEnvelope
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
  }

  export type DisabledDayUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput> | DisabledDayCreateWithoutBarberInput[] | DisabledDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledDayCreateOrConnectWithoutBarberInput | DisabledDayCreateOrConnectWithoutBarberInput[]
    createMany?: DisabledDayCreateManyBarberInputEnvelope
    connect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
  }

  export type ClientPlanUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput> | ClientPlanCreateWithoutBarberInput[] | ClientPlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBarberInput | ClientPlanCreateOrConnectWithoutBarberInput[]
    createMany?: ClientPlanCreateManyBarberInputEnvelope
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
  }

  export type PlanUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput> | PlanCreateWithoutBarberInput[] | PlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBarberInput | PlanCreateOrConnectWithoutBarberInput[]
    createMany?: PlanCreateManyBarberInputEnvelope
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
  }

  export type ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput> | ExtraTimeDayCreateWithoutBarberInput[] | ExtraTimeDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ExtraTimeDayCreateOrConnectWithoutBarberInput | ExtraTimeDayCreateOrConnectWithoutBarberInput[]
    createMany?: ExtraTimeDayCreateManyBarberInputEnvelope
    connect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
  }

  export type DisabledTimeUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput> | DisabledTimeCreateWithoutBarberInput[] | DisabledTimeUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledTimeCreateOrConnectWithoutBarberInput | DisabledTimeCreateOrConnectWithoutBarberInput[]
    createMany?: DisabledTimeCreateManyBarberInputEnvelope
    connect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutBarberInput = {
    create?: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput> | NotificationCreateWithoutBarberInput[] | NotificationUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBarberInput | NotificationCreateOrConnectWithoutBarberInput[]
    createMany?: NotificationCreateManyBarberInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutBarberProfileNestedInput = {
    create?: XOR<UserCreateWithoutBarberProfileInput, UserUncheckedCreateWithoutBarberProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutBarberProfileInput
    upsert?: UserUpsertWithoutBarberProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBarberProfileInput, UserUpdateWithoutBarberProfileInput>, UserUncheckedUpdateWithoutBarberProfileInput>
  }

  export type BookingUpdateManyWithoutBarberNestedInput = {
    create?: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput> | BookingCreateWithoutBarberInput[] | BookingUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBarberInput | BookingCreateOrConnectWithoutBarberInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBarberInput | BookingUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: BookingCreateManyBarberInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBarberInput | BookingUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBarberInput | BookingUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput> | BarberProfileToServiceCreateWithoutBarberProfileInput[] | BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput | BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput[]
    upsert?: BarberProfileToServiceUpsertWithWhereUniqueWithoutBarberProfileInput | BarberProfileToServiceUpsertWithWhereUniqueWithoutBarberProfileInput[]
    createMany?: BarberProfileToServiceCreateManyBarberProfileInputEnvelope
    set?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    disconnect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    delete?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    update?: BarberProfileToServiceUpdateWithWhereUniqueWithoutBarberProfileInput | BarberProfileToServiceUpdateWithWhereUniqueWithoutBarberProfileInput[]
    updateMany?: BarberProfileToServiceUpdateManyWithWhereWithoutBarberProfileInput | BarberProfileToServiceUpdateManyWithWhereWithoutBarberProfileInput[]
    deleteMany?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
  }

  export type DisabledDayUpdateManyWithoutBarberNestedInput = {
    create?: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput> | DisabledDayCreateWithoutBarberInput[] | DisabledDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledDayCreateOrConnectWithoutBarberInput | DisabledDayCreateOrConnectWithoutBarberInput[]
    upsert?: DisabledDayUpsertWithWhereUniqueWithoutBarberInput | DisabledDayUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: DisabledDayCreateManyBarberInputEnvelope
    set?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    disconnect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    delete?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    connect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    update?: DisabledDayUpdateWithWhereUniqueWithoutBarberInput | DisabledDayUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: DisabledDayUpdateManyWithWhereWithoutBarberInput | DisabledDayUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: DisabledDayScalarWhereInput | DisabledDayScalarWhereInput[]
  }

  export type ClientPlanUpdateManyWithoutBarberNestedInput = {
    create?: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput> | ClientPlanCreateWithoutBarberInput[] | ClientPlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBarberInput | ClientPlanCreateOrConnectWithoutBarberInput[]
    upsert?: ClientPlanUpsertWithWhereUniqueWithoutBarberInput | ClientPlanUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: ClientPlanCreateManyBarberInputEnvelope
    set?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    disconnect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    delete?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    update?: ClientPlanUpdateWithWhereUniqueWithoutBarberInput | ClientPlanUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: ClientPlanUpdateManyWithWhereWithoutBarberInput | ClientPlanUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
  }

  export type PlanUpdateManyWithoutBarberNestedInput = {
    create?: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput> | PlanCreateWithoutBarberInput[] | PlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBarberInput | PlanCreateOrConnectWithoutBarberInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutBarberInput | PlanUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: PlanCreateManyBarberInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutBarberInput | PlanUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutBarberInput | PlanUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type ExtraTimeDayUpdateManyWithoutBarberNestedInput = {
    create?: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput> | ExtraTimeDayCreateWithoutBarberInput[] | ExtraTimeDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ExtraTimeDayCreateOrConnectWithoutBarberInput | ExtraTimeDayCreateOrConnectWithoutBarberInput[]
    upsert?: ExtraTimeDayUpsertWithWhereUniqueWithoutBarberInput | ExtraTimeDayUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: ExtraTimeDayCreateManyBarberInputEnvelope
    set?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    disconnect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    delete?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    connect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    update?: ExtraTimeDayUpdateWithWhereUniqueWithoutBarberInput | ExtraTimeDayUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: ExtraTimeDayUpdateManyWithWhereWithoutBarberInput | ExtraTimeDayUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: ExtraTimeDayScalarWhereInput | ExtraTimeDayScalarWhereInput[]
  }

  export type DisabledTimeUpdateManyWithoutBarberNestedInput = {
    create?: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput> | DisabledTimeCreateWithoutBarberInput[] | DisabledTimeUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledTimeCreateOrConnectWithoutBarberInput | DisabledTimeCreateOrConnectWithoutBarberInput[]
    upsert?: DisabledTimeUpsertWithWhereUniqueWithoutBarberInput | DisabledTimeUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: DisabledTimeCreateManyBarberInputEnvelope
    set?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    disconnect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    delete?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    connect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    update?: DisabledTimeUpdateWithWhereUniqueWithoutBarberInput | DisabledTimeUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: DisabledTimeUpdateManyWithWhereWithoutBarberInput | DisabledTimeUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: DisabledTimeScalarWhereInput | DisabledTimeScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutBarberNestedInput = {
    create?: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput> | NotificationCreateWithoutBarberInput[] | NotificationUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBarberInput | NotificationCreateOrConnectWithoutBarberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBarberInput | NotificationUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: NotificationCreateManyBarberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBarberInput | NotificationUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBarberInput | NotificationUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput> | BookingCreateWithoutBarberInput[] | BookingUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBarberInput | BookingCreateOrConnectWithoutBarberInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBarberInput | BookingUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: BookingCreateManyBarberInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBarberInput | BookingUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBarberInput | BookingUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput> | BarberProfileToServiceCreateWithoutBarberProfileInput[] | BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput | BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput[]
    upsert?: BarberProfileToServiceUpsertWithWhereUniqueWithoutBarberProfileInput | BarberProfileToServiceUpsertWithWhereUniqueWithoutBarberProfileInput[]
    createMany?: BarberProfileToServiceCreateManyBarberProfileInputEnvelope
    set?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    disconnect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    delete?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    update?: BarberProfileToServiceUpdateWithWhereUniqueWithoutBarberProfileInput | BarberProfileToServiceUpdateWithWhereUniqueWithoutBarberProfileInput[]
    updateMany?: BarberProfileToServiceUpdateManyWithWhereWithoutBarberProfileInput | BarberProfileToServiceUpdateManyWithWhereWithoutBarberProfileInput[]
    deleteMany?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
  }

  export type DisabledDayUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput> | DisabledDayCreateWithoutBarberInput[] | DisabledDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledDayCreateOrConnectWithoutBarberInput | DisabledDayCreateOrConnectWithoutBarberInput[]
    upsert?: DisabledDayUpsertWithWhereUniqueWithoutBarberInput | DisabledDayUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: DisabledDayCreateManyBarberInputEnvelope
    set?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    disconnect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    delete?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    connect?: DisabledDayWhereUniqueInput | DisabledDayWhereUniqueInput[]
    update?: DisabledDayUpdateWithWhereUniqueWithoutBarberInput | DisabledDayUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: DisabledDayUpdateManyWithWhereWithoutBarberInput | DisabledDayUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: DisabledDayScalarWhereInput | DisabledDayScalarWhereInput[]
  }

  export type ClientPlanUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput> | ClientPlanCreateWithoutBarberInput[] | ClientPlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBarberInput | ClientPlanCreateOrConnectWithoutBarberInput[]
    upsert?: ClientPlanUpsertWithWhereUniqueWithoutBarberInput | ClientPlanUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: ClientPlanCreateManyBarberInputEnvelope
    set?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    disconnect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    delete?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    update?: ClientPlanUpdateWithWhereUniqueWithoutBarberInput | ClientPlanUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: ClientPlanUpdateManyWithWhereWithoutBarberInput | ClientPlanUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
  }

  export type PlanUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput> | PlanCreateWithoutBarberInput[] | PlanUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: PlanCreateOrConnectWithoutBarberInput | PlanCreateOrConnectWithoutBarberInput[]
    upsert?: PlanUpsertWithWhereUniqueWithoutBarberInput | PlanUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: PlanCreateManyBarberInputEnvelope
    set?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    disconnect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    delete?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    connect?: PlanWhereUniqueInput | PlanWhereUniqueInput[]
    update?: PlanUpdateWithWhereUniqueWithoutBarberInput | PlanUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: PlanUpdateManyWithWhereWithoutBarberInput | PlanUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: PlanScalarWhereInput | PlanScalarWhereInput[]
  }

  export type ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput> | ExtraTimeDayCreateWithoutBarberInput[] | ExtraTimeDayUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: ExtraTimeDayCreateOrConnectWithoutBarberInput | ExtraTimeDayCreateOrConnectWithoutBarberInput[]
    upsert?: ExtraTimeDayUpsertWithWhereUniqueWithoutBarberInput | ExtraTimeDayUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: ExtraTimeDayCreateManyBarberInputEnvelope
    set?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    disconnect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    delete?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    connect?: ExtraTimeDayWhereUniqueInput | ExtraTimeDayWhereUniqueInput[]
    update?: ExtraTimeDayUpdateWithWhereUniqueWithoutBarberInput | ExtraTimeDayUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: ExtraTimeDayUpdateManyWithWhereWithoutBarberInput | ExtraTimeDayUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: ExtraTimeDayScalarWhereInput | ExtraTimeDayScalarWhereInput[]
  }

  export type DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput> | DisabledTimeCreateWithoutBarberInput[] | DisabledTimeUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: DisabledTimeCreateOrConnectWithoutBarberInput | DisabledTimeCreateOrConnectWithoutBarberInput[]
    upsert?: DisabledTimeUpsertWithWhereUniqueWithoutBarberInput | DisabledTimeUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: DisabledTimeCreateManyBarberInputEnvelope
    set?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    disconnect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    delete?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    connect?: DisabledTimeWhereUniqueInput | DisabledTimeWhereUniqueInput[]
    update?: DisabledTimeUpdateWithWhereUniqueWithoutBarberInput | DisabledTimeUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: DisabledTimeUpdateManyWithWhereWithoutBarberInput | DisabledTimeUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: DisabledTimeScalarWhereInput | DisabledTimeScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutBarberNestedInput = {
    create?: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput> | NotificationCreateWithoutBarberInput[] | NotificationUncheckedCreateWithoutBarberInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBarberInput | NotificationCreateOrConnectWithoutBarberInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBarberInput | NotificationUpsertWithWhereUniqueWithoutBarberInput[]
    createMany?: NotificationCreateManyBarberInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBarberInput | NotificationUpdateWithWhereUniqueWithoutBarberInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBarberInput | NotificationUpdateManyWithWhereWithoutBarberInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type BookingServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type BarberProfileToServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput> | BarberProfileToServiceCreateWithoutServiceInput[] | BarberProfileToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutServiceInput | BarberProfileToServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BarberProfileToServiceCreateManyServiceInputEnvelope
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
  }

  export type PlanToServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput> | PlanToServiceCreateWithoutServiceInput[] | PlanToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutServiceInput | PlanToServiceCreateOrConnectWithoutServiceInput[]
    createMany?: PlanToServiceCreateManyServiceInputEnvelope
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type BarberProfileToServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput> | BarberProfileToServiceCreateWithoutServiceInput[] | BarberProfileToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutServiceInput | BarberProfileToServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BarberProfileToServiceCreateManyServiceInputEnvelope
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
  }

  export type PlanToServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput> | PlanToServiceCreateWithoutServiceInput[] | PlanToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutServiceInput | PlanToServiceCreateOrConnectWithoutServiceInput[]
    createMany?: PlanToServiceCreateManyServiceInputEnvelope
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
  }

  export type BookingServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type BarberProfileToServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput> | BarberProfileToServiceCreateWithoutServiceInput[] | BarberProfileToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutServiceInput | BarberProfileToServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BarberProfileToServiceUpsertWithWhereUniqueWithoutServiceInput | BarberProfileToServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BarberProfileToServiceCreateManyServiceInputEnvelope
    set?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    disconnect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    delete?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    update?: BarberProfileToServiceUpdateWithWhereUniqueWithoutServiceInput | BarberProfileToServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BarberProfileToServiceUpdateManyWithWhereWithoutServiceInput | BarberProfileToServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
  }

  export type PlanToServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput> | PlanToServiceCreateWithoutServiceInput[] | PlanToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutServiceInput | PlanToServiceCreateOrConnectWithoutServiceInput[]
    upsert?: PlanToServiceUpsertWithWhereUniqueWithoutServiceInput | PlanToServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PlanToServiceCreateManyServiceInputEnvelope
    set?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    disconnect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    delete?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    update?: PlanToServiceUpdateWithWhereUniqueWithoutServiceInput | PlanToServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PlanToServiceUpdateManyWithWhereWithoutServiceInput | PlanToServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type BarberProfileToServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput> | BarberProfileToServiceCreateWithoutServiceInput[] | BarberProfileToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BarberProfileToServiceCreateOrConnectWithoutServiceInput | BarberProfileToServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BarberProfileToServiceUpsertWithWhereUniqueWithoutServiceInput | BarberProfileToServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BarberProfileToServiceCreateManyServiceInputEnvelope
    set?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    disconnect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    delete?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    connect?: BarberProfileToServiceWhereUniqueInput | BarberProfileToServiceWhereUniqueInput[]
    update?: BarberProfileToServiceUpdateWithWhereUniqueWithoutServiceInput | BarberProfileToServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BarberProfileToServiceUpdateManyWithWhereWithoutServiceInput | BarberProfileToServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
  }

  export type PlanToServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput> | PlanToServiceCreateWithoutServiceInput[] | PlanToServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutServiceInput | PlanToServiceCreateOrConnectWithoutServiceInput[]
    upsert?: PlanToServiceUpsertWithWhereUniqueWithoutServiceInput | PlanToServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: PlanToServiceCreateManyServiceInputEnvelope
    set?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    disconnect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    delete?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    update?: PlanToServiceUpdateWithWhereUniqueWithoutServiceInput | PlanToServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: PlanToServiceUpdateManyWithWhereWithoutServiceInput | PlanToServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
  }

  export type BarberProfileCreateNestedOneWithoutServicesInput = {
    create?: XOR<BarberProfileCreateWithoutServicesInput, BarberProfileUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutServicesInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBarbersInput = {
    create?: XOR<ServiceCreateWithoutBarbersInput, ServiceUncheckedCreateWithoutBarbersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBarbersInput
    connect?: ServiceWhereUniqueInput
  }

  export type BarberProfileUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BarberProfileCreateWithoutServicesInput, BarberProfileUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutServicesInput
    upsert?: BarberProfileUpsertWithoutServicesInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutServicesInput, BarberProfileUpdateWithoutServicesInput>, BarberProfileUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutBarbersNestedInput = {
    create?: XOR<ServiceCreateWithoutBarbersInput, ServiceUncheckedCreateWithoutBarbersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBarbersInput
    upsert?: ServiceUpsertWithoutBarbersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBarbersInput, ServiceUpdateWithoutBarbersInput>, ServiceUncheckedUpdateWithoutBarbersInput>
  }

  export type BookingCreateNestedOneWithoutServicesInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    connect?: BookingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    upsert?: BookingUpsertWithoutServicesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutServicesInput, BookingUpdateWithoutServicesInput>, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type BarberProfileCreateNestedOneWithoutBookingsInput = {
    create?: XOR<BarberProfileCreateWithoutBookingsInput, BarberProfileUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutBookingsInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ClientPlanCreateNestedOneWithoutBookingInput = {
    create?: XOR<ClientPlanCreateWithoutBookingInput, ClientPlanUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBookingInput
    connect?: ClientPlanWhereUniqueInput
  }

  export type BookingServiceCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type CouponCreateNestedOneWithoutBookingInput = {
    create?: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CouponCreateOrConnectWithoutBookingInput
    connect?: CouponWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CouponCreateOrConnectWithoutBookingInput
    connect?: CouponWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type BarberProfileUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<BarberProfileCreateWithoutBookingsInput, BarberProfileUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutBookingsInput
    upsert?: BarberProfileUpsertWithoutBookingsInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutBookingsInput, BarberProfileUpdateWithoutBookingsInput>, BarberProfileUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ClientPlanUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ClientPlanCreateWithoutBookingInput, ClientPlanUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ClientPlanCreateOrConnectWithoutBookingInput
    upsert?: ClientPlanUpsertWithoutBookingInput
    disconnect?: ClientPlanWhereInput | boolean
    delete?: ClientPlanWhereInput | boolean
    connect?: ClientPlanWhereUniqueInput
    update?: XOR<XOR<ClientPlanUpdateToOneWithWhereWithoutBookingInput, ClientPlanUpdateWithoutBookingInput>, ClientPlanUncheckedUpdateWithoutBookingInput>
  }

  export type BookingServiceUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type CouponUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CouponCreateOrConnectWithoutBookingInput
    upsert?: CouponUpsertWithoutBookingInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutBookingInput, CouponUpdateWithoutBookingInput>, CouponUncheckedUpdateWithoutBookingInput>
  }

  export type NotificationUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type CouponUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CouponCreateOrConnectWithoutBookingInput
    upsert?: CouponUpsertWithoutBookingInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutBookingInput, CouponUpdateWithoutBookingInput>, CouponUncheckedUpdateWithoutBookingInput>
  }

  export type NotificationUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput> | NotificationCreateWithoutBookingInput[] | NotificationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutBookingInput | NotificationCreateOrConnectWithoutBookingInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutBookingInput | NotificationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: NotificationCreateManyBookingInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutBookingInput | NotificationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutBookingInput | NotificationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BarberProfileCreateNestedOneWithoutDisabledDaysInput = {
    create?: XOR<BarberProfileCreateWithoutDisabledDaysInput, BarberProfileUncheckedCreateWithoutDisabledDaysInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutDisabledDaysInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type BarberProfileUpdateOneRequiredWithoutDisabledDaysNestedInput = {
    create?: XOR<BarberProfileCreateWithoutDisabledDaysInput, BarberProfileUncheckedCreateWithoutDisabledDaysInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutDisabledDaysInput
    upsert?: BarberProfileUpsertWithoutDisabledDaysInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutDisabledDaysInput, BarberProfileUpdateWithoutDisabledDaysInput>, BarberProfileUncheckedUpdateWithoutDisabledDaysInput>
  }

  export type BarberProfileCreateNestedOneWithoutDisabledTimesInput = {
    create?: XOR<BarberProfileCreateWithoutDisabledTimesInput, BarberProfileUncheckedCreateWithoutDisabledTimesInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutDisabledTimesInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type BarberProfileUpdateOneRequiredWithoutDisabledTimesNestedInput = {
    create?: XOR<BarberProfileCreateWithoutDisabledTimesInput, BarberProfileUncheckedCreateWithoutDisabledTimesInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutDisabledTimesInput
    upsert?: BarberProfileUpsertWithoutDisabledTimesInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutDisabledTimesInput, BarberProfileUpdateWithoutDisabledTimesInput>, BarberProfileUncheckedUpdateWithoutDisabledTimesInput>
  }

  export type BarberProfileCreateNestedOneWithoutExtraTimeDaysInput = {
    create?: XOR<BarberProfileCreateWithoutExtraTimeDaysInput, BarberProfileUncheckedCreateWithoutExtraTimeDaysInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutExtraTimeDaysInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type BarberProfileUpdateOneRequiredWithoutExtraTimeDaysNestedInput = {
    create?: XOR<BarberProfileCreateWithoutExtraTimeDaysInput, BarberProfileUncheckedCreateWithoutExtraTimeDaysInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutExtraTimeDaysInput
    upsert?: BarberProfileUpsertWithoutExtraTimeDaysInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutExtraTimeDaysInput, BarberProfileUpdateWithoutExtraTimeDaysInput>, BarberProfileUncheckedUpdateWithoutExtraTimeDaysInput>
  }

  export type UserCreateNestedOneWithoutPointSystemInput = {
    create?: XOR<UserCreateWithoutPointSystemInput, UserUncheckedCreateWithoutPointSystemInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointSystemInput
    connect?: UserWhereUniqueInput
  }

  export type CouponCreateNestedManyWithoutPointSystemInput = {
    create?: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput> | CouponCreateWithoutPointSystemInput[] | CouponUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutPointSystemInput | CouponCreateOrConnectWithoutPointSystemInput[]
    createMany?: CouponCreateManyPointSystemInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type PointTransactionCreateNestedManyWithoutPointSystemInput = {
    create?: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput> | PointTransactionCreateWithoutPointSystemInput[] | PointTransactionUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutPointSystemInput | PointTransactionCreateOrConnectWithoutPointSystemInput[]
    createMany?: PointTransactionCreateManyPointSystemInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutPointSystemInput = {
    create?: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput> | CouponCreateWithoutPointSystemInput[] | CouponUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutPointSystemInput | CouponCreateOrConnectWithoutPointSystemInput[]
    createMany?: CouponCreateManyPointSystemInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type PointTransactionUncheckedCreateNestedManyWithoutPointSystemInput = {
    create?: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput> | PointTransactionCreateWithoutPointSystemInput[] | PointTransactionUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutPointSystemInput | PointTransactionCreateOrConnectWithoutPointSystemInput[]
    createMany?: PointTransactionCreateManyPointSystemInputEnvelope
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPointSystemNestedInput = {
    create?: XOR<UserCreateWithoutPointSystemInput, UserUncheckedCreateWithoutPointSystemInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointSystemInput
    upsert?: UserUpsertWithoutPointSystemInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointSystemInput, UserUpdateWithoutPointSystemInput>, UserUncheckedUpdateWithoutPointSystemInput>
  }

  export type CouponUpdateManyWithoutPointSystemNestedInput = {
    create?: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput> | CouponCreateWithoutPointSystemInput[] | CouponUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutPointSystemInput | CouponCreateOrConnectWithoutPointSystemInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutPointSystemInput | CouponUpsertWithWhereUniqueWithoutPointSystemInput[]
    createMany?: CouponCreateManyPointSystemInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutPointSystemInput | CouponUpdateWithWhereUniqueWithoutPointSystemInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutPointSystemInput | CouponUpdateManyWithWhereWithoutPointSystemInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type PointTransactionUpdateManyWithoutPointSystemNestedInput = {
    create?: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput> | PointTransactionCreateWithoutPointSystemInput[] | PointTransactionUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutPointSystemInput | PointTransactionCreateOrConnectWithoutPointSystemInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutPointSystemInput | PointTransactionUpsertWithWhereUniqueWithoutPointSystemInput[]
    createMany?: PointTransactionCreateManyPointSystemInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutPointSystemInput | PointTransactionUpdateWithWhereUniqueWithoutPointSystemInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutPointSystemInput | PointTransactionUpdateManyWithWhereWithoutPointSystemInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutPointSystemNestedInput = {
    create?: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput> | CouponCreateWithoutPointSystemInput[] | CouponUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutPointSystemInput | CouponCreateOrConnectWithoutPointSystemInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutPointSystemInput | CouponUpsertWithWhereUniqueWithoutPointSystemInput[]
    createMany?: CouponCreateManyPointSystemInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutPointSystemInput | CouponUpdateWithWhereUniqueWithoutPointSystemInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutPointSystemInput | CouponUpdateManyWithWhereWithoutPointSystemInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type PointTransactionUncheckedUpdateManyWithoutPointSystemNestedInput = {
    create?: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput> | PointTransactionCreateWithoutPointSystemInput[] | PointTransactionUncheckedCreateWithoutPointSystemInput[]
    connectOrCreate?: PointTransactionCreateOrConnectWithoutPointSystemInput | PointTransactionCreateOrConnectWithoutPointSystemInput[]
    upsert?: PointTransactionUpsertWithWhereUniqueWithoutPointSystemInput | PointTransactionUpsertWithWhereUniqueWithoutPointSystemInput[]
    createMany?: PointTransactionCreateManyPointSystemInputEnvelope
    set?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    disconnect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    delete?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    connect?: PointTransactionWhereUniqueInput | PointTransactionWhereUniqueInput[]
    update?: PointTransactionUpdateWithWhereUniqueWithoutPointSystemInput | PointTransactionUpdateWithWhereUniqueWithoutPointSystemInput[]
    updateMany?: PointTransactionUpdateManyWithWhereWithoutPointSystemInput | PointTransactionUpdateManyWithWhereWithoutPointSystemInput[]
    deleteMany?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
  }

  export type PointSystemCreateNestedOneWithoutCouponsInput = {
    create?: XOR<PointSystemCreateWithoutCouponsInput, PointSystemUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutCouponsInput
    connect?: PointSystemWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutCouponInput = {
    create?: XOR<BookingCreateWithoutCouponInput, BookingUncheckedCreateWithoutCouponInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCouponInput
    connect?: BookingWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutCouponInput = {
    create?: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput> | NotificationCreateWithoutCouponInput[] | NotificationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCouponInput | NotificationCreateOrConnectWithoutCouponInput[]
    createMany?: NotificationCreateManyCouponInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput> | NotificationCreateWithoutCouponInput[] | NotificationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCouponInput | NotificationCreateOrConnectWithoutCouponInput[]
    createMany?: NotificationCreateManyCouponInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PointSystemUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<PointSystemCreateWithoutCouponsInput, PointSystemUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutCouponsInput
    upsert?: PointSystemUpsertWithoutCouponsInput
    connect?: PointSystemWhereUniqueInput
    update?: XOR<XOR<PointSystemUpdateToOneWithWhereWithoutCouponsInput, PointSystemUpdateWithoutCouponsInput>, PointSystemUncheckedUpdateWithoutCouponsInput>
  }

  export type BookingUpdateOneWithoutCouponNestedInput = {
    create?: XOR<BookingCreateWithoutCouponInput, BookingUncheckedCreateWithoutCouponInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCouponInput
    upsert?: BookingUpsertWithoutCouponInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCouponInput, BookingUpdateWithoutCouponInput>, BookingUncheckedUpdateWithoutCouponInput>
  }

  export type NotificationUpdateManyWithoutCouponNestedInput = {
    create?: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput> | NotificationCreateWithoutCouponInput[] | NotificationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCouponInput | NotificationCreateOrConnectWithoutCouponInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCouponInput | NotificationUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: NotificationCreateManyCouponInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCouponInput | NotificationUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCouponInput | NotificationUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput> | NotificationCreateWithoutCouponInput[] | NotificationUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCouponInput | NotificationCreateOrConnectWithoutCouponInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCouponInput | NotificationUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: NotificationCreateManyCouponInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCouponInput | NotificationUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCouponInput | NotificationUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PointSystemCreateNestedOneWithoutPointTransactionsInput = {
    create?: XOR<PointSystemCreateWithoutPointTransactionsInput, PointSystemUncheckedCreateWithoutPointTransactionsInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutPointTransactionsInput
    connect?: PointSystemWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutTransactionInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type PointSystemUpdateOneRequiredWithoutPointTransactionsNestedInput = {
    create?: XOR<PointSystemCreateWithoutPointTransactionsInput, PointSystemUncheckedCreateWithoutPointTransactionsInput>
    connectOrCreate?: PointSystemCreateOrConnectWithoutPointTransactionsInput
    upsert?: PointSystemUpsertWithoutPointTransactionsInput
    connect?: PointSystemWhereUniqueInput
    update?: XOR<XOR<PointSystemUpdateToOneWithWhereWithoutPointTransactionsInput, PointSystemUpdateWithoutPointTransactionsInput>, PointSystemUncheckedUpdateWithoutPointTransactionsInput>
  }

  export type NotificationUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTransactionInput | NotificationUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTransactionInput | NotificationUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTransactionInput | NotificationUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput> | NotificationCreateWithoutTransactionInput[] | NotificationUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTransactionInput | NotificationCreateOrConnectWithoutTransactionInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTransactionInput | NotificationUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: NotificationCreateManyTransactionInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTransactionInput | NotificationUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTransactionInput | NotificationUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    connect?: BookingWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CouponCreateWithoutNotificationsInput, CouponUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutNotificationsInput
    connect?: CouponWhereUniqueInput
  }

  export type PointTransactionCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PointTransactionCreateWithoutNotificationsInput, PointTransactionUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PointTransactionCreateOrConnectWithoutNotificationsInput
    connect?: PointTransactionWhereUniqueInput
  }

  export type BarberProfileCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<BarberProfileCreateWithoutNotificationsInput, BarberProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutNotificationsInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationRecipientFieldUpdateOperationsInput = {
    set?: $Enums.NotificationRecipient
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type BookingUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNotificationsInput
    upsert?: BookingUpsertWithoutNotificationsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutNotificationsInput, BookingUpdateWithoutNotificationsInput>, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type CouponUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CouponCreateWithoutNotificationsInput, CouponUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutNotificationsInput
    upsert?: CouponUpsertWithoutNotificationsInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutNotificationsInput, CouponUpdateWithoutNotificationsInput>, CouponUncheckedUpdateWithoutNotificationsInput>
  }

  export type PointTransactionUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PointTransactionCreateWithoutNotificationsInput, PointTransactionUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PointTransactionCreateOrConnectWithoutNotificationsInput
    upsert?: PointTransactionUpsertWithoutNotificationsInput
    disconnect?: PointTransactionWhereInput | boolean
    delete?: PointTransactionWhereInput | boolean
    connect?: PointTransactionWhereUniqueInput
    update?: XOR<XOR<PointTransactionUpdateToOneWithWhereWithoutNotificationsInput, PointTransactionUpdateWithoutNotificationsInput>, PointTransactionUncheckedUpdateWithoutNotificationsInput>
  }

  export type BarberProfileUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<BarberProfileCreateWithoutNotificationsInput, BarberProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutNotificationsInput
    upsert?: BarberProfileUpsertWithoutNotificationsInput
    disconnect?: BarberProfileWhereInput | boolean
    delete?: BarberProfileWhereInput | boolean
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutNotificationsInput, BarberProfileUpdateWithoutNotificationsInput>, BarberProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPlanInput = {
    create?: XOR<UserCreateWithoutPlanInput, UserUncheckedCreateWithoutPlanInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanInput
    connect?: UserWhereUniqueInput
  }

  export type BarberProfileCreateNestedOneWithoutClientPlansInput = {
    create?: XOR<BarberProfileCreateWithoutClientPlansInput, BarberProfileUncheckedCreateWithoutClientPlansInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutClientPlansInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutClientPlansInput = {
    create?: XOR<PlanCreateWithoutClientPlansInput, PlanUncheckedCreateWithoutClientPlansInput>
    connectOrCreate?: PlanCreateOrConnectWithoutClientPlansInput
    connect?: PlanWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutPlanInput = {
    create?: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput> | BookingCreateWithoutPlanInput[] | BookingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPlanInput | BookingCreateOrConnectWithoutPlanInput[]
    createMany?: BookingCreateManyPlanInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput> | BookingCreateWithoutPlanInput[] | BookingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPlanInput | BookingCreateOrConnectWithoutPlanInput[]
    createMany?: BookingCreateManyPlanInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPlanNestedInput = {
    create?: XOR<UserCreateWithoutPlanInput, UserUncheckedCreateWithoutPlanInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlanInput
    upsert?: UserUpsertWithoutPlanInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlanInput, UserUpdateWithoutPlanInput>, UserUncheckedUpdateWithoutPlanInput>
  }

  export type BarberProfileUpdateOneRequiredWithoutClientPlansNestedInput = {
    create?: XOR<BarberProfileCreateWithoutClientPlansInput, BarberProfileUncheckedCreateWithoutClientPlansInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutClientPlansInput
    upsert?: BarberProfileUpsertWithoutClientPlansInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutClientPlansInput, BarberProfileUpdateWithoutClientPlansInput>, BarberProfileUncheckedUpdateWithoutClientPlansInput>
  }

  export type PlanUpdateOneRequiredWithoutClientPlansNestedInput = {
    create?: XOR<PlanCreateWithoutClientPlansInput, PlanUncheckedCreateWithoutClientPlansInput>
    connectOrCreate?: PlanCreateOrConnectWithoutClientPlansInput
    upsert?: PlanUpsertWithoutClientPlansInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutClientPlansInput, PlanUpdateWithoutClientPlansInput>, PlanUncheckedUpdateWithoutClientPlansInput>
  }

  export type BookingUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput> | BookingCreateWithoutPlanInput[] | BookingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPlanInput | BookingCreateOrConnectWithoutPlanInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPlanInput | BookingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BookingCreateManyPlanInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPlanInput | BookingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPlanInput | BookingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput> | BookingCreateWithoutPlanInput[] | BookingUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPlanInput | BookingCreateOrConnectWithoutPlanInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPlanInput | BookingUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BookingCreateManyPlanInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPlanInput | BookingUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPlanInput | BookingUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PlanToServiceCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput> | PlanToServiceCreateWithoutPlanInput[] | PlanToServiceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutPlanInput | PlanToServiceCreateOrConnectWithoutPlanInput[]
    createMany?: PlanToServiceCreateManyPlanInputEnvelope
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
  }

  export type ClientPlanCreateNestedManyWithoutPlanInput = {
    create?: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput> | ClientPlanCreateWithoutPlanInput[] | ClientPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutPlanInput | ClientPlanCreateOrConnectWithoutPlanInput[]
    createMany?: ClientPlanCreateManyPlanInputEnvelope
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
  }

  export type BarberProfileCreateNestedOneWithoutPlansInput = {
    create?: XOR<BarberProfileCreateWithoutPlansInput, BarberProfileUncheckedCreateWithoutPlansInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutPlansInput
    connect?: BarberProfileWhereUniqueInput
  }

  export type PlanToServiceUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput> | PlanToServiceCreateWithoutPlanInput[] | PlanToServiceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutPlanInput | PlanToServiceCreateOrConnectWithoutPlanInput[]
    createMany?: PlanToServiceCreateManyPlanInputEnvelope
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
  }

  export type ClientPlanUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput> | ClientPlanCreateWithoutPlanInput[] | ClientPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutPlanInput | ClientPlanCreateOrConnectWithoutPlanInput[]
    createMany?: ClientPlanCreateManyPlanInputEnvelope
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
  }

  export type PlanToServiceUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput> | PlanToServiceCreateWithoutPlanInput[] | PlanToServiceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutPlanInput | PlanToServiceCreateOrConnectWithoutPlanInput[]
    upsert?: PlanToServiceUpsertWithWhereUniqueWithoutPlanInput | PlanToServiceUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanToServiceCreateManyPlanInputEnvelope
    set?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    disconnect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    delete?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    update?: PlanToServiceUpdateWithWhereUniqueWithoutPlanInput | PlanToServiceUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanToServiceUpdateManyWithWhereWithoutPlanInput | PlanToServiceUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
  }

  export type ClientPlanUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput> | ClientPlanCreateWithoutPlanInput[] | ClientPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutPlanInput | ClientPlanCreateOrConnectWithoutPlanInput[]
    upsert?: ClientPlanUpsertWithWhereUniqueWithoutPlanInput | ClientPlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ClientPlanCreateManyPlanInputEnvelope
    set?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    disconnect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    delete?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    update?: ClientPlanUpdateWithWhereUniqueWithoutPlanInput | ClientPlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ClientPlanUpdateManyWithWhereWithoutPlanInput | ClientPlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
  }

  export type BarberProfileUpdateOneRequiredWithoutPlansNestedInput = {
    create?: XOR<BarberProfileCreateWithoutPlansInput, BarberProfileUncheckedCreateWithoutPlansInput>
    connectOrCreate?: BarberProfileCreateOrConnectWithoutPlansInput
    upsert?: BarberProfileUpsertWithoutPlansInput
    connect?: BarberProfileWhereUniqueInput
    update?: XOR<XOR<BarberProfileUpdateToOneWithWhereWithoutPlansInput, BarberProfileUpdateWithoutPlansInput>, BarberProfileUncheckedUpdateWithoutPlansInput>
  }

  export type PlanToServiceUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput> | PlanToServiceCreateWithoutPlanInput[] | PlanToServiceUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanToServiceCreateOrConnectWithoutPlanInput | PlanToServiceCreateOrConnectWithoutPlanInput[]
    upsert?: PlanToServiceUpsertWithWhereUniqueWithoutPlanInput | PlanToServiceUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanToServiceCreateManyPlanInputEnvelope
    set?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    disconnect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    delete?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    connect?: PlanToServiceWhereUniqueInput | PlanToServiceWhereUniqueInput[]
    update?: PlanToServiceUpdateWithWhereUniqueWithoutPlanInput | PlanToServiceUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanToServiceUpdateManyWithWhereWithoutPlanInput | PlanToServiceUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
  }

  export type ClientPlanUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput> | ClientPlanCreateWithoutPlanInput[] | ClientPlanUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: ClientPlanCreateOrConnectWithoutPlanInput | ClientPlanCreateOrConnectWithoutPlanInput[]
    upsert?: ClientPlanUpsertWithWhereUniqueWithoutPlanInput | ClientPlanUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: ClientPlanCreateManyPlanInputEnvelope
    set?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    disconnect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    delete?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    connect?: ClientPlanWhereUniqueInput | ClientPlanWhereUniqueInput[]
    update?: ClientPlanUpdateWithWhereUniqueWithoutPlanInput | ClientPlanUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: ClientPlanUpdateManyWithWhereWithoutPlanInput | ClientPlanUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutPlanToServiceInput = {
    create?: XOR<PlanCreateWithoutPlanToServiceInput, PlanUncheckedCreateWithoutPlanToServiceInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPlanToServiceInput
    connect?: PlanWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPlanToServiceInput = {
    create?: XOR<ServiceCreateWithoutPlanToServiceInput, ServiceUncheckedCreateWithoutPlanToServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPlanToServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutPlanToServiceNestedInput = {
    create?: XOR<PlanCreateWithoutPlanToServiceInput, PlanUncheckedCreateWithoutPlanToServiceInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPlanToServiceInput
    upsert?: PlanUpsertWithoutPlanToServiceInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutPlanToServiceInput, PlanUpdateWithoutPlanToServiceInput>, PlanUncheckedUpdateWithoutPlanToServiceInput>
  }

  export type ServiceUpdateOneRequiredWithoutPlanToServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutPlanToServiceInput, ServiceUncheckedCreateWithoutPlanToServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPlanToServiceInput
    upsert?: ServiceUpsertWithoutPlanToServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPlanToServiceInput, ServiceUpdateWithoutPlanToServiceInput>, ServiceUncheckedUpdateWithoutPlanToServiceInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationRecipientFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationRecipient | EnumNotificationRecipientFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationRecipientFilter<$PrismaModel> | $Enums.NotificationRecipient
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationRecipientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationRecipient | EnumNotificationRecipientFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationRecipient[] | ListEnumNotificationRecipientFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationRecipientWithAggregatesFilter<$PrismaModel> | $Enums.NotificationRecipient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationRecipientFilter<$PrismaModel>
    _max?: NestedEnumNotificationRecipientFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BarberProfileCreateWithoutUserInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutUserInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointSystemCreateWithoutUserInput = {
    id?: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponCreateNestedManyWithoutPointSystemInput
    pointTransactions?: PointTransactionCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemUncheckedCreateWithoutUserInput = {
    id?: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponUncheckedCreateNestedManyWithoutPointSystemInput
    pointTransactions?: PointTransactionUncheckedCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemCreateOrConnectWithoutUserInput = {
    where: PointSystemWhereUniqueInput
    create: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
  }

  export type ClientPlanCreateWithoutUserInput = {
    id?: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutClientPlansInput
    plan: PlanCreateNestedOneWithoutClientPlansInput
    booking?: BookingCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanUncheckedCreateWithoutUserInput = {
    id?: string
    barberId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanCreateOrConnectWithoutUserInput = {
    where: ClientPlanWhereUniqueInput
    create: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    coupon?: CouponCreateNestedOneWithoutNotificationsInput
    transaction?: PointTransactionCreateNestedOneWithoutNotificationsInput
    barber?: BarberProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type BarberProfileUpsertWithoutUserInput = {
    update: XOR<BarberProfileUpdateWithoutUserInput, BarberProfileUncheckedUpdateWithoutUserInput>
    create: XOR<BarberProfileCreateWithoutUserInput, BarberProfileUncheckedCreateWithoutUserInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutUserInput, BarberProfileUncheckedUpdateWithoutUserInput>
  }

  export type BarberProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    date?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    userId?: StringFilter<"Booking"> | string
    planId?: StringNullableFilter<"Booking"> | string | null
    barberId?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    totalDuration?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PointSystemUpsertWithoutUserInput = {
    update: XOR<PointSystemUpdateWithoutUserInput, PointSystemUncheckedUpdateWithoutUserInput>
    create: XOR<PointSystemCreateWithoutUserInput, PointSystemUncheckedCreateWithoutUserInput>
    where?: PointSystemWhereInput
  }

  export type PointSystemUpdateToOneWithWhereWithoutUserInput = {
    where?: PointSystemWhereInput
    data: XOR<PointSystemUpdateWithoutUserInput, PointSystemUncheckedUpdateWithoutUserInput>
  }

  export type PointSystemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUpdateManyWithoutPointSystemNestedInput
    pointTransactions?: PointTransactionUpdateManyWithoutPointSystemNestedInput
  }

  export type PointSystemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUncheckedUpdateManyWithoutPointSystemNestedInput
    pointTransactions?: PointTransactionUncheckedUpdateManyWithoutPointSystemNestedInput
  }

  export type ClientPlanUpsertWithoutUserInput = {
    update: XOR<ClientPlanUpdateWithoutUserInput, ClientPlanUncheckedUpdateWithoutUserInput>
    create: XOR<ClientPlanCreateWithoutUserInput, ClientPlanUncheckedCreateWithoutUserInput>
    where?: ClientPlanWhereInput
  }

  export type ClientPlanUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientPlanWhereInput
    data: XOR<ClientPlanUpdateWithoutUserInput, ClientPlanUncheckedUpdateWithoutUserInput>
  }

  export type ClientPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutClientPlansNestedInput
    plan?: PlanUpdateOneRequiredWithoutClientPlansNestedInput
    booking?: BookingUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    recipientType?: EnumNotificationRecipientFilter<"Notification"> | $Enums.NotificationRecipient
    barberId?: StringNullableFilter<"Notification"> | string | null
    userId?: StringNullableFilter<"Notification"> | string | null
    bookingId?: StringNullableFilter<"Notification"> | string | null
    couponId?: StringNullableFilter<"Notification"> | string | null
    transactionId?: StringNullableFilter<"Notification"> | string | null
    metadata?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringNullableFilter<"PushSubscription"> | string | null
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type UserCreateWithoutBarberProfileInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBarberProfileInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBarberProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBarberProfileInput, UserUncheckedCreateWithoutBarberProfileInput>
  }

  export type BookingCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBarberInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput>
  }

  export type BookingCreateManyBarberInputEnvelope = {
    data: BookingCreateManyBarberInput | BookingCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type BarberProfileToServiceCreateWithoutBarberProfileInput = {
    service: ServiceCreateNestedOneWithoutBarbersInput
  }

  export type BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput = {
    serviceId: string
  }

  export type BarberProfileToServiceCreateOrConnectWithoutBarberProfileInput = {
    where: BarberProfileToServiceWhereUniqueInput
    create: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput>
  }

  export type BarberProfileToServiceCreateManyBarberProfileInputEnvelope = {
    data: BarberProfileToServiceCreateManyBarberProfileInput | BarberProfileToServiceCreateManyBarberProfileInput[]
    skipDuplicates?: boolean
  }

  export type DisabledDayCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type DisabledDayUncheckedCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type DisabledDayCreateOrConnectWithoutBarberInput = {
    where: DisabledDayWhereUniqueInput
    create: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput>
  }

  export type DisabledDayCreateManyBarberInputEnvelope = {
    data: DisabledDayCreateManyBarberInput | DisabledDayCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type ClientPlanCreateWithoutBarberInput = {
    id?: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanInput
    plan: PlanCreateNestedOneWithoutClientPlansInput
    booking?: BookingCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanUncheckedCreateWithoutBarberInput = {
    id?: string
    userId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanCreateOrConnectWithoutBarberInput = {
    where: ClientPlanWhereUniqueInput
    create: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput>
  }

  export type ClientPlanCreateManyBarberInputEnvelope = {
    data: ClientPlanCreateManyBarberInput | ClientPlanCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type PlanCreateWithoutBarberInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceCreateNestedManyWithoutPlanInput
    clientPlans?: ClientPlanCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutBarberInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutPlanInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutBarberInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput>
  }

  export type PlanCreateManyBarberInputEnvelope = {
    data: PlanCreateManyBarberInput | PlanCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type ExtraTimeDayCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    amount: number
    createdAT?: Date | string
  }

  export type ExtraTimeDayUncheckedCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    amount: number
    createdAT?: Date | string
  }

  export type ExtraTimeDayCreateOrConnectWithoutBarberInput = {
    where: ExtraTimeDayWhereUniqueInput
    create: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput>
  }

  export type ExtraTimeDayCreateManyBarberInputEnvelope = {
    data: ExtraTimeDayCreateManyBarberInput | ExtraTimeDayCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type DisabledTimeCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
  }

  export type DisabledTimeUncheckedCreateWithoutBarberInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
  }

  export type DisabledTimeCreateOrConnectWithoutBarberInput = {
    where: DisabledTimeWhereUniqueInput
    create: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput>
  }

  export type DisabledTimeCreateManyBarberInputEnvelope = {
    data: DisabledTimeCreateManyBarberInput | DisabledTimeCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutBarberInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    coupon?: CouponCreateNestedOneWithoutNotificationsInput
    transaction?: PointTransactionCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutBarberInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBarberInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput>
  }

  export type NotificationCreateManyBarberInputEnvelope = {
    data: NotificationCreateManyBarberInput | NotificationCreateManyBarberInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBarberProfileInput = {
    update: XOR<UserUpdateWithoutBarberProfileInput, UserUncheckedUpdateWithoutBarberProfileInput>
    create: XOR<UserCreateWithoutBarberProfileInput, UserUncheckedCreateWithoutBarberProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBarberProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBarberProfileInput, UserUncheckedUpdateWithoutBarberProfileInput>
  }

  export type UserUpdateWithoutBarberProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBarberProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutBarberInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBarberInput, BookingUncheckedUpdateWithoutBarberInput>
    create: XOR<BookingCreateWithoutBarberInput, BookingUncheckedCreateWithoutBarberInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBarberInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBarberInput, BookingUncheckedUpdateWithoutBarberInput>
  }

  export type BookingUpdateManyWithWhereWithoutBarberInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBarberInput>
  }

  export type BarberProfileToServiceUpsertWithWhereUniqueWithoutBarberProfileInput = {
    where: BarberProfileToServiceWhereUniqueInput
    update: XOR<BarberProfileToServiceUpdateWithoutBarberProfileInput, BarberProfileToServiceUncheckedUpdateWithoutBarberProfileInput>
    create: XOR<BarberProfileToServiceCreateWithoutBarberProfileInput, BarberProfileToServiceUncheckedCreateWithoutBarberProfileInput>
  }

  export type BarberProfileToServiceUpdateWithWhereUniqueWithoutBarberProfileInput = {
    where: BarberProfileToServiceWhereUniqueInput
    data: XOR<BarberProfileToServiceUpdateWithoutBarberProfileInput, BarberProfileToServiceUncheckedUpdateWithoutBarberProfileInput>
  }

  export type BarberProfileToServiceUpdateManyWithWhereWithoutBarberProfileInput = {
    where: BarberProfileToServiceScalarWhereInput
    data: XOR<BarberProfileToServiceUpdateManyMutationInput, BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileInput>
  }

  export type BarberProfileToServiceScalarWhereInput = {
    AND?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
    OR?: BarberProfileToServiceScalarWhereInput[]
    NOT?: BarberProfileToServiceScalarWhereInput | BarberProfileToServiceScalarWhereInput[]
    barberProfileId?: StringFilter<"BarberProfileToService"> | string
    serviceId?: StringFilter<"BarberProfileToService"> | string
  }

  export type DisabledDayUpsertWithWhereUniqueWithoutBarberInput = {
    where: DisabledDayWhereUniqueInput
    update: XOR<DisabledDayUpdateWithoutBarberInput, DisabledDayUncheckedUpdateWithoutBarberInput>
    create: XOR<DisabledDayCreateWithoutBarberInput, DisabledDayUncheckedCreateWithoutBarberInput>
  }

  export type DisabledDayUpdateWithWhereUniqueWithoutBarberInput = {
    where: DisabledDayWhereUniqueInput
    data: XOR<DisabledDayUpdateWithoutBarberInput, DisabledDayUncheckedUpdateWithoutBarberInput>
  }

  export type DisabledDayUpdateManyWithWhereWithoutBarberInput = {
    where: DisabledDayScalarWhereInput
    data: XOR<DisabledDayUpdateManyMutationInput, DisabledDayUncheckedUpdateManyWithoutBarberInput>
  }

  export type DisabledDayScalarWhereInput = {
    AND?: DisabledDayScalarWhereInput | DisabledDayScalarWhereInput[]
    OR?: DisabledDayScalarWhereInput[]
    NOT?: DisabledDayScalarWhereInput | DisabledDayScalarWhereInput[]
    id?: StringFilter<"DisabledDay"> | string
    barberId?: StringFilter<"DisabledDay"> | string
    date?: DateTimeFilter<"DisabledDay"> | Date | string
    reason?: StringNullableFilter<"DisabledDay"> | string | null
    createdAt?: DateTimeFilter<"DisabledDay"> | Date | string
  }

  export type ClientPlanUpsertWithWhereUniqueWithoutBarberInput = {
    where: ClientPlanWhereUniqueInput
    update: XOR<ClientPlanUpdateWithoutBarberInput, ClientPlanUncheckedUpdateWithoutBarberInput>
    create: XOR<ClientPlanCreateWithoutBarberInput, ClientPlanUncheckedCreateWithoutBarberInput>
  }

  export type ClientPlanUpdateWithWhereUniqueWithoutBarberInput = {
    where: ClientPlanWhereUniqueInput
    data: XOR<ClientPlanUpdateWithoutBarberInput, ClientPlanUncheckedUpdateWithoutBarberInput>
  }

  export type ClientPlanUpdateManyWithWhereWithoutBarberInput = {
    where: ClientPlanScalarWhereInput
    data: XOR<ClientPlanUpdateManyMutationInput, ClientPlanUncheckedUpdateManyWithoutBarberInput>
  }

  export type ClientPlanScalarWhereInput = {
    AND?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
    OR?: ClientPlanScalarWhereInput[]
    NOT?: ClientPlanScalarWhereInput | ClientPlanScalarWhereInput[]
    id?: StringFilter<"ClientPlan"> | string
    userId?: StringFilter<"ClientPlan"> | string
    barberId?: StringFilter<"ClientPlan"> | string
    planId?: StringFilter<"ClientPlan"> | string
    useAmount?: IntFilter<"ClientPlan"> | number
    starts?: DateTimeFilter<"ClientPlan"> | Date | string
    expires?: DateTimeFilter<"ClientPlan"> | Date | string
    createdAt?: DateTimeFilter<"ClientPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ClientPlan"> | Date | string
  }

  export type PlanUpsertWithWhereUniqueWithoutBarberInput = {
    where: PlanWhereUniqueInput
    update: XOR<PlanUpdateWithoutBarberInput, PlanUncheckedUpdateWithoutBarberInput>
    create: XOR<PlanCreateWithoutBarberInput, PlanUncheckedCreateWithoutBarberInput>
  }

  export type PlanUpdateWithWhereUniqueWithoutBarberInput = {
    where: PlanWhereUniqueInput
    data: XOR<PlanUpdateWithoutBarberInput, PlanUncheckedUpdateWithoutBarberInput>
  }

  export type PlanUpdateManyWithWhereWithoutBarberInput = {
    where: PlanScalarWhereInput
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyWithoutBarberInput>
  }

  export type PlanScalarWhereInput = {
    AND?: PlanScalarWhereInput | PlanScalarWhereInput[]
    OR?: PlanScalarWhereInput[]
    NOT?: PlanScalarWhereInput | PlanScalarWhereInput[]
    id?: StringFilter<"Plan"> | string
    barberId?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: IntFilter<"Plan"> | number
    keyword?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type ExtraTimeDayUpsertWithWhereUniqueWithoutBarberInput = {
    where: ExtraTimeDayWhereUniqueInput
    update: XOR<ExtraTimeDayUpdateWithoutBarberInput, ExtraTimeDayUncheckedUpdateWithoutBarberInput>
    create: XOR<ExtraTimeDayCreateWithoutBarberInput, ExtraTimeDayUncheckedCreateWithoutBarberInput>
  }

  export type ExtraTimeDayUpdateWithWhereUniqueWithoutBarberInput = {
    where: ExtraTimeDayWhereUniqueInput
    data: XOR<ExtraTimeDayUpdateWithoutBarberInput, ExtraTimeDayUncheckedUpdateWithoutBarberInput>
  }

  export type ExtraTimeDayUpdateManyWithWhereWithoutBarberInput = {
    where: ExtraTimeDayScalarWhereInput
    data: XOR<ExtraTimeDayUpdateManyMutationInput, ExtraTimeDayUncheckedUpdateManyWithoutBarberInput>
  }

  export type ExtraTimeDayScalarWhereInput = {
    AND?: ExtraTimeDayScalarWhereInput | ExtraTimeDayScalarWhereInput[]
    OR?: ExtraTimeDayScalarWhereInput[]
    NOT?: ExtraTimeDayScalarWhereInput | ExtraTimeDayScalarWhereInput[]
    id?: StringFilter<"ExtraTimeDay"> | string
    date?: DateTimeFilter<"ExtraTimeDay"> | Date | string
    barberId?: StringFilter<"ExtraTimeDay"> | string
    amount?: IntFilter<"ExtraTimeDay"> | number
    createdAT?: DateTimeFilter<"ExtraTimeDay"> | Date | string
  }

  export type DisabledTimeUpsertWithWhereUniqueWithoutBarberInput = {
    where: DisabledTimeWhereUniqueInput
    update: XOR<DisabledTimeUpdateWithoutBarberInput, DisabledTimeUncheckedUpdateWithoutBarberInput>
    create: XOR<DisabledTimeCreateWithoutBarberInput, DisabledTimeUncheckedCreateWithoutBarberInput>
  }

  export type DisabledTimeUpdateWithWhereUniqueWithoutBarberInput = {
    where: DisabledTimeWhereUniqueInput
    data: XOR<DisabledTimeUpdateWithoutBarberInput, DisabledTimeUncheckedUpdateWithoutBarberInput>
  }

  export type DisabledTimeUpdateManyWithWhereWithoutBarberInput = {
    where: DisabledTimeScalarWhereInput
    data: XOR<DisabledTimeUpdateManyMutationInput, DisabledTimeUncheckedUpdateManyWithoutBarberInput>
  }

  export type DisabledTimeScalarWhereInput = {
    AND?: DisabledTimeScalarWhereInput | DisabledTimeScalarWhereInput[]
    OR?: DisabledTimeScalarWhereInput[]
    NOT?: DisabledTimeScalarWhereInput | DisabledTimeScalarWhereInput[]
    id?: StringFilter<"DisabledTime"> | string
    date?: DateTimeFilter<"DisabledTime"> | Date | string
    barberId?: StringFilter<"DisabledTime"> | string
    createdAt?: DateTimeFilter<"DisabledTime"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutBarberInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBarberInput, NotificationUncheckedUpdateWithoutBarberInput>
    create: XOR<NotificationCreateWithoutBarberInput, NotificationUncheckedCreateWithoutBarberInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBarberInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBarberInput, NotificationUncheckedUpdateWithoutBarberInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBarberInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBarberInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingServiceCreateWithoutServiceInput = {
    booking: BookingCreateNestedOneWithoutServicesInput
  }

  export type BookingServiceUncheckedCreateWithoutServiceInput = {
    bookingId: string
  }

  export type BookingServiceCreateOrConnectWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceCreateManyServiceInputEnvelope = {
    data: BookingServiceCreateManyServiceInput | BookingServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BarberProfileToServiceCreateWithoutServiceInput = {
    barberProfile: BarberProfileCreateNestedOneWithoutServicesInput
  }

  export type BarberProfileToServiceUncheckedCreateWithoutServiceInput = {
    barberProfileId: string
  }

  export type BarberProfileToServiceCreateOrConnectWithoutServiceInput = {
    where: BarberProfileToServiceWhereUniqueInput
    create: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput>
  }

  export type BarberProfileToServiceCreateManyServiceInputEnvelope = {
    data: BarberProfileToServiceCreateManyServiceInput | BarberProfileToServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type PlanToServiceCreateWithoutServiceInput = {
    plan: PlanCreateNestedOneWithoutPlanToServiceInput
  }

  export type PlanToServiceUncheckedCreateWithoutServiceInput = {
    planId: string
  }

  export type PlanToServiceCreateOrConnectWithoutServiceInput = {
    where: PlanToServiceWhereUniqueInput
    create: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput>
  }

  export type PlanToServiceCreateManyServiceInputEnvelope = {
    data: PlanToServiceCreateManyServiceInput | PlanToServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingServiceScalarWhereInput = {
    AND?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    OR?: BookingServiceScalarWhereInput[]
    NOT?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    bookingId?: StringFilter<"BookingService"> | string
    serviceId?: StringFilter<"BookingService"> | string
  }

  export type BarberProfileToServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BarberProfileToServiceWhereUniqueInput
    update: XOR<BarberProfileToServiceUpdateWithoutServiceInput, BarberProfileToServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BarberProfileToServiceCreateWithoutServiceInput, BarberProfileToServiceUncheckedCreateWithoutServiceInput>
  }

  export type BarberProfileToServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BarberProfileToServiceWhereUniqueInput
    data: XOR<BarberProfileToServiceUpdateWithoutServiceInput, BarberProfileToServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BarberProfileToServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BarberProfileToServiceScalarWhereInput
    data: XOR<BarberProfileToServiceUpdateManyMutationInput, BarberProfileToServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type PlanToServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: PlanToServiceWhereUniqueInput
    update: XOR<PlanToServiceUpdateWithoutServiceInput, PlanToServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<PlanToServiceCreateWithoutServiceInput, PlanToServiceUncheckedCreateWithoutServiceInput>
  }

  export type PlanToServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: PlanToServiceWhereUniqueInput
    data: XOR<PlanToServiceUpdateWithoutServiceInput, PlanToServiceUncheckedUpdateWithoutServiceInput>
  }

  export type PlanToServiceUpdateManyWithWhereWithoutServiceInput = {
    where: PlanToServiceScalarWhereInput
    data: XOR<PlanToServiceUpdateManyMutationInput, PlanToServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type PlanToServiceScalarWhereInput = {
    AND?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
    OR?: PlanToServiceScalarWhereInput[]
    NOT?: PlanToServiceScalarWhereInput | PlanToServiceScalarWhereInput[]
    planId?: StringFilter<"PlanToService"> | string
    serviceId?: StringFilter<"PlanToService"> | string
  }

  export type BarberProfileCreateWithoutServicesInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutServicesInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutServicesInput, BarberProfileUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutBarbersInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBarbersInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBarbersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBarbersInput, ServiceUncheckedCreateWithoutBarbersInput>
  }

  export type BarberProfileUpsertWithoutServicesInput = {
    update: XOR<BarberProfileUpdateWithoutServicesInput, BarberProfileUncheckedUpdateWithoutServicesInput>
    create: XOR<BarberProfileCreateWithoutServicesInput, BarberProfileUncheckedCreateWithoutServicesInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutServicesInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutServicesInput, BarberProfileUncheckedUpdateWithoutServicesInput>
  }

  export type BarberProfileUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type ServiceUpsertWithoutBarbersInput = {
    update: XOR<ServiceUpdateWithoutBarbersInput, ServiceUncheckedUpdateWithoutBarbersInput>
    create: XOR<ServiceCreateWithoutBarbersInput, ServiceUncheckedCreateWithoutBarbersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBarbersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBarbersInput, ServiceUncheckedUpdateWithoutBarbersInput>
  }

  export type ServiceUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BookingCreateWithoutServicesInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServicesInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServicesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    barbers?: BarberProfileToServiceCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    barbers?: BarberProfileToServiceUncheckedCreateNestedManyWithoutServiceInput
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type BookingUpsertWithoutServicesInput = {
    update: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutServicesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    barbers?: BarberProfileToServiceUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    barbers?: BarberProfileToServiceUncheckedUpdateManyWithoutServiceNestedInput
    planToService?: PlanToServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type BarberProfileCreateWithoutBookingsInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutBookingsInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutBookingsInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutBookingsInput, BarberProfileUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ClientPlanCreateWithoutBookingInput = {
    id?: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanInput
    barber: BarberProfileCreateNestedOneWithoutClientPlansInput
    plan: PlanCreateNestedOneWithoutClientPlansInput
  }

  export type ClientPlanUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: string
    barberId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientPlanCreateOrConnectWithoutBookingInput = {
    where: ClientPlanWhereUniqueInput
    create: XOR<ClientPlanCreateWithoutBookingInput, ClientPlanUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceCreateWithoutBookingInput = {
    service: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingServiceUncheckedCreateWithoutBookingInput = {
    serviceId: string
  }

  export type BookingServiceCreateOrConnectWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceCreateManyBookingInputEnvelope = {
    data: BookingServiceCreateManyBookingInput | BookingServiceCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutBookingInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    pointSystem: PointSystemCreateNestedOneWithoutCouponsInput
    notifications?: NotificationCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutBookingInput = {
    id?: string
    pointSystemId: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutBookingInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
  }

  export type NotificationCreateWithoutBookingInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    coupon?: CouponCreateNestedOneWithoutNotificationsInput
    transaction?: PointTransactionCreateNestedOneWithoutNotificationsInput
    barber?: BarberProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutBookingInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationCreateManyBookingInputEnvelope = {
    data: NotificationCreateManyBookingInput | NotificationCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BarberProfileUpsertWithoutBookingsInput = {
    update: XOR<BarberProfileUpdateWithoutBookingsInput, BarberProfileUncheckedUpdateWithoutBookingsInput>
    create: XOR<BarberProfileCreateWithoutBookingsInput, BarberProfileUncheckedCreateWithoutBookingsInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutBookingsInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutBookingsInput, BarberProfileUncheckedUpdateWithoutBookingsInput>
  }

  export type BarberProfileUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClientPlanUpsertWithoutBookingInput = {
    update: XOR<ClientPlanUpdateWithoutBookingInput, ClientPlanUncheckedUpdateWithoutBookingInput>
    create: XOR<ClientPlanCreateWithoutBookingInput, ClientPlanUncheckedCreateWithoutBookingInput>
    where?: ClientPlanWhereInput
  }

  export type ClientPlanUpdateToOneWithWhereWithoutBookingInput = {
    where?: ClientPlanWhereInput
    data: XOR<ClientPlanUpdateWithoutBookingInput, ClientPlanUncheckedUpdateWithoutBookingInput>
  }

  export type ClientPlanUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutClientPlansNestedInput
    plan?: PlanUpdateOneRequiredWithoutClientPlansNestedInput
  }

  export type ClientPlanUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutBookingInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutBookingInput>
  }

  export type CouponUpsertWithoutBookingInput = {
    update: XOR<CouponUpdateWithoutBookingInput, CouponUncheckedUpdateWithoutBookingInput>
    create: XOR<CouponCreateWithoutBookingInput, CouponUncheckedCreateWithoutBookingInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutBookingInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutBookingInput, CouponUncheckedUpdateWithoutBookingInput>
  }

  export type CouponUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pointSystem?: PointSystemUpdateOneRequiredWithoutCouponsNestedInput
    notifications?: NotificationUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
    create: XOR<NotificationCreateWithoutBookingInput, NotificationUncheckedCreateWithoutBookingInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutBookingInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutBookingInput, NotificationUncheckedUpdateWithoutBookingInput>
  }

  export type NotificationUpdateManyWithWhereWithoutBookingInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutBookingInput>
  }

  export type BarberProfileCreateWithoutDisabledDaysInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutDisabledDaysInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutDisabledDaysInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutDisabledDaysInput, BarberProfileUncheckedCreateWithoutDisabledDaysInput>
  }

  export type BarberProfileUpsertWithoutDisabledDaysInput = {
    update: XOR<BarberProfileUpdateWithoutDisabledDaysInput, BarberProfileUncheckedUpdateWithoutDisabledDaysInput>
    create: XOR<BarberProfileCreateWithoutDisabledDaysInput, BarberProfileUncheckedCreateWithoutDisabledDaysInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutDisabledDaysInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutDisabledDaysInput, BarberProfileUncheckedUpdateWithoutDisabledDaysInput>
  }

  export type BarberProfileUpdateWithoutDisabledDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutDisabledDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileCreateWithoutDisabledTimesInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutDisabledTimesInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutDisabledTimesInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutDisabledTimesInput, BarberProfileUncheckedCreateWithoutDisabledTimesInput>
  }

  export type BarberProfileUpsertWithoutDisabledTimesInput = {
    update: XOR<BarberProfileUpdateWithoutDisabledTimesInput, BarberProfileUncheckedUpdateWithoutDisabledTimesInput>
    create: XOR<BarberProfileCreateWithoutDisabledTimesInput, BarberProfileUncheckedCreateWithoutDisabledTimesInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutDisabledTimesInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutDisabledTimesInput, BarberProfileUncheckedUpdateWithoutDisabledTimesInput>
  }

  export type BarberProfileUpdateWithoutDisabledTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutDisabledTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileCreateWithoutExtraTimeDaysInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutExtraTimeDaysInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutExtraTimeDaysInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutExtraTimeDaysInput, BarberProfileUncheckedCreateWithoutExtraTimeDaysInput>
  }

  export type BarberProfileUpsertWithoutExtraTimeDaysInput = {
    update: XOR<BarberProfileUpdateWithoutExtraTimeDaysInput, BarberProfileUncheckedUpdateWithoutExtraTimeDaysInput>
    create: XOR<BarberProfileCreateWithoutExtraTimeDaysInput, BarberProfileUncheckedCreateWithoutExtraTimeDaysInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutExtraTimeDaysInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutExtraTimeDaysInput, BarberProfileUncheckedUpdateWithoutExtraTimeDaysInput>
  }

  export type BarberProfileUpdateWithoutExtraTimeDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutExtraTimeDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type UserCreateWithoutPointSystemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPointSystemInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPointSystemInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointSystemInput, UserUncheckedCreateWithoutPointSystemInput>
  }

  export type CouponCreateWithoutPointSystemInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    booking?: BookingCreateNestedOneWithoutCouponInput
    notifications?: NotificationCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutPointSystemInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    bookingId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutPointSystemInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput>
  }

  export type CouponCreateManyPointSystemInputEnvelope = {
    data: CouponCreateManyPointSystemInput | CouponCreateManyPointSystemInput[]
    skipDuplicates?: boolean
  }

  export type PointTransactionCreateWithoutPointSystemInput = {
    id?: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    notifications?: NotificationCreateNestedManyWithoutTransactionInput
  }

  export type PointTransactionUncheckedCreateWithoutPointSystemInput = {
    id?: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PointTransactionCreateOrConnectWithoutPointSystemInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput>
  }

  export type PointTransactionCreateManyPointSystemInputEnvelope = {
    data: PointTransactionCreateManyPointSystemInput | PointTransactionCreateManyPointSystemInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPointSystemInput = {
    update: XOR<UserUpdateWithoutPointSystemInput, UserUncheckedUpdateWithoutPointSystemInput>
    create: XOR<UserCreateWithoutPointSystemInput, UserUncheckedCreateWithoutPointSystemInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointSystemInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointSystemInput, UserUncheckedUpdateWithoutPointSystemInput>
  }

  export type UserUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CouponUpsertWithWhereUniqueWithoutPointSystemInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutPointSystemInput, CouponUncheckedUpdateWithoutPointSystemInput>
    create: XOR<CouponCreateWithoutPointSystemInput, CouponUncheckedCreateWithoutPointSystemInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutPointSystemInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutPointSystemInput, CouponUncheckedUpdateWithoutPointSystemInput>
  }

  export type CouponUpdateManyWithWhereWithoutPointSystemInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutPointSystemInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: StringFilter<"Coupon"> | string
    pointSystemId?: StringFilter<"Coupon"> | string
    discountPercent?: IntFilter<"Coupon"> | number
    isUsed?: BoolFilter<"Coupon"> | boolean
    usedAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    bookingId?: StringNullableFilter<"Coupon"> | string | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Coupon"> | Date | string | null
  }

  export type PointTransactionUpsertWithWhereUniqueWithoutPointSystemInput = {
    where: PointTransactionWhereUniqueInput
    update: XOR<PointTransactionUpdateWithoutPointSystemInput, PointTransactionUncheckedUpdateWithoutPointSystemInput>
    create: XOR<PointTransactionCreateWithoutPointSystemInput, PointTransactionUncheckedCreateWithoutPointSystemInput>
  }

  export type PointTransactionUpdateWithWhereUniqueWithoutPointSystemInput = {
    where: PointTransactionWhereUniqueInput
    data: XOR<PointTransactionUpdateWithoutPointSystemInput, PointTransactionUncheckedUpdateWithoutPointSystemInput>
  }

  export type PointTransactionUpdateManyWithWhereWithoutPointSystemInput = {
    where: PointTransactionScalarWhereInput
    data: XOR<PointTransactionUpdateManyMutationInput, PointTransactionUncheckedUpdateManyWithoutPointSystemInput>
  }

  export type PointTransactionScalarWhereInput = {
    AND?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    OR?: PointTransactionScalarWhereInput[]
    NOT?: PointTransactionScalarWhereInput | PointTransactionScalarWhereInput[]
    id?: StringFilter<"PointTransaction"> | string
    pointSystemId?: StringFilter<"PointTransaction"> | string
    points?: IntFilter<"PointTransaction"> | number
    type?: EnumTransactionTypeFilter<"PointTransaction"> | $Enums.TransactionType
    description?: StringNullableFilter<"PointTransaction"> | string | null
    bookingId?: StringNullableFilter<"PointTransaction"> | string | null
    createdAt?: DateTimeFilter<"PointTransaction"> | Date | string
    status?: EnumTransactionStatusFilter<"PointTransaction"> | $Enums.TransactionStatus
    confirmedAt?: DateTimeNullableFilter<"PointTransaction"> | Date | string | null
    confirmedBy?: StringNullableFilter<"PointTransaction"> | string | null
  }

  export type PointSystemCreateWithoutCouponsInput = {
    id?: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPointSystemInput
    pointTransactions?: PointTransactionCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemUncheckedCreateWithoutCouponsInput = {
    id?: string
    userId: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pointTransactions?: PointTransactionUncheckedCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemCreateOrConnectWithoutCouponsInput = {
    where: PointSystemWhereUniqueInput
    create: XOR<PointSystemCreateWithoutCouponsInput, PointSystemUncheckedCreateWithoutCouponsInput>
  }

  export type BookingCreateWithoutCouponInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCouponInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCouponInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCouponInput, BookingUncheckedCreateWithoutCouponInput>
  }

  export type NotificationCreateWithoutCouponInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    transaction?: PointTransactionCreateNestedOneWithoutNotificationsInput
    barber?: BarberProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCouponInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCouponInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput>
  }

  export type NotificationCreateManyCouponInputEnvelope = {
    data: NotificationCreateManyCouponInput | NotificationCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type PointSystemUpsertWithoutCouponsInput = {
    update: XOR<PointSystemUpdateWithoutCouponsInput, PointSystemUncheckedUpdateWithoutCouponsInput>
    create: XOR<PointSystemCreateWithoutCouponsInput, PointSystemUncheckedCreateWithoutCouponsInput>
    where?: PointSystemWhereInput
  }

  export type PointSystemUpdateToOneWithWhereWithoutCouponsInput = {
    where?: PointSystemWhereInput
    data: XOR<PointSystemUpdateWithoutCouponsInput, PointSystemUncheckedUpdateWithoutCouponsInput>
  }

  export type PointSystemUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointSystemNestedInput
    pointTransactions?: PointTransactionUpdateManyWithoutPointSystemNestedInput
  }

  export type PointSystemUncheckedUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pointTransactions?: PointTransactionUncheckedUpdateManyWithoutPointSystemNestedInput
  }

  export type BookingUpsertWithoutCouponInput = {
    update: XOR<BookingUpdateWithoutCouponInput, BookingUncheckedUpdateWithoutCouponInput>
    create: XOR<BookingCreateWithoutCouponInput, BookingUncheckedCreateWithoutCouponInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCouponInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCouponInput, BookingUncheckedUpdateWithoutCouponInput>
  }

  export type BookingUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutCouponInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCouponInput, NotificationUncheckedUpdateWithoutCouponInput>
    create: XOR<NotificationCreateWithoutCouponInput, NotificationUncheckedCreateWithoutCouponInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCouponInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCouponInput, NotificationUncheckedUpdateWithoutCouponInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCouponInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCouponInput>
  }

  export type PointSystemCreateWithoutPointTransactionsInput = {
    id?: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPointSystemInput
    coupons?: CouponCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemUncheckedCreateWithoutPointTransactionsInput = {
    id?: string
    userId: string
    currentPoints?: number
    pointsPerService?: number
    pointsNeededForReward?: number
    discountPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponUncheckedCreateNestedManyWithoutPointSystemInput
  }

  export type PointSystemCreateOrConnectWithoutPointTransactionsInput = {
    where: PointSystemWhereUniqueInput
    create: XOR<PointSystemCreateWithoutPointTransactionsInput, PointSystemUncheckedCreateWithoutPointTransactionsInput>
  }

  export type NotificationCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    metadata?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
    booking?: BookingCreateNestedOneWithoutNotificationsInput
    coupon?: CouponCreateNestedOneWithoutNotificationsInput
    barber?: BarberProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput>
  }

  export type NotificationCreateManyTransactionInputEnvelope = {
    data: NotificationCreateManyTransactionInput | NotificationCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type PointSystemUpsertWithoutPointTransactionsInput = {
    update: XOR<PointSystemUpdateWithoutPointTransactionsInput, PointSystemUncheckedUpdateWithoutPointTransactionsInput>
    create: XOR<PointSystemCreateWithoutPointTransactionsInput, PointSystemUncheckedCreateWithoutPointTransactionsInput>
    where?: PointSystemWhereInput
  }

  export type PointSystemUpdateToOneWithWhereWithoutPointTransactionsInput = {
    where?: PointSystemWhereInput
    data: XOR<PointSystemUpdateWithoutPointTransactionsInput, PointSystemUncheckedUpdateWithoutPointTransactionsInput>
  }

  export type PointSystemUpdateWithoutPointTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointSystemNestedInput
    coupons?: CouponUpdateManyWithoutPointSystemNestedInput
  }

  export type PointSystemUncheckedUpdateWithoutPointTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentPoints?: IntFieldUpdateOperationsInput | number
    pointsPerService?: IntFieldUpdateOperationsInput | number
    pointsNeededForReward?: IntFieldUpdateOperationsInput | number
    discountPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUncheckedUpdateManyWithoutPointSystemNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTransactionInput, NotificationUncheckedUpdateWithoutTransactionInput>
    create: XOR<NotificationCreateWithoutTransactionInput, NotificationUncheckedCreateWithoutTransactionInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTransactionInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTransactionInput, NotificationUncheckedUpdateWithoutTransactionInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTransactionInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type BookingCreateWithoutNotificationsInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    plan?: ClientPlanCreateNestedOneWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutNotificationsInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutNotificationsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
  }

  export type CouponCreateWithoutNotificationsInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
    pointSystem: PointSystemCreateNestedOneWithoutCouponsInput
    booking?: BookingCreateNestedOneWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutNotificationsInput = {
    id?: string
    pointSystemId: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    bookingId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type CouponCreateOrConnectWithoutNotificationsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutNotificationsInput, CouponUncheckedCreateWithoutNotificationsInput>
  }

  export type PointTransactionCreateWithoutNotificationsInput = {
    id?: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
    pointSystem: PointSystemCreateNestedOneWithoutPointTransactionsInput
  }

  export type PointTransactionUncheckedCreateWithoutNotificationsInput = {
    id?: string
    pointSystemId: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
  }

  export type PointTransactionCreateOrConnectWithoutNotificationsInput = {
    where: PointTransactionWhereUniqueInput
    create: XOR<PointTransactionCreateWithoutNotificationsInput, PointTransactionUncheckedCreateWithoutNotificationsInput>
  }

  export type BarberProfileCreateWithoutNotificationsInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutNotificationsInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutNotificationsInput, BarberProfileUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingUpsertWithoutNotificationsInput = {
    update: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BookingCreateWithoutNotificationsInput, BookingUncheckedCreateWithoutNotificationsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutNotificationsInput, BookingUncheckedUpdateWithoutNotificationsInput>
  }

  export type BookingUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type CouponUpsertWithoutNotificationsInput = {
    update: XOR<CouponUpdateWithoutNotificationsInput, CouponUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CouponCreateWithoutNotificationsInput, CouponUncheckedCreateWithoutNotificationsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutNotificationsInput, CouponUncheckedUpdateWithoutNotificationsInput>
  }

  export type CouponUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pointSystem?: PointSystemUpdateOneRequiredWithoutCouponsNestedInput
    booking?: BookingUpdateOneWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointTransactionUpsertWithoutNotificationsInput = {
    update: XOR<PointTransactionUpdateWithoutNotificationsInput, PointTransactionUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PointTransactionCreateWithoutNotificationsInput, PointTransactionUncheckedCreateWithoutNotificationsInput>
    where?: PointTransactionWhereInput
  }

  export type PointTransactionUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PointTransactionWhereInput
    data: XOR<PointTransactionUpdateWithoutNotificationsInput, PointTransactionUncheckedUpdateWithoutNotificationsInput>
  }

  export type PointTransactionUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    pointSystem?: PointSystemUpdateOneRequiredWithoutPointTransactionsNestedInput
  }

  export type PointTransactionUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pointSystemId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BarberProfileUpsertWithoutNotificationsInput = {
    update: XOR<BarberProfileUpdateWithoutNotificationsInput, BarberProfileUncheckedUpdateWithoutNotificationsInput>
    create: XOR<BarberProfileCreateWithoutNotificationsInput, BarberProfileUncheckedCreateWithoutNotificationsInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutNotificationsInput, BarberProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type BarberProfileUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type UserCreateWithoutPlanInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlanInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlanInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlanInput, UserUncheckedCreateWithoutPlanInput>
  }

  export type BarberProfileCreateWithoutClientPlansInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    plans?: PlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutClientPlansInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    plans?: PlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutClientPlansInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutClientPlansInput, BarberProfileUncheckedCreateWithoutClientPlansInput>
  }

  export type PlanCreateWithoutClientPlansInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceCreateNestedManyWithoutPlanInput
    barber?: BarberProfileCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutClientPlansInput = {
    id?: string
    barberId?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planToService?: PlanToServiceUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutClientPlansInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutClientPlansInput, PlanUncheckedCreateWithoutClientPlansInput>
  }

  export type BookingCreateWithoutPlanInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    barber: BarberProfileCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    coupon?: CouponCreateNestedOneWithoutBookingInput
    notifications?: NotificationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPlanInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    coupon?: CouponUncheckedCreateNestedOneWithoutBookingInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPlanInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput>
  }

  export type BookingCreateManyPlanInputEnvelope = {
    data: BookingCreateManyPlanInput | BookingCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlanInput = {
    update: XOR<UserUpdateWithoutPlanInput, UserUncheckedUpdateWithoutPlanInput>
    create: XOR<UserCreateWithoutPlanInput, UserUncheckedCreateWithoutPlanInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlanInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlanInput, UserUncheckedUpdateWithoutPlanInput>
  }

  export type UserUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BarberProfileUpsertWithoutClientPlansInput = {
    update: XOR<BarberProfileUpdateWithoutClientPlansInput, BarberProfileUncheckedUpdateWithoutClientPlansInput>
    create: XOR<BarberProfileCreateWithoutClientPlansInput, BarberProfileUncheckedCreateWithoutClientPlansInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutClientPlansInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutClientPlansInput, BarberProfileUncheckedUpdateWithoutClientPlansInput>
  }

  export type BarberProfileUpdateWithoutClientPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    plans?: PlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutClientPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    plans?: PlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type PlanUpsertWithoutClientPlansInput = {
    update: XOR<PlanUpdateWithoutClientPlansInput, PlanUncheckedUpdateWithoutClientPlansInput>
    create: XOR<PlanCreateWithoutClientPlansInput, PlanUncheckedCreateWithoutClientPlansInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutClientPlansInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutClientPlansInput, PlanUncheckedUpdateWithoutClientPlansInput>
  }

  export type PlanUpdateWithoutClientPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUpdateManyWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutClientPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutPlanInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPlanInput, BookingUncheckedUpdateWithoutPlanInput>
    create: XOR<BookingCreateWithoutPlanInput, BookingUncheckedCreateWithoutPlanInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPlanInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPlanInput, BookingUncheckedUpdateWithoutPlanInput>
  }

  export type BookingUpdateManyWithWhereWithoutPlanInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanToServiceCreateWithoutPlanInput = {
    service: ServiceCreateNestedOneWithoutPlanToServiceInput
  }

  export type PlanToServiceUncheckedCreateWithoutPlanInput = {
    serviceId: string
  }

  export type PlanToServiceCreateOrConnectWithoutPlanInput = {
    where: PlanToServiceWhereUniqueInput
    create: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput>
  }

  export type PlanToServiceCreateManyPlanInputEnvelope = {
    data: PlanToServiceCreateManyPlanInput | PlanToServiceCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type ClientPlanCreateWithoutPlanInput = {
    id?: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPlanInput
    barber: BarberProfileCreateNestedOneWithoutClientPlansInput
    booking?: BookingCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    barberId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingUncheckedCreateNestedManyWithoutPlanInput
  }

  export type ClientPlanCreateOrConnectWithoutPlanInput = {
    where: ClientPlanWhereUniqueInput
    create: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput>
  }

  export type ClientPlanCreateManyPlanInputEnvelope = {
    data: ClientPlanCreateManyPlanInput | ClientPlanCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type BarberProfileCreateWithoutPlansInput = {
    id?: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBarberProfileInput
    bookings?: BookingCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeCreateNestedManyWithoutBarberInput
    notifications?: NotificationCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileUncheckedCreateWithoutPlansInput = {
    id?: string
    userId: string
    displayName: string
    bio?: string | null
    timeInterval?: number
    createdAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutBarberInput
    services?: BarberProfileToServiceUncheckedCreateNestedManyWithoutBarberProfileInput
    disabledDays?: DisabledDayUncheckedCreateNestedManyWithoutBarberInput
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutBarberInput
    extraTimeDays?: ExtraTimeDayUncheckedCreateNestedManyWithoutBarberInput
    disabledTimes?: DisabledTimeUncheckedCreateNestedManyWithoutBarberInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutBarberInput
  }

  export type BarberProfileCreateOrConnectWithoutPlansInput = {
    where: BarberProfileWhereUniqueInput
    create: XOR<BarberProfileCreateWithoutPlansInput, BarberProfileUncheckedCreateWithoutPlansInput>
  }

  export type PlanToServiceUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanToServiceWhereUniqueInput
    update: XOR<PlanToServiceUpdateWithoutPlanInput, PlanToServiceUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanToServiceCreateWithoutPlanInput, PlanToServiceUncheckedCreateWithoutPlanInput>
  }

  export type PlanToServiceUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanToServiceWhereUniqueInput
    data: XOR<PlanToServiceUpdateWithoutPlanInput, PlanToServiceUncheckedUpdateWithoutPlanInput>
  }

  export type PlanToServiceUpdateManyWithWhereWithoutPlanInput = {
    where: PlanToServiceScalarWhereInput
    data: XOR<PlanToServiceUpdateManyMutationInput, PlanToServiceUncheckedUpdateManyWithoutPlanInput>
  }

  export type ClientPlanUpsertWithWhereUniqueWithoutPlanInput = {
    where: ClientPlanWhereUniqueInput
    update: XOR<ClientPlanUpdateWithoutPlanInput, ClientPlanUncheckedUpdateWithoutPlanInput>
    create: XOR<ClientPlanCreateWithoutPlanInput, ClientPlanUncheckedCreateWithoutPlanInput>
  }

  export type ClientPlanUpdateWithWhereUniqueWithoutPlanInput = {
    where: ClientPlanWhereUniqueInput
    data: XOR<ClientPlanUpdateWithoutPlanInput, ClientPlanUncheckedUpdateWithoutPlanInput>
  }

  export type ClientPlanUpdateManyWithWhereWithoutPlanInput = {
    where: ClientPlanScalarWhereInput
    data: XOR<ClientPlanUpdateManyMutationInput, ClientPlanUncheckedUpdateManyWithoutPlanInput>
  }

  export type BarberProfileUpsertWithoutPlansInput = {
    update: XOR<BarberProfileUpdateWithoutPlansInput, BarberProfileUncheckedUpdateWithoutPlansInput>
    create: XOR<BarberProfileCreateWithoutPlansInput, BarberProfileUncheckedCreateWithoutPlansInput>
    where?: BarberProfileWhereInput
  }

  export type BarberProfileUpdateToOneWithWhereWithoutPlansInput = {
    where?: BarberProfileWhereInput
    data: XOR<BarberProfileUpdateWithoutPlansInput, BarberProfileUncheckedUpdateWithoutPlansInput>
  }

  export type BarberProfileUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBarberProfileNestedInput
    bookings?: BookingUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUpdateManyWithoutBarberNestedInput
  }

  export type BarberProfileUncheckedUpdateWithoutPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    timeInterval?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutBarberNestedInput
    services?: BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileNestedInput
    disabledDays?: DisabledDayUncheckedUpdateManyWithoutBarberNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutBarberNestedInput
    extraTimeDays?: ExtraTimeDayUncheckedUpdateManyWithoutBarberNestedInput
    disabledTimes?: DisabledTimeUncheckedUpdateManyWithoutBarberNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBarberNestedInput
  }

  export type PlanCreateWithoutPlanToServiceInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPlans?: ClientPlanCreateNestedManyWithoutPlanInput
    barber?: BarberProfileCreateNestedOneWithoutPlansInput
  }

  export type PlanUncheckedCreateWithoutPlanToServiceInput = {
    id?: string
    barberId?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientPlans?: ClientPlanUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPlanToServiceInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPlanToServiceInput, PlanUncheckedCreateWithoutPlanToServiceInput>
  }

  export type ServiceCreateWithoutPlanToServiceInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceCreateNestedManyWithoutServiceInput
    barbers?: BarberProfileToServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPlanToServiceInput = {
    id?: string
    name: string
    price: number
    duration: number
    keyword: string
    imagePath: string
    bookings?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
    barbers?: BarberProfileToServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPlanToServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPlanToServiceInput, ServiceUncheckedCreateWithoutPlanToServiceInput>
  }

  export type PlanUpsertWithoutPlanToServiceInput = {
    update: XOR<PlanUpdateWithoutPlanToServiceInput, PlanUncheckedUpdateWithoutPlanToServiceInput>
    create: XOR<PlanCreateWithoutPlanToServiceInput, PlanUncheckedCreateWithoutPlanToServiceInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutPlanToServiceInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutPlanToServiceInput, PlanUncheckedUpdateWithoutPlanToServiceInput>
  }

  export type PlanUpdateWithoutPlanToServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPlans?: ClientPlanUpdateManyWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutPlansNestedInput
  }

  export type PlanUncheckedUpdateWithoutPlanToServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ServiceUpsertWithoutPlanToServiceInput = {
    update: XOR<ServiceUpdateWithoutPlanToServiceInput, ServiceUncheckedUpdateWithoutPlanToServiceInput>
    create: XOR<ServiceCreateWithoutPlanToServiceInput, ServiceUncheckedCreateWithoutPlanToServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPlanToServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPlanToServiceInput, ServiceUncheckedUpdateWithoutPlanToServiceInput>
  }

  export type ServiceUpdateWithoutPlanToServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUpdateManyWithoutServiceNestedInput
    barbers?: BarberProfileToServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPlanToServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    imagePath?: StringFieldUpdateOperationsInput | string
    bookings?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
    barbers?: BarberProfileToServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileCreateNestedOneWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemCreateNestedOneWithoutUserInput
    plan?: ClientPlanCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    phone?: string | null
    createdAt?: Date | string
    role?: $Enums.Role
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    barberProfile?: BarberProfileUncheckedCreateNestedOneWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pointSystem?: PointSystemUncheckedCreateNestedOneWithoutUserInput
    plan?: ClientPlanUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUpdateOneWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    barberProfile?: BarberProfileUncheckedUpdateOneWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pointSystem?: PointSystemUncheckedUpdateOneWithoutUserNestedInput
    plan?: ClientPlanUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type BookingCreateManyUserInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    planId?: string | null
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    coupon?: CouponUpdateOneWithoutNotificationsNestedInput
    transaction?: PointTransactionUpdateOneWithoutNotificationsNestedInput
    barber?: BarberProfileUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyBarberInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    planId?: string | null
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
  }

  export type BarberProfileToServiceCreateManyBarberProfileInput = {
    serviceId: string
  }

  export type DisabledDayCreateManyBarberInput = {
    id?: string
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type ClientPlanCreateManyBarberInput = {
    id?: string
    userId: string
    planId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanCreateManyBarberInput = {
    id?: string
    name: string
    price: number
    keyword?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExtraTimeDayCreateManyBarberInput = {
    id?: string
    date: Date | string
    amount: number
    createdAT?: Date | string
  }

  export type DisabledTimeCreateManyBarberInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyBarberInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    plan?: ClientPlanUpdateOneWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BarberProfileToServiceUpdateWithoutBarberProfileInput = {
    service?: ServiceUpdateOneRequiredWithoutBarbersNestedInput
  }

  export type BarberProfileToServiceUncheckedUpdateWithoutBarberProfileInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BarberProfileToServiceUncheckedUpdateManyWithoutBarberProfileInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type DisabledDayUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledDayUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledDayUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientPlanUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanNestedInput
    plan?: PlanUpdateOneRequiredWithoutClientPlansNestedInput
    booking?: BookingUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUpdateManyWithoutPlanNestedInput
    clientPlans?: ClientPlanUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planToService?: PlanToServiceUncheckedUpdateManyWithoutPlanNestedInput
    clientPlans?: ClientPlanUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtraTimeDayUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: IntFieldUpdateOperationsInput | number
    createdAT?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisabledTimeUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    coupon?: CouponUpdateOneWithoutNotificationsNestedInput
    transaction?: PointTransactionUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceCreateManyServiceInput = {
    bookingId: string
  }

  export type BarberProfileToServiceCreateManyServiceInput = {
    barberProfileId: string
  }

  export type PlanToServiceCreateManyServiceInput = {
    planId: string
  }

  export type BookingServiceUpdateWithoutServiceInput = {
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutServiceInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceInput = {
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type BarberProfileToServiceUpdateWithoutServiceInput = {
    barberProfile?: BarberProfileUpdateOneRequiredWithoutServicesNestedInput
  }

  export type BarberProfileToServiceUncheckedUpdateWithoutServiceInput = {
    barberProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type BarberProfileToServiceUncheckedUpdateManyWithoutServiceInput = {
    barberProfileId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanToServiceUpdateWithoutServiceInput = {
    plan?: PlanUpdateOneRequiredWithoutPlanToServiceNestedInput
  }

  export type PlanToServiceUncheckedUpdateWithoutServiceInput = {
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanToServiceUncheckedUpdateManyWithoutServiceInput = {
    planId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingServiceCreateManyBookingInput = {
    serviceId: string
  }

  export type NotificationCreateManyBookingInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    couponId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type BookingServiceUpdateWithoutBookingInput = {
    service?: ServiceUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutBookingInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    coupon?: CouponUpdateOneWithoutNotificationsNestedInput
    transaction?: PointTransactionUpdateOneWithoutNotificationsNestedInput
    barber?: BarberProfileUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyPointSystemInput = {
    id?: string
    discountPercent: number
    isUsed?: boolean
    usedAt?: Date | string | null
    bookingId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PointTransactionCreateManyPointSystemInput = {
    id?: string
    points: number
    type: $Enums.TransactionType
    description?: string | null
    bookingId?: string | null
    createdAt?: Date | string
    status?: $Enums.TransactionStatus
    confirmedAt?: Date | string | null
    confirmedBy?: string | null
  }

  export type CouponUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneWithoutCouponNestedInput
    notifications?: NotificationUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    discountPercent?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointTransactionUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUpdateManyWithoutTransactionNestedInput
  }

  export type PointTransactionUncheckedUpdateWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PointTransactionUncheckedUpdateManyWithoutPointSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyCouponInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    transactionId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    transaction?: PointTransactionUpdateOneWithoutNotificationsNestedInput
    barber?: BarberProfileUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyTransactionInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    read?: boolean
    recipientType?: $Enums.NotificationRecipient
    barberId?: string | null
    userId?: string | null
    bookingId?: string | null
    couponId?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
    booking?: BookingUpdateOneWithoutNotificationsNestedInput
    coupon?: CouponUpdateOneWithoutNotificationsNestedInput
    barber?: BarberProfileUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    recipientType?: EnumNotificationRecipientFieldUpdateOperationsInput | $Enums.NotificationRecipient
    barberId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyPlanInput = {
    id?: string
    date: Date | string
    status: $Enums.BookingStatus
    userId: string
    barberId: string
    totalPrice: number
    totalDuration: number
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    barber?: BarberProfileUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    coupon?: CouponUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    coupon?: CouponUncheckedUpdateOneWithoutBookingNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    totalDuration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanToServiceCreateManyPlanInput = {
    serviceId: string
  }

  export type ClientPlanCreateManyPlanInput = {
    id?: string
    userId: string
    barberId: string
    useAmount: number
    starts?: Date | string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanToServiceUpdateWithoutPlanInput = {
    service?: ServiceUpdateOneRequiredWithoutPlanToServiceNestedInput
  }

  export type PlanToServiceUncheckedUpdateWithoutPlanInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type PlanToServiceUncheckedUpdateManyWithoutPlanInput = {
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientPlanUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlanNestedInput
    barber?: BarberProfileUpdateOneRequiredWithoutClientPlansNestedInput
    booking?: BookingUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type ClientPlanUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    barberId?: StringFieldUpdateOperationsInput | string
    useAmount?: IntFieldUpdateOperationsInput | number
    starts?: DateTimeFieldUpdateOperationsInput | Date | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}